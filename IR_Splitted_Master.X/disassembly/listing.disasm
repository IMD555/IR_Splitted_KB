Disassembly Listing for IR_Splitted_Master
Generated From:
C:/Users/imada/OneDrive/Documents/MPLAB X/IR_Splitted_KB/IR_Splitted_Master.X/dist/Configuration/production/IR_Splitted_Master.X.production.elf
Dec 3, 2018 2:41:04 AM

---  C:/Users/imada/OneDrive/Documents/MPLAB X/IR_Splitted_KB/IR_Splitted_Master.X/usb_hal_16bit.c  -----
1:                 // DOM-IGNORE-BEGIN
2:                 /*******************************************************************************
3:                 Copyright 2015 Microchip Technology Inc. (www.microchip.com)
4:                 
5:                 Licensed under the Apache License, Version 2.0 (the "License");
6:                 you may not use this file except in compliance with the License.
7:                 You may obtain a copy of the License at
8:                 
9:                     http://www.apache.org/licenses/LICENSE-2.0
10:                
11:                Unless required by applicable law or agreed to in writing, software
12:                distributed under the License is distributed on an "AS IS" BASIS,
13:                WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
14:                See the License for the specific language governing permissions and
15:                limitations under the License.
16:                
17:                To request to license the code under the MLA license (www.microchip.com/mla_license), 
18:                please contact mla_licensing@microchip.com
19:                *******************************************************************************/
20:                //DOM-IGNORE-END
21:                
22:                #ifndef __USB_HAL_16BIT_C
23:                #define __USB_HAL_16BIT_C
24:                
25:                #include "usb.h"
26:                
27:                //The code in this file is only intended for use with the 16-bit PIC24/dsPIC devices.
28:                //See other hal file for other microcontrollers.
29:                #if defined(__XC16__) || defined(__C30__)
30:                
31:                
32:                
33:                
34:                //Private prototypes - do not call directly from application code.
35:                static void USBSaveAndPrepareInterruptsForSleep(void);
36:                static void USBRestorePreviousInterruptSettings(void);
37:                
38:                
39:                //Private static variables needed for context saving operations.  Do not use/touch
40:                //outside of the context of the implemented APIs.
41:                static unsigned int CPUIPLSave;
42:                static unsigned int IECRegSaves[DEVICE_SPECIFIC_IEC_REGISTER_COUNT];
43:                static unsigned int U1IE_save;
44:                static unsigned int U1OTGIE_save;
45:                static unsigned int USBIPLSave;
46:                static unsigned char USBIESave;
47:                
48:                
49:                
50:                
51:                /********************************************************************
52:                Function:
53:                    bool USBSleepOnSuspend(void)
54:                    
55:                Summary:
56:                    Places the core into sleep and sets up the USB module
57:                    to wake up the device on USB activity.
58:                    
59:                PreCondition:
60:                    
61:                Parameters:
62:                    None
63:                    
64:                Return Values:
65:                    true  - if entered sleep successfully
66:                    false - if there was an error entering sleep
67:                    
68:                Remarks:
69:                    Please note that before calling this function that it is the
70:                    responsibility of the application to place all of the other
71:                    peripherals or board features into a lower power state if
72:                    required.
73:                
74:                    Based on the USB specifications, upon detection of the suspend condition, a
75:                    USB device should promptly put itself into a low power mode (such that it consumes
76:                    no more than 2.5mA from the USB host (unless the host is a USB type-C host and
77:                    is actively advertising higher than standard USB spec current capability).
78:                
79:                *******************************************************************/
80:                bool USBSleepOnSuspend(void)
81:                {
00149E  FA0000     LNK #0x0
82:                    //This function needs to reconfigure the device interrupt settings so it can
83:                    //properly wake up from suspend on USB activity, or, upon remote wakeup trigger source
84:                    //events (when the host has allowed remote wakeup).  In order to achieve this,
85:                    //we need to context save all interrupt settings, then disable everything, except
86:                    //the very minimum needed to wake the microcontroller.
87:                    USBSaveAndPrepareInterruptsForSleep();
0014A0  0700A6     RCALL _USBSaveAndPrepareInterruptsForSleep, .LFE4, .LFB5
88:                
89:                
90:                    //Enable remote wakeup interrupt now, but only if applicable/legal to do so.
91:                    if((USBGetRemoteWakeupStatus() == true) && (USBIsBusSuspended() == true))
0014A2  BFC814     MOV.B RemoteWakeup, WREG
0014A4  E00400     CP0.B W0
0014A6  320001     BRA Z, .L2
0014A8  BFC815     MOV.B USBBusIsSuspended, WREG
92:                    {
93:                        //If using remote wakeup capability, you must add code here to enable the remote
94:                        //wakeup stimulus to wake the microcontroller from sleep here.
95:                        //Do not enable any other interrupt sources here, except the remote wakeup stimulus
96:                        //source.  Example code for enabling a user pushbutton for example might look
97:                        //something like follows:
98:                        //CNEN1 = 0;
99:                        //CNEN2 = 0;
100:                       //CNEN3 = 0;
101:                       //CNEN4 = 0;
102:                       //CNEN5 = 0;
103:                       //CNEN6 = 0;
104:                       //CNENxbits.CNxxIE = 1; //The individual pin interrupt source to use as the remote wakeup stimulus
105:                       //IFS1bits.CNIF = 0;
106:                       //IPC4bits.CNIP = 4;    //IP >= 1, to allow it to cause wake from sleep.
107:                       //IEC1bits.CNIE = 1;
108:                   }
109:               
110:               
111:                   //Stop clocks and put the microcontroller core to sleep now.
112:                   Sleep();
0014AA  FE4000     PWRSAV #0
113:               
114:               
115:                   //Check wakeup source, to make sure it was due to host sending resume signalling
116:                   //(or the device becoming detached from the host)
117:                   if(USBRESUMEIF == 0)
0014AC  802051     MOV U1IR, W1
0014AE  200200     MOV #0x20, W0
0014B0  608000     AND W1, W0, W0
0014B2  E00000     CP0 W0
0014B4  3A0002     BRA NZ, .L3
118:                   {
119:                       //We woke up by some means other than resume from the host.  Figure out what that source was.
120:                       
121:                       //Check the VBUS level.  If VBUS is no longer present, then a user detach event
122:                       //must have occurred, or, the cable is still plugged in, but the host itself
123:                       //powered down.
124:                       if(USBVBUSSessionValidStateGet(true) == 0)
0014B6  B3C010     MOV.B #0x1, W0
0014B8  070041     RCALL USBVBUSSessionValidStateGet
125:                       {
126:                           //A detach event has occurred.  You may optionally stay awake and
127:                           //continue executing code in this case, or, go back to sleep until
128:                           //the next re-attachment event.
129:               
130:                       }
131:               
132:               
133:                       //Check if the wakeup was due to the (optional) remote wakeup source, and if
134:                       //it is actually legal to perform a remote wakeup.
135:                       #if 0
136:                       if(YOUR_REMOTE_WAKEUP_TRIGGER_SOURCE_ASSERTED)      //Replace YOUR_REMOTE_WAKEUP_TRIGGER_SOURCE_ASSERTED with your proper interrupt source (such as: _CNIF == 1)
137:                       {
138:                           //Try to wake up the host.
139:                           USBRemoteWakeupAssertBlocking();
140:                       }
141:                       #endif        
142:                   }
143:               
144:               
145:                   //Restore all interrupt settings back to what they were before at the start
146:                   //of this function.  According to the USB specs, USB devices should return
147:                   //to their exact same USB state/operating condition after the end of suspend,
148:                   //as they were in prior to entering suspend.
149:                   USBRestorePreviousInterruptSettings();
0014BA  0700D2     RCALL _USBRestorePreviousInterruptSettings, .LFE5, .LFB6
150:                   
151:                   return true;
0014BC  B3C010     MOV.B #0x1, W0
152:               }
0014BE  FA8000     ULNK
0014C0  060000     RETURN
153:               
154:               
155:               
156:               
157:               
158:               
159:               /********************************************************************
160:               Function:
161:                   bool USBRemoteWakeupAssertBlocking(void)
162:               
163:               Summary:
164:                   Checks if it is currently legal to send remote wakeup signalling to the
165:                   host, and if so, it sends it.  This is a blocking function that takes ~5-6ms
166:                   to execute.
167:               
168:               PreCondition:
169:               
170:               Parameters:
171:                   None
172:               
173:               Return Values:
174:                   true  - if it was legal to send remote wakeup signalling and the signalling was sent
175:                   false - if it was not legal to send remote wakeup signalling (in this case, no signalling gets sent)
176:               
177:               Remarks:
178:                   To successfully use remote wakeup in an application, the device must first
179:                   let the host know that it supports remote wakeup (by setting the appropriate
180:                   bit in the attributes field of the USB configuration descriptor).  Additionally,
181:                   the end user must allow/enable remote wakeup for the device.  Hosts are not
182:                   obligated to always allow remote wakeup, and the end user can typically enable/disable this
183:                   feature for each device at their discretion.  Under Windows, devices supporting
184:                   remote wakeup will normally have an extra checkbox setting under the device
185:                   manager properties pages for the device, which the user can change.
186:               
187:                   Additionally, remote wakeup capability requires driver support, in the USB
188:                   class drivers being used for the device on the host.  Under Windows 7, the CDC
189:                   drivers do not support remote wakeup capability, while other drivers like HID
190:                   and WinUSB fully support this capability.  If the intended application is
191:                   CDC or based on some other driver not supporting remote wakeup, it is potentially
192:                   possible to make the device a composite device (ex: CDC+HID) and then use the
193:                   HID driver as a means of achieving the remote wakeup effect of the host.
194:               
195:                   Sometime prior to entering USB suspend (usually just prior), if the host and
196:                   driver(s) support remote wakeup, and the user has enabled the feature for the
197:                   device, then the host will send notification to the device firmware letting it
198:                   know that remote wakeup is legal.  The USBGetRemoteWakeupStatus() API function
199:                   can be used to check if the host has allowed remote wakeup or not.  The application
200:                   firmware should not send remote wakeup signalling to the host, unless both
201:                   USBGetRemoteWakeupStatus() and USBIsBusSuspended() return true.  Attempting to
202:                   send the remote wakeup signalling to the host when it is not legal to do so
203:                   will nomrally not wake up the host, and will instead create a violation of
204:                   the USB compliance criteria.  Additionally, devices should not send remote
205:                   wakeup signalling immediately upon entry into the suspended bus state.  Based on
206:                   the USB specifications, the bus must be continuously idle for at least 5ms before
207:                   a device may send remote wakeup signalling.  After the signalling is sent, the
208:                   device must become fully ready for normal USB communication/request
209:                   processing within 10ms.
210:                *******************************************************************/
211:               bool USBRemoteWakeupAssertBlocking(void)
212:               {
0014C2  FA0000     LNK #0x0
213:                   //Make sure we are in a state where it is legal to send remote wakeup signalling
214:                   if((USBGetRemoteWakeupStatus() == true) && (USBIsBusSuspended() == true))
0014C4  BFC814     MOV.B RemoteWakeup, WREG
0014C6  E00400     CP0.B W0
0014C8  320036     BRA Z, .L5
0014CA  BFC815     MOV.B USBBusIsSuspended, WREG
0014CC  E00400     CP0.B W0
0014CE  320033     BRA Z, .L5
215:                   {
216:                       //Make sure the USB module is not suspended.  We need it to be clocked and
217:                       //fully operational.
218:                       if(USBSuspendControl == 1)
0014D0  802040     MOV U1PWRC, W0
0014D2  600062     AND W0, #0x2, W0
0014D4  E00000     CP0 W0
0014D6  320001     BRA Z, .L6
219:                       {
220:                           USBSuspendControl = 0;
0014D8  A92408     BCLR U1PWRC, #1
221:                       }
222:               
223:                       USBMaskAllUSBInterrupts();  //Temporarily disable USB interrupts, to prevent the stack from using/gobbling up the T1MSECIF events if USB interrupts are enabled/used.
0014DA  070075     RCALL USBMaskAllUSBInterrupts
224:               
225:                       //USB specs require the device not send resume signalling within the first 5ms of bus idle time.
226:                       //Since it takes 3ms of continuous idle for the suspend condition to occur,
227:                       //this means the firmware must wait a minimum of two additional milliseconds
228:                       //from the point that suspend is detected before sending the resume signalling.
229:                       //To ensure that this requirement is always met, we add deliberate delay
230:                       //below, to wait 2-3ms of extra time, before starting to send the resume signalling.
231:                       USBClearInterruptFlag(USBT1MSECIFReg, USBT1MSECIFBitNum);
0014DC  200400     MOV #0x40, W0
0014DE  882000     MOV W0, U1OTGIR
232:                       while(U1OTGIRbits.T1MSECIF == 0);   //Wait 0-1 ms
0014E0  000000     NOP
0014E2  802001     MOV U1OTGIR, W1
0014E4  200400     MOV #0x40, W0
0014E6  608000     AND W1, W0, W0
0014E8  E00000     CP0 W0
0014EA  32FFFB     BRA Z, .L7
233:                       USBClearInterruptFlag(USBT1MSECIFReg, USBT1MSECIFBitNum);
0014EC  200400     MOV #0x40, W0
0014EE  882000     MOV W0, U1OTGIR
234:                       while(U1OTGIRbits.T1MSECIF == 0);   //Wait 1 full ms
0014F0  000000     NOP
0014F2  802001     MOV U1OTGIR, W1
0014F4  200400     MOV #0x40, W0
0014F6  608000     AND W1, W0, W0
0014F8  E00000     CP0 W0
0014FA  32FFFB     BRA Z, .L8
235:                       USBClearInterruptFlag(USBT1MSECIFReg, USBT1MSECIFBitNum);
0014FC  200400     MOV #0x40, W0
0014FE  882000     MOV W0, U1OTGIR
236:                       while(U1OTGIRbits.T1MSECIF == 0);   //Wait 1 full ms
001500  000000     NOP
001502  802001     MOV U1OTGIR, W1
001504  200400     MOV #0x40, W0
001506  608000     AND W1, W0, W0
001508  E00000     CP0 W0
00150A  32FFFB     BRA Z, .L9
237:               
238:                       //Begin sending the actual resume K-state signalling to the host
239:                       USBResumeControl = 1;       //Start RESUME signaling
00150C  A84414     BSET U1CON, #2
240:               
241:                       //USB specs require the RESUME signalling to persist for 1-15ms in duration.
242:                       USBClearInterruptFlag(USBT1MSECIFReg, USBT1MSECIFBitNum);
00150E  200400     MOV #0x40, W0
001510  882000     MOV W0, U1OTGIR
243:                       while(U1OTGIRbits.T1MSECIF == 0);   //Wait 0-1 ms
001512  000000     NOP
001514  802001     MOV U1OTGIR, W1
001516  200400     MOV #0x40, W0
001518  608000     AND W1, W0, W0
00151A  E00000     CP0 W0
00151C  32FFFB     BRA Z, .L10
244:                       USBClearInterruptFlag(USBT1MSECIFReg, USBT1MSECIFBitNum);
00151E  200400     MOV #0x40, W0
001520  882000     MOV W0, U1OTGIR
245:                       while(U1OTGIRbits.T1MSECIF == 0);   //Wait 1 full ms
001522  000000     NOP
001524  802001     MOV U1OTGIR, W1
001526  200400     MOV #0x40, W0
001528  608000     AND W1, W0, W0
00152A  E00000     CP0 W0
00152C  32FFFB     BRA Z, .L11
246:                       USBResumeControl = 0;       //Stop driving resume signalling
00152E  A94414     BCLR U1CON, #2
247:               
248:                       //Restore previous interrupt settings that we may have changed.
249:                       USBRestoreUSBInterrupts();
001530  070057     RCALL USBRestoreUSBInterrupts
250:               
251:                       //We sent the signalling and the host should be waking up now.
252:                       return true;
001532  B3C010     MOV.B #0x1, W0
001534  370001     BRA .L12
253:                   }
254:               
255:                   //Wasn't legal to send remote wakeup signalling to the host.  We must return
256:                   //without actually doing anything.
257:                   return false;
001536  EB4000     CLR.B W0
258:               }
001538  FA8000     ULNK
00153A  060000     RETURN
259:               
260:               
261:               
262:               
263:               
264:               /********************************************************************
265:               Function:
266:                   int8_t USBVBUSSessionValidStateGet(bool AllowInvasiveReads)
267:               
268:               Summary:
269:                   This function tries to check the current VBUS voltage level to see if it is
270:                   above the session valid threshold or not.  This is useful for detecting if the
271:                   device is currently attached to a host or hub that is actively supplying
272:                   power on the +5V VBUS net (instead of being powered down).
273:               
274:               PreCondition:
275:                   This function assumes that USBDeviceInit() has been called at least once,
276:                   although it is not necessary for the USB module to be already enabled, if
277:                   "invasive reads" are allowed.  However, it is always the caller's responsibility
278:                   to make sure that the microcontroller system clock settings have been
279:                   pre-configured for an operating mode that are compatible with USB operation
280:                   at the right frequency (ex: the USB module must have 48MHz clocking available
281:                   internally), prior to calling this function.
282:               
283:               Parameters:
284:                   bool AllowInvasiveReads - Specify false if you want this function to perform
285:                   a "passive" read attempt, which will not block or change the state of the USB module.
286:                   If this parameter is false, the function can return a negative number, indicating
287:                   that the read could not be performed (ex: if the comparators are currently off).
288:               
289:                   Specify true, if you want this function to perform a forceful read operation.
290:                   In this case, this function will turn on the USB module and/or unsuspend it if
291:                   needed, in order to read the actual value.  The function will always return 0 or 1
292:                   in this case.  However, the function may block for as much time as required to
293:                   ensure that any necessary analog startup/settling/propagation times have
294:                   elapsed, so as to get an accurate reading.  If invasive reads are allowed, and
295:                   this function turns on the USB module or unsuspends it, the module will remain
296:                   on and unsuspended subsequent to returning from this function.
297:                   It is the caller's responsibility to turn the USB module off if
298:                   desired/appropriate for the application (ex: because the returned value was
299:                   0, indicating VBUS is not currently powered, in which case the application may
300:                   wish to shut things down for lower power consumption).
301:               
302:               
303:               Return Values:
304:                   Returns a signed 8-bit byte indicating the current VBUS level.  If VBUS is above
305:                   the session valid state (ex: because the cable is attached and a host or hub is actively
306:                   sourcing VBUS power), the return value will be 1.  If the VBUS level is below
307:                   the session valid level (ex: because the cable is detached or the host/hub is
308:                   powered down and not sourcing anything on VBUS), the return value will be 0.
309:                   If the function could not conclusively determine the state of the VBUS line
310:                   (ex: because the VBUS sensing comparator wasn't powered on for example), the
311:                   return value will be a negative number (ex: return value of -1 or less, with
312:                   the actual value indicating a code representing the reason why the value
313:                   couldn't be read).
314:               
315:               Remarks:
316:                   This function may block for upwards of ~5ms if AllowInvasiveReads was true
317:                   and the USB module wasn't previously turned or or was recently (or is still) suspended.
318:               
319:                *******************************************************************/
320:               int8_t USBVBUSSessionValidStateGet(bool AllowInvasiveReads)
321:               {
00153C  FA0004     LNK #0x4
00153E  984720     MOV.B W0, [W14+2]
322:                   unsigned char i;
323:                   int8_t retValue;
324:               
325:                   //Check if module is already on and non-suspended
326:                   if((U1PWRCbits.USBPWR == 1) && (USBSuspendControl == 0) && (USBGetTicksSinceSuspendEnd() >= 4))
001540  802040     MOV U1PWRC, W0
001542  600061     AND W0, #0x1, W0
001544  E00000     CP0 W0
001546  32000B     BRA Z, .L14
001548  802040     MOV U1PWRC, W0
00154A  600062     AND W0, #0x2, W0
00154C  E00000     CP0 W0
00154E  3A0007     BRA NZ, .L14
001550  BFC824     MOV.B USBTicksSinceSuspendEnd, WREG
001552  504FE3     SUB.B W0, #0x3, [W15]
001554  360004     BRA LEU, .L14
327:                   {
328:                       return U1OTGSTATbits.SESVD;
001556  802020     MOV U1OTGSTAT, W0
001558  DE0043     LSR W0, #3, W0
00155A  604061     AND.B W0, #0x1, W0
00155C  370032     BRA .L15
329:                   }
330:                   else
331:                   {
332:                       //The module wasn't in a state where we can rely on the SESVD bit value yet.
333:                       if(AllowInvasiveReads == true)
00155E  90402E     MOV.B [W14+2], W0
001560  E00400     CP0.B W0
001562  32001D     BRA Z, .L16
334:                       {
335:                           //Turn on the module and make sure it is not suspended.
336:                           USBSuspendControl = 0;
001564  A92408     BCLR U1PWRC, #1
337:                           USBPowerModule();
001566  A80408     BSET U1PWRC, #0
338:               
339:                           //Make sure USB interrupt vectoring is disabled, to prevent interrupt
340:                           //handler from "stealing" the T1MSECIF events and clearing the flag before returning.
341:                           USBMaskAllUSBInterrupts();
001568  07002E     RCALL USBMaskAllUSBInterrupts
342:               
343:                           //Wait ~4-5ms analog settling time for bandgap and comparators to
344:                           //power up, and at least one comparator propagation delay has elapsed,
345:                           //so as to provide trustworthy output status.
346:                           for(i = 0; i < 5; i++)
00156A  EB4000     CLR.B W0
00156C  784F00     MOV.B W0, [W14]
00156E  370009     BRA .L17
001580  E84F1E     INC.B [W14], [W14]
001582  78401E     MOV.B [W14], W0
001584  504FE4     SUB.B W0, #0x4, [W15]
001586  36FFF4     BRA LEU, .L19
347:                           {
348:                               USBClearInterruptFlag(USBT1MSECIFReg, USBT1MSECIFBitNum);
001570  200400     MOV #0x40, W0
001572  882000     MOV W0, U1OTGIR
349:                               while(USBT1MSECIF == 0);   //Wait for assertion
001574  000000     NOP
001576  802001     MOV U1OTGIR, W1
001578  200400     MOV #0x40, W0
00157A  608000     AND W1, W0, W0
00157C  E00000     CP0 W0
00157E  32FFFB     BRA Z, .L18
350:                           }
351:               
352:                           //The SESVD bit value should now be trustworthy to read.
353:                           retValue = 0;
001588  EB4000     CLR.B W0
00158A  984710     MOV.B W0, [W14+1]
354:                           if(U1OTGSTATbits.SESVD == 1)
00158C  802020     MOV U1OTGSTAT, W0
00158E  600068     AND W0, #0x8, W0
001590  E00000     CP0 W0
001592  320002     BRA Z, .L20
355:                           {
356:                               retValue = 1;
001594  B3C010     MOV.B #0x1, W0
001596  984710     MOV.B W0, [W14+1]
357:                           }
358:               
359:                           //Restore normal USB interrupt settings.
360:                           USBRestoreUSBInterrupts();
001598  070023     RCALL USBRestoreUSBInterrupts
361:                               
362:                           return retValue;
00159A  90401E     MOV.B [W14+1], W0
00159C  370012     BRA .L15
363:                       }
364:                       else
365:                       {
366:                           //Couldn't read the value...  Module is not in a state where the 
367:                           //value can be meaningful, and the caller didn't allow us to make
368:                           //module setting changes.
369:               
370:                           if(U1PWRCbits.USBPWR == 0)
00159E  802040     MOV U1PWRC, W0
0015A0  600061     AND W0, #0x1, W0
0015A2  E00000     CP0 W0
0015A4  3A0002     BRA NZ, .L21
371:                           {
372:                               return -1;  //-1 indicates the USB module wasn't powered
0015A6  EBC000     SETM.B W0
0015A8  37000C     BRA .L15
373:                           }
374:                           else if(USBSuspendControl == 0)
0015AA  802040     MOV U1PWRC, W0
0015AC  600062     AND W0, #0x2, W0
0015AE  E00000     CP0 W0
0015B0  3A0002     BRA NZ, .L22
375:                           {
376:                               return -2;   //-2 indicates the USB module was powered, but was suspended
0015B2  B3CFE0     MOV.B #0xFE, W0
0015B4  370006     BRA .L15
377:                           }
378:                           else if(USBGetTicksSinceSuspendEnd() < 4)
0015B6  BFC824     MOV.B USBTicksSinceSuspendEnd, WREG
0015B8  504FE3     SUB.B W0, #0x3, [W15]
0015BA  3E0002     BRA GTU, .L23
379:                           {
380:                               return -3;  //-3 indicates the USB module was powered and not suspended,
0015BC  B3CFD0     MOV.B #0xFD, W0
0015BE  370001     BRA .L15
381:                                           //but that insufficient settling time has elapsed yet to
382:                                           //get a trustworthy reading.
383:                           }
384:               
385:                           //Shouldn't get here.
386:                           return -4;
0015C0  B3CFC0     MOV.B #0xFC, W0
387:                       }
388:                   }
389:               }
0015C2  FA8000     ULNK
0015C4  060000     RETURN
390:               
391:               
392:               
393:               
394:               
395:               /********************************************************************
396:               Function:
397:                   void USBMaskAllUSBInterrupts(void)
398:               
399:               Summary:
400:                   This function saves the current USBIE bit state, and then clears it
401:                   to prevent any USB interrupt vectoring.
402:               
403:               PreCondition:
404:                   None
405:               
406:               Parameters:
407:                   None
408:               
409:               Return Values:
410:                   None
411:               
412:               Remarks:
413:                    This function should always be called in a exact 1:1 ratio with the
414:                    corresponding USBRestoreUSBInterrupts() function (which restores the
415:                    setting saved by this function).  This function should not be called
416:                    more than once, prior to calling USBRestoreUSBInterrupts(),
417:                    as this will cause the previously saved value to get overwritten.
418:                 *******************************************************************/
419:               void USBMaskAllUSBInterrupts(void)
420:               {
0015C6  FA0000     LNK #0x0
421:                   //Save and clear the USBIE bit to prevent USB interrupt vectoring.
422:                   USBIESave = 0;
0015C8  EF682E     CLR.B USBIESave
423:                   __builtin_disi(16); //Temporarily disable all interrupts, to prevent an
0015CA  FC0010     DISI #0x10
424:                                       //ISR from modifying the xxxIE bit between our read
425:                                       //of the value, and when we clear it.
426:                   if(_USB1IE == 1)
0015CC  8004F1     MOV IEC5, W1
0015CE  200400     MOV #0x40, W0
0015D0  608000     AND W1, W0, W0
0015D2  E00000     CP0 W0
0015D4  320002     BRA Z, .L25
427:                   {
428:                       USBIESave = 1;
0015D6  B3C010     MOV.B #0x1, W0
0015D8  B7E82E     MOV.B WREG, USBIESave
429:                   }
430:                   _USB1IE = 0;        //Disable USB interrupt vectoring.
0015DA  A9C09E     BCLR IEC5, #6
431:               }
0015DC  FA8000     ULNK
0015DE  060000     RETURN
432:               
433:               
434:               
435:               /********************************************************************
436:               Function:
437:                   void USBRestoreUSBInterrupts(void)
438:               
439:               Summary:
440:                   This function restores the previous USB interrupt setting that was
441:                   in effect prior to calling the corresponding USBMaskAllUSBInterrupts().
442:               
443:               PreCondition:
444:                   None
445:               
446:               Parameters:
447:                   None
448:               
449:               Return Values:
450:                   None
451:               
452:               Remarks:
453:                This function should only be called in an exact 1:1 ratio with the
454:                USBMaskAllUSBInterrupts() function.  This function should never be
455:                called without first being preceded by a call to USBMaskAllUSBInterrupts().
456:                 *******************************************************************/
457:               void USBRestoreUSBInterrupts(void)
458:               {
0015E0  FA0000     LNK #0x0
459:                   //Restore the previous USBIE setting, that was saved when USBMaskAllUSBInterrupts() was called.
460:                   if(USBIESave)
0015E2  BFC82E     MOV.B USBIESave, WREG
0015E4  E00400     CP0.B W0
0015E6  320001     BRA Z, .L26
461:                   {
462:                       _USB1IE = 1;
0015E8  A8C09E     BSET IEC5, #6
463:                   }
464:               }
0015EA  FA8000     ULNK
0015EC  060000     RETURN
465:               
466:               
467:               
468:               
469:               
470:               /********************************************************************
471:               Function:
472:                   static void USBSaveAndPrepareInterruptsForSleep(void)
473:               
474:               Summary:
475:                   This is a private function that should never be called directly by
476:                   user application code.  This function saves the state of all IECx interupt
477:                   enable register bits, and then clears/disables all interrupts.  It then
478:                   re-enables only the very specific ones needed for wakeup from sleep due
479:                   to USB activity.
480:               
481:               PreCondition:
482:                   Must only be called by USB stack code in the context of a USB suspend or
483:                   USB detach event handler.
484:               
485:               Parameters:
486:                   None
487:               
488:               Return Values:
489:                   None
490:               
491:               Remarks:
492:                   Application code should not call or modify this function.  If in the
493:                   application it is desired to wake up from sleep by additional sources,
494:                   such as for remote wakeup purposes, only these additional interrupt sources
495:                   must be enabled after returning from this function, and prior to executing
496:                   the sleep instruction.  When called, this function must always be called in
497:                   an exact 1:1 ratio with the USBRestorePreviousInterruptSettings() function, in
498:                   order to restore the application interrupt settings to their previous values.
499:                   Calling this function more than one (without calling USBRestorePreviousInterruptSettings()
500:                   will result in a loss of state information.
501:                 *******************************************************************/
502:               static void USBSaveAndPrepareInterruptsForSleep(void)
503:               {
0015EE  FA0004     LNK #0x4
504:                   unsigned int i;
505:                   volatile unsigned int* pRegister;
506:               
507:                   //Disable all (maskable) interrupts by setting the CPU "interrupt" priority level to maximum
508:                   __builtin_disi(30); //Disable interrupts long enough to reliably save the current SR<IPL> bit values, and then disable interrupts.
0015F0  FC001E     DISI #0x1E
509:                   CPUIPLSave = SR & 0x00E0;   //Save IPL bits only
0015F2  800211     MOV SR, W1
0015F4  200E00     MOV #0xE0, W0
0015F6  608000     AND W1, W0, W0
0015F8  884130     MOV W0, CPUIPLSave
510:                   SRbits.IPL = 7;             //Set CPU to maximum, so as to disable lower priority interrupt vectoring.
0015FA  800211     MOV SR, W1
0015FC  200E00     MOV #0xE0, W0
0015FE  700001     IOR W0, W1, W0
001600  880210     MOV W0, SR
511:               
512:                   //Now save and disable all other interrupt enable bits settings.  Note: This code
513:                   //assumes all IECx registers are packed together little endian with no other registers intermingled
514:                   //(make sure this is true if using a hypothetical device where this might not be the case).
515:                   pRegister = &IEC0;
001602  200940     MOV #0x94, W0
001604  980710     MOV W0, [W14+2]
516:                   for(i = 0; i < DEVICE_SPECIFIC_IEC_REGISTER_COUNT; i++)
001606  EB0000     CLR W0
001608  780F00     MOV W0, [W14]
00160A  37000E     BRA .L29
001626  E80F1E     INC [W14], [W14]
001628  78001E     MOV [W14], W0
00162A  500FE7     SUB W0, #0x7, [W15]
00162C  36FFEF     BRA LEU, .L30
517:                   {
518:                       IECRegSaves[i] = *pRegister;    //Save the current IECx register contents
00160C  90001E     MOV [W14+2], W0
00160E  780090     MOV [W0], W1
001610  78001E     MOV [W14], W0
001612  400100     ADD W0, W0, W2
001614  208780     MOV #0x878, W0
001616  410000     ADD W2, W0, W0
001618  780801     MOV W1, [W0]
519:                       *pRegister++ = 0;               //Clear out the current IECx register
00161A  90001E     MOV [W14+2], W0
00161C  EB0080     CLR W1
00161E  780801     MOV W1, [W0]
001620  90001E     MOV [W14+2], W0
001622  E88000     INC2 W0, W0
001624  980710     MOV W0, [W14+2]
520:                   }
521:                   U1IE_save = U1IE;    //Also save and clear USB module sub-interrupts
00162E  802060     MOV U1IE, W0
001630  884140     MOV W0, U1IE_save
522:                   U1IE = 0;
001632  EF240C     CLR U1IE
523:                   U1OTGIE_save = U1OTGIE;
001634  802010     MOV U1OTGIE, W0
001636  884150     MOV W0, U1OTGIE_save
524:                   U1OTGIE = 0;
001638  EF2402     CLR U1OTGIE
525:                   USBIPLSave = _USB1IP;
00163A  800670     MOV IPC21, W0
00163C  DE0048     LSR W0, #8, W0
00163E  604067     AND.B W0, #0x7, W0
001640  FB8000     ZE W0, W0
001642  884160     MOV W0, USBIPLSave
526:               
527:                   //Now enable only the USBIE + ACVIE + SOFIE + URSTIE interrupt sources, plus possible remote
528:                   //wakeup stimulus interrupt source(s) (but only when legal to perform remote wakeup),
529:                   //so that they make wake the microcontroller from sleep mode (but not to vector, due to CPU IPL = 7)
530:                   USBClearInterruptFlag(USBActivityIFReg, USBActivityIFBitNum);
001644  200100     MOV #0x10, W0
001646  882000     MOV W0, U1OTGIR
531:                   USBClearInterruptFlag(USBRESUMEIFReg, USBRESUMEIFBitNum);
001648  200200     MOV #0x20, W0
00164A  882050     MOV W0, U1IR
532:               
533:                   _USB1IF = 0;
00164C  A9C08E     BCLR IFS5, #6
534:                   _ACTVIE = 1;
00164E  A88402     BSET U1OTGIE, #4
535:                   _USB1IP = 4;    //Make sure USB module IPL is > 0, so it can at least wake the device from sleep
001650  800671     MOV IPC21, W1
001652  2F8FF0     MOV #0xF8FF, W0
001654  608000     AND W1, W0, W0
001656  A0A000     BSET W0, #10
001658  880670     MOV W0, IPC21
536:                   _USB1IE = 1;    //Enable the top level USB module IE bit now, to enable wake from sleep.
00165A  A8C09E     BSET IEC5, #6
537:               }
00165C  FA8000     ULNK
00165E  060000     RETURN
538:               
539:               
540:               
541:               /********************************************************************
542:               Function:
543:                   static void USBRestorePreviousInterruptSettings(void)
544:               
545:               Summary:
546:                   This is a private function that should never be called directly by
547:                   user application code.  This function restores the state of all IECx interrupt
548:                   enable register bits that were previously modified by the
549:                   USBSaveAndPrepareInterruptsForSleep() function.
550:               
551:               PreCondition:
552:                   Must only be called by USB stack code in the context of a USB suspend or
553:                   USB detach event handler, after the event has ended and it is time to
554:                   restore the previous operating status.
555:               
556:               Parameters:
557:                   None
558:               
559:               Return Values:
560:                   None
561:               
562:               Remarks:
563:                   Application code should not call or modify this function.  This function
564:                   must always be called in an exact 1:1 ratio with the
565:                   USBSaveAndPrepareInterruptsForSleep() function.
566:                 *******************************************************************/
567:               static void USBRestorePreviousInterruptSettings(void)
568:               {
001660  FA0004     LNK #0x4
569:                   unsigned int i;
570:                   volatile unsigned int* pRegister;
571:               
572:                   //Restore the previously saved interrupt settings.
573:               
574:                   //Restore all the previous application interrupt settings that we modified
575:                   //previously by the USBSaveAndPrepareInterruptsForSleep() function.
576:                   pRegister = &IEC0;
001662  200940     MOV #0x94, W0
001664  980710     MOV W0, [W14+2]
577:                   for(i = 0; i < DEVICE_SPECIFIC_IEC_REGISTER_COUNT; i++)
001666  EB0000     CLR W0
001668  780F00     MOV W0, [W14]
00166A  37000B     BRA .L32
001680  E80F1E     INC [W14], [W14]
001682  78001E     MOV [W14], W0
001684  500FE7     SUB W0, #0x7, [W15]
001686  36FFF2     BRA LEU, .L33
578:                   {
579:                       *pRegister++ = IECRegSaves[i];
00166C  78001E     MOV [W14], W0
00166E  400080     ADD W0, W0, W1
001670  208780     MOV #0x878, W0
001672  408000     ADD W1, W0, W0
001674  780090     MOV [W0], W1
001676  90001E     MOV [W14+2], W0
001678  780801     MOV W1, [W0]
00167A  90001E     MOV [W14+2], W0
00167C  E88000     INC2 W0, W0
00167E  980710     MOV W0, [W14+2]
580:                   }
581:                   U1IE = U1IE_save;
001688  804140     MOV U1IE_save, W0
00168A  882060     MOV W0, U1IE
582:                   U1OTGIE = U1OTGIE_save;
00168C  804150     MOV U1OTGIE_save, W0
00168E  882010     MOV W0, U1OTGIE
583:                   _USB1IP = USBIPLSave;
001690  804160     MOV USBIPLSave, W0
001692  784000     MOV.B W0, W0
001694  604067     AND.B W0, #0x7, W0
001696  FB8000     ZE W0, W0
001698  600067     AND W0, #0x7, W0
00169A  DD0048     SL W0, #8, W0
00169C  800672     MOV IPC21, W2
00169E  2F8FF1     MOV #0xF8FF, W1
0016A0  610081     AND W2, W1, W1
0016A2  700001     IOR W0, W1, W0
0016A4  880670     MOV W0, IPC21
584:               
585:               
586:                   //Restore CPU interrupt priority level to allow normal vectoring again.
587:                   CPUIPLSave = (SR & 0xFF1F) | CPUIPLSave;
0016A6  800211     MOV SR, W1
0016A8  2FF1F0     MOV #0xFF1F, W0
0016AA  608080     AND W1, W0, W1
0016AC  804130     MOV CPUIPLSave, W0
0016AE  700001     IOR W0, W1, W0
0016B0  884130     MOV W0, CPUIPLSave
588:                   SR = CPUIPLSave;
0016B2  804130     MOV CPUIPLSave, W0
0016B4  880210     MOV W0, SR
589:               }
0016B6  FA8000     ULNK
0016B8  060000     RETURN
590:               
591:               
592:               
593:               
594:               //-------------------------------------------------------------------------------------------
595:               #endif //#if defined(__XC16__) || defined(__C30__)
596:               #endif //__USB_HAL_16BIT_C
---  C:/Users/imada/OneDrive/Documents/MPLAB X/IR_Splitted_KB/IR_Splitted_Master.X/usb_events.c  --------
1:                 /*******************************************************************************
2:                 Copyright 2016 Microchip Technology Inc. (www.microchip.com)
3:                 
4:                 Licensed under the Apache License, Version 2.0 (the "License");
5:                 you may not use this file except in compliance with the License.
6:                 You may obtain a copy of the License at
7:                 
8:                     http://www.apache.org/licenses/LICENSE-2.0
9:                 
10:                Unless required by applicable law or agreed to in writing, software
11:                distributed under the License is distributed on an "AS IS" BASIS,
12:                WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
13:                See the License for the specific language governing permissions and
14:                limitations under the License.
15:                
16:                To request to license the code under the MLA license (www.microchip.com/mla_license), 
17:                please contact mla_licensing@microchip.com
18:                *******************************************************************************/
19:                
20:                // *****************************************************************************
21:                // *****************************************************************************
22:                // Section: Included Files
23:                // *****************************************************************************
24:                // *****************************************************************************
25:                /* Standard C includes */
26:                #include <stdint.h>
27:                
28:                /* Microchip library includes */
29:                #include "system.h"
30:                
31:                #include "usb.h"
32:                #include "usb_device_hid.h"
33:                
34:                /* Demo project includes */
35:                #include "app_led_usb_status.h"
36:                #include "app_device_keyboard.h"
37:                
38:                
39:                // *****************************************************************************
40:                // *****************************************************************************
41:                // Section: File Scope or Global Constants
42:                // *****************************************************************************
43:                // *****************************************************************************
44:                volatile signed int SOFCounter = 0;
45:                
46:                /*******************************************************************
47:                 * Function:        bool USER_USB_CALLBACK_EVENT_HANDLER(
48:                 *                        USB_EVENT event, void *pdata, uint16_t size)
49:                 *
50:                 * PreCondition:    None
51:                 *
52:                 * Input:           USB_EVENT event - the type of event
53:                 *                  void *pdata - pointer to the event data
54:                 *                  uint16_t size - size of the event data
55:                 *
56:                 * Output:          None
57:                 *
58:                 * Side Effects:    None
59:                 *
60:                 * Overview:        This function is called from the USB stack to
61:                 *                  notify a user application that a USB event
62:                 *                  occured.  This callback is in interrupt context
63:                 *                  when the USB_INTERRUPT option is selected.
64:                 *
65:                 * Note:            None
66:                 *******************************************************************/
67:                bool USER_USB_CALLBACK_EVENT_HANDLER(USB_EVENT event, void *pdata, uint16_t size)
68:                {
001B1E  FA0006     LNK #0x6
001B20  780F00     MOV W0, [W14]
001B22  980711     MOV W1, [W14+2]
001B24  980722     MOV W2, [W14+4]
69:                    switch((int)event)
001B26  78001E     MOV [W14], W0
001B28  200721     MOV #0x72, W1
001B2A  500F81     SUB W0, W1, [W15]
001B2C  32002E     BRA Z, .L17
001B2E  200721     MOV #0x72, W1
001B30  500F81     SUB W0, W1, [W15]
001B32  3C000A     BRA GT, .L12
001B34  500FE2     SUB W0, #0x2, [W15]
001B36  32002B     BRA Z, .L18
001B38  500FE2     SUB W0, #0x2, [W15]
001B3A  3C0003     BRA GT, .L13
001B3C  500FE1     SUB W0, #0x1, [W15]
001B3E  320021     BRA Z, .L3
001B42  500FE3     SUB W0, #0x3, [W15]
001B44  320020     BRA Z, .L5
001B48  200741     MOV #0x74, W1
001B4A  500F81     SUB W0, W1, [W15]
001B4C  320016     BRA Z, .L9
001B4E  200741     MOV #0x74, W1
001B50  500F81     SUB W0, W1, [W15]
001B52  350004     BRA LT, .L8
001B54  200751     MOV #0x75, W1
001B56  500F81     SUB W0, W1, [W15]
001B58  32000C     BRA Z, .L10
70:                    {
71:                        case EVENT_TRANSFER:
72:                            break;
001B8A  000000     NOP
001B8C  370001     BRA .L14
73:                
74:                        case EVENT_SOF:
75:                            /* We are using the SOF as a timer to time the LED indicator.  Call
76:                             * the LED update function here. */
77:                            APP_LEDUpdateUSBStatus();
001B5C  07001C     RCALL APP_LEDUpdateUSBStatus
78:                            if(SOFCounter < 32767)
001B5E  8041C1     MOV SOFCounter, W1
001B60  27FFF0     MOV #0x7FFF, W0
001B62  508F80     SUB W1, W0, [W15]
001B64  320004     BRA Z, .L15
79:                            {
80:                                SOFCounter++;
001B66  8041C0     MOV SOFCounter, W0
001B68  E80000     INC W0, W0
001B6A  8841C0     MOV W0, SOFCounter
81:                            }
82:                            else
83:                            {
84:                                SOFCounter = 0;
001B6E  EF2838     CLR SOFCounter
85:                            }
86:                            break;
001B6C  370011     BRA .L14
001B70  37000F     BRA .L14
87:                
88:                        case EVENT_SUSPEND:
89:                            /* Update the LED status for the suspend event. */
90:                            APP_LEDUpdateUSBStatus();
001B72  070011     RCALL APP_LEDUpdateUSBStatus
91:                
92:                            //Call the hardware platform specific handler for suspend events for
93:                            //possible further action (like optionally going reconfiguring the application
94:                            //for lower power states and going to sleep during the suspend event).  This
95:                            //would normally be done in USB compliant bus powered applications, although
96:                            //no further processing is needed for purely self powered applications that
97:                            //don't consume power from the host.
98:                            SYSTEM_Initialize(SYSTEM_STATE_USB_SUSPEND);
001B74  200010     MOV #0x1, W0
001B76  0700C8     RCALL SYSTEM_Initialize
99:                            break;
001B78  37000B     BRA .L14
100:               
101:                       case EVENT_RESUME:
102:                           /* Update the LED status for the resume event. */
103:                           APP_LEDUpdateUSBStatus();
001B7A  07000D     RCALL APP_LEDUpdateUSBStatus
104:               
105:                           //Call the hardware platform specific resume from suspend handler (ex: to
106:                           //restore I/O pins to higher power states if they were changed during the 
107:                           //preceding SYSTEM_Initialize(SYSTEM_STATE_USB_SUSPEND) call at the start
108:                           //of the suspend condition.
109:                           SYSTEM_Initialize(SYSTEM_STATE_USB_RESUME);
001B7C  200020     MOV #0x2, W0
001B7E  0700C4     RCALL SYSTEM_Initialize
110:                           break;
001B80  370007     BRA .L14
111:               
112:                       case EVENT_CONFIGURED:
113:                           /* When the device is configured, we can (re)initialize the keyboard
114:                            * demo code. */
115:                           APP_KeyboardInit();
001B82  07FD9B     RCALL APP_KeyboardInit
116:                           break;
001B84  370005     BRA .L14
117:               
118:                       case EVENT_SET_DESCRIPTOR:
119:                           break;
001B8E  000000     NOP
120:               
121:                       case EVENT_EP0_REQUEST:
122:                           /* We have received a non-standard USB request.  The HID driver
123:                            * needs to check to see if the request was for it. */
124:                           USBCheckHIDRequest();
001B86  07FF53     RCALL USBCheckHIDRequest
125:                           break;
001B88  370003     BRA .L14
126:               
127:                       case EVENT_BUS_ERROR:
128:                           break;
001B5A  37001A     BRA .L14
129:               
130:                       case EVENT_TRANSFER_TERMINATED:
131:                           break;
001B46  370024     BRA .L14
132:               
133:                       default:
134:                           break;
001B40  370027     BRA .L14
135:                   }
136:                   return true;
001B90  B3C010     MOV.B #0x1, W0
137:               }
001B92  FA8000     ULNK
001B94  060000     RETURN
138:               
139:               /*******************************************************************************
140:                End of File
141:               */
---  C:/Users/imada/OneDrive/Documents/MPLAB X/IR_Splitted_KB/IR_Splitted_Master.X/usb_device_hid.c  ----
1:                 // DOM-IGNORE-BEGIN
2:                 /*******************************************************************************
3:                 Copyright 2015 Microchip Technology Inc. (www.microchip.com)
4:                 
5:                 Licensed under the Apache License, Version 2.0 (the "License");
6:                 you may not use this file except in compliance with the License.
7:                 You may obtain a copy of the License at
8:                 
9:                     http://www.apache.org/licenses/LICENSE-2.0
10:                
11:                Unless required by applicable law or agreed to in writing, software
12:                distributed under the License is distributed on an "AS IS" BASIS,
13:                WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
14:                See the License for the specific language governing permissions and
15:                limitations under the License.
16:                
17:                To request to license the code under the MLA license (www.microchip.com/mla_license), 
18:                please contact mla_licensing@microchip.com
19:                *******************************************************************************/
20:                //DOM-IGNORE-END
21:                
22:                /*******************************************************************************
23:                  USB Device Human Interface Device (HID) Layer
24:                
25:                  Company:
26:                    Microchip Technology Inc.
27:                
28:                  File Name:
29:                    usb_device_hid.c
30:                
31:                  Summary:
32:                    USB Device Human Interface Device (HID) Layer interface API.
33:                
34:                  Description:
35:                    USB Device Human Interface Device (HID) Layer interface API.
36:                *******************************************************************************/
37:                
38:                
39:                // *****************************************************************************
40:                // *****************************************************************************
41:                // Section: Included Files
42:                // *****************************************************************************
43:                // *****************************************************************************
44:                #include "usb_config.h"
45:                #include "usb.h"
46:                #include "usb_device_hid.h"
47:                
48:                // *****************************************************************************
49:                // *****************************************************************************
50:                // Section: File Scope or Global Constants
51:                // *****************************************************************************
52:                // *****************************************************************************
53:                
54:                // *****************************************************************************
55:                // *****************************************************************************
56:                // Section: File Scope Data Types
57:                // *****************************************************************************
58:                // *****************************************************************************
59:                typedef struct __attribute__((packed))
60:                {
61:                    unsigned :8;
62:                    unsigned :8;
63:                    uint8_t reportId;
64:                    uint8_t duration;
65:                } USB_SETUP_SET_IDLE_RATE;
66:                
67:                typedef struct __attribute__((packed))
68:                {
69:                    unsigned :8;
70:                    unsigned :8;
71:                    uint8_t protocol;
72:                } USB_SETUP_SET_PROTOCOL;
73:                
74:                // *****************************************************************************
75:                // *****************************************************************************
76:                // Section: Variables
77:                // *****************************************************************************
78:                // *****************************************************************************
79:                static uint8_t idle_rate;
80:                static uint8_t active_protocol;   // [0] Boot Protocol [1] Report Protocol
81:                
82:                extern const struct{uint8_t report[HID_RPT01_SIZE];}hid_rpt01;
83:                
84:                // *****************************************************************************
85:                // *****************************************************************************
86:                // Section: Prototypes
87:                // *****************************************************************************
88:                // *****************************************************************************
89:                #if defined USER_GET_REPORT_HANDLER
90:                    void USER_GET_REPORT_HANDLER(void);
91:                #endif
92:                
93:                #if defined USER_SET_REPORT_HANDLER
94:                    extern void USER_SET_REPORT_HANDLER(void);
95:                #endif     
96:                
97:                // *****************************************************************************
98:                // *****************************************************************************
99:                // Section: Macros or Functions
100:               // *****************************************************************************
101:               // *****************************************************************************
102:               
103:               //To implement a set idle rate callback function in the application,
104:               //Make sure "#define USB_DEVICE_HID_IDLE_RATE_CALLBACK(reportID, newIdleRate)    USBHIDCBSetIdleRateHandler(reportID, newIdleRate)"
105:               //is placed in your usb_config.h file, and then in your application .c file,
106:               //add the void USBHIDCBSetIdleRateHandler(reportID, newIdleRate) function
107:               //implementation that saves the new idle rate and report ID info, so that it
108:               //gets used later when sending subsequent HID input report packets to the host.
109:               #ifndef USB_DEVICE_HID_IDLE_RATE_CALLBACK
110:                   #define USB_DEVICE_HID_IDLE_RATE_CALLBACK(reportId, idleRate)
111:               #else
112:                   extern void USB_DEVICE_HID_IDLE_RATE_CALLBACK(uint8_t reportId, uint8_t idleRate);
113:               #endif
114:               
115:               /********************************************************************
116:               	Function:
117:               		void USBCheckHIDRequest(void)
118:               
119:                	Summary:
120:                		This routine handles HID specific request that happen on EP0.
121:                       This function should be called from the USBCBCheckOtherReq() call back
122:                       function whenever implementing a HID device.
123:               
124:                	Description:
125:                		This routine handles HID specific request that happen on EP0.  These
126:                       include, but are not limited to, requests for the HID report
127:                       descriptors.  This function should be called from the
128:                       USBCBCheckOtherReq() call back function whenever using an HID device.
129:               
130:                       Typical Usage:
131:                       <code>
132:                       void USBCBCheckOtherReq(void)
133:                       {
134:                           //Since the stack didn't handle the request I need to check
135:                           //  my class drivers to see if it is for them
136:                           USBCheckHIDRequest();
137:                       }
138:                       </code>
139:               
140:               	PreCondition:
141:               		None
142:               
143:               	Parameters:
144:               		None
145:               
146:               	Return Values:
147:               		None
148:               
149:               	Remarks:
150:               		None
151:                
152:                *******************************************************************/
153:               void USBCheckHIDRequest(void)
154:               {
001A2E  FA0000     LNK #0x0
155:                   if(SetupPkt.Recipient != USB_SETUP_RECIPIENT_INTERFACE_BITFIELD) return;
001A30  208500     MOV #0x850, W0
001A32  784010     MOV.B [W0], W0
001A34  60407F     AND.B W0, #0x1F, W0
001A36  504FE1     SUB.B W0, #0x1, [W15]
001A38  3A0069     BRA NZ, .L18
001B0C  000000     NOP
001B0E  370005     BRA .L1
156:                   if(SetupPkt.bIntfID != HID_INTF_ID) return;
001A3A  208540     MOV #0x854, W0
001A3C  784010     MOV.B [W0], W0
001A3E  E00400     CP0.B W0
001A40  3A0067     BRA NZ, .L19
001B10  000000     NOP
001B12  370003     BRA .L1
157:                   
158:                   /*
159:                    * There are two standard requests that hid.c may support.
160:                    * 1. GET_DSC(DSC_HID,DSC_RPT,DSC_PHY);
161:                    * 2. SET_DSC(DSC_HID,DSC_RPT,DSC_PHY);
162:                    */
163:                   if(SetupPkt.bRequest == USB_REQUEST_GET_DESCRIPTOR)
001A42  208510     MOV #0x851, W0
001A44  784010     MOV.B [W0], W0
001A46  504FE6     SUB.B W0, #0x6, [W15]
001A48  3A0022     BRA NZ, .L5
164:                   {
165:                       switch(SetupPkt.bDescriptorType)
001A4A  208530     MOV #0x853, W0
001A4C  784010     MOV.B [W0], W0
001A4E  FB8000     ZE W0, W0
001A50  200221     MOV #0x22, W1
001A52  500F81     SUB W0, W1, [W15]
001A54  320011     BRA Z, .L7
001A56  200231     MOV #0x23, W1
001A58  500F81     SUB W0, W1, [W15]
001A5A  320016     BRA Z, .L20
001A5C  200211     MOV #0x21, W1
001A5E  500F81     SUB W0, W1, [W15]
001A60  3A0016     BRA NZ, .L5
166:                       {
167:                           case DSC_HID: //HID Descriptor          
168:                               if(USBActiveConfiguration == 1)
001A62  BFC802     MOV.B USBActiveConfiguration, WREG
001A64  504FE1     SUB.B W0, #0x1, [W15]
001A66  3A0012     BRA NZ, .L21
169:                               {
170:                                   USBEP0SendROMPtr(
001A68  284840     MOV #0x8484, W0
001A6A  8841F0     MOV W0, inPipes
001A6C  200090     MOV #0x9, W0
001A6E  884210     MOV W0, 0x842
001A70  208400     MOV #0x840, W0
001A72  B3CC01     MOV.B #0xC0, W1
001A74  784801     MOV.B W1, [W0]
171:                                       (const uint8_t*)&configDescriptor1 + 18,		//18 is a magic number.  It is the offset from start of the configuration descriptor to the start of the HID descriptor.
172:                                       sizeof(USB_HID_DSC)+3,
173:                                       USB_EP0_INCLUDE_ZERO);
174:                               }
175:                               break;
001A76  37000B     BRA .L5
001A8C  000000     NOP
176:                           case DSC_RPT:  //Report Descriptor           
177:                               //if(USBActiveConfiguration == 1)
178:                               {
179:                                   USBEP0SendROMPtr(
001A78  283C00     MOV #0x83C0, W0
001A7A  8841F0     MOV W0, inPipes
001A7C  2003F0     MOV #0x3F, W0
001A7E  884210     MOV W0, 0x842
001A80  208400     MOV #0x840, W0
001A82  B3CC01     MOV.B #0xC0, W1
001A84  784801     MOV.B W1, [W0]
180:                                       (const uint8_t*)&hid_rpt01,
181:                                       HID_RPT01_SIZE,     //See usbcfg.h
182:                                       USB_EP0_INCLUDE_ZERO);
183:                               }
184:                               break;
001A86  370003     BRA .L5
185:                           case DSC_PHY:  //Physical Descriptor
186:               				//Note: The below placeholder code is commented out.  HID Physical Descriptors are optional and are not used
187:               				//in many types of HID applications.  If an application does not have a physical descriptor,
188:               				//then the device should return STALL in response to this request (stack will do this automatically
189:               				//if no-one claims ownership of the control transfer).
190:               				//If an application does implement a physical descriptor, then make sure to declare
191:               				//hid_phy01 (rom structure containing the descriptor data), and hid_phy01 (the size of the descriptors in uint8_ts),
192:               				//and then uncomment the below code.
193:                               //if(USBActiveConfiguration == 1)
194:                               //{
195:                               //    USBEP0SendROMPtr((const uint8_t*)&hid_phy01, sizeof(hid_phy01), USB_EP0_INCLUDE_ZERO);
196:                               //}
197:                               break;
001A88  000000     NOP
001A8A  370001     BRA .L5
198:                       }//end switch(SetupPkt.bDescriptorType)
199:                   }//end if(SetupPkt.bRequest == GET_DSC)
200:                   
201:                   if(SetupPkt.RequestType != USB_SETUP_TYPE_CLASS_BITFIELD)
001A8E  208500     MOV #0x850, W0
001A90  784010     MOV.B [W0], W0
001A92  B3C602     MOV.B #0x60, W2
001A94  604082     AND.B W0, W2, W1
001A96  B3C200     MOV.B #0x20, W0
001A98  50CF80     SUB.B W1, W0, [W15]
001A9A  3A003C     BRA NZ, .L22
202:                   {
203:                       return;
001B14  000000     NOP
001B16  370001     BRA .L1
204:                   }
205:               
206:                   switch(SetupPkt.bRequest)
001A9C  208510     MOV #0x851, W0
001A9E  784010     MOV.B [W0], W0
001AA0  FB8000     ZE W0, W0
001AA2  500FE3     SUB W0, #0x3, [W15]
001AA4  320023     BRA Z, .L13
001AA6  500FE3     SUB W0, #0x3, [W15]
001AA8  3C0005     BRA GT, .L17
001AAA  500FE1     SUB W0, #0x1, [W15]
001AAC  320035     BRA Z, .L23
001AAE  500FE2     SUB W0, #0x2, [W15]
001AB0  320009     BRA Z, .L12
001AB2  370033     BRA .L1
001AB4  500FEA     SUB W0, #0xA, [W15]
001AB6  32000E     BRA Z, .L15
001AB8  500FEB     SUB W0, #0xB, [W15]
001ABA  320020     BRA Z, .L16
001ABC  500FE9     SUB W0, #0x9, [W15]
001ABE  3A002D     BRA NZ, .L1
207:                   {
208:                       case GET_REPORT:
209:                           #if defined USER_GET_REPORT_HANDLER
210:                               USER_GET_REPORT_HANDLER();
211:                           #endif
212:                           break;
001B18  000000     NOP
213:                       case SET_REPORT:
214:                           #if defined USER_SET_REPORT_HANDLER
215:                               USER_SET_REPORT_HANDLER();
001AC0  07FEB7     RCALL USBHIDCBSetReportHandler
216:                           #endif       
217:                           break;
001AC2  37002B     BRA .L1
218:                       case GET_IDLE:
219:                           USBEP0SendRAMPtr(
001AC4  208360     MOV #0x836, W0
001AC6  8841F0     MOV W0, inPipes
001AC8  200010     MOV #0x1, W0
001ACA  884210     MOV W0, 0x842
001ACC  208400     MOV #0x840, W0
001ACE  B3CC11     MOV.B #0xC1, W1
001AD0  784801     MOV.B W1, [W0]
220:                               (uint8_t*)&idle_rate,
221:                               1,
222:                               USB_EP0_INCLUDE_ZERO);
223:                           break;
001AD2  370023     BRA .L1
224:                       case SET_IDLE:
225:                           USBEP0Transmit(USB_EP0_NO_DATA);
001AD4  208400     MOV #0x840, W0
001AD6  B3C801     MOV.B #0x80, W1
001AD8  784801     MOV.B W1, [W0]
226:                           idle_rate = SetupPkt.W_Value.byte.HB;
001ADA  208530     MOV #0x853, W0
001ADC  784010     MOV.B [W0], W0
001ADE  B7E836     MOV.B WREG, idle_rate
227:                           USB_DEVICE_HID_IDLE_RATE_CALLBACK(SetupPkt.W_Value.byte.LB, idle_rate);
001AE0  208361     MOV #0x836, W1
001AE2  784091     MOV.B [W1], W1
001AE4  208520     MOV #0x852, W0
001AE6  784010     MOV.B [W0], W0
001AE8  07FECF     RCALL USBHIDCBSetIdleRateHandler
228:                           break;
001AEA  370017     BRA .L1
229:                       case GET_PROTOCOL:
230:                           USBEP0SendRAMPtr(
001AEC  208370     MOV #0x837, W0
001AEE  8841F0     MOV W0, inPipes
001AF0  200010     MOV #0x1, W0
001AF2  884210     MOV W0, 0x842
001AF4  208400     MOV #0x840, W0
001AF6  B3C811     MOV.B #0x81, W1
001AF8  784801     MOV.B W1, [W0]
231:                               (uint8_t*)&active_protocol,
232:                               1,
233:                               USB_EP0_NO_OPTIONS);
234:                           break;
001AFA  37000F     BRA .L1
235:                       case SET_PROTOCOL:
236:                           USBEP0Transmit(USB_EP0_NO_DATA);
001AFC  208400     MOV #0x840, W0
001AFE  B3C801     MOV.B #0x80, W1
001B00  784801     MOV.B W1, [W0]
237:                           active_protocol = SetupPkt.W_Value.byte.LB;
001B02  208520     MOV #0x852, W0
001B04  784010     MOV.B [W0], W0
001B06  B7E837     MOV.B WREG, active_protocol
238:                           break;
001B08  000000     NOP
001B0A  370007     BRA .L1
239:                   }//end switch(SetupPkt.bRequest)
240:               
241:               }//end USBCheckHIDRequest
001B1A  FA8000     ULNK
001B1C  060000     RETURN
242:               
243:               /********************************************************************
244:                   Function:
245:                       USB_HANDLE HIDTxPacket(uint8_t ep, uint8_t* data, uint16_t len)
246:                       
247:                   Summary:
248:                       Sends the specified data out the specified endpoint
249:               
250:                   Description:
251:                       This function sends the specified data out the specified 
252:                       endpoint and returns a handle to the transfer information.
253:               
254:                       Typical Usage:
255:                       <code>
256:                       //make sure that the last transfer isn't busy by checking the handle
257:                       if(!HIDTxHandleBusy(USBInHandle))
258:                       {
259:                           //Send the data contained in the ToSendDataBuffer[] array out on
260:                           //  endpoint HID_EP
261:                           USBInHandle = HIDTxPacket(HID_EP,(uint8_t*)&ToSendDataBuffer[0],sizeof(ToSendDataBuffer));
262:                       }
263:                       </code>
264:                       
265:                   PreCondition:
266:                       None
267:                       
268:                   Parameters:
269:                       uint8_t ep    - the endpoint you want to send the data out of
270:                       uint8_t* data - pointer to the data that you wish to send
271:                       uint16_t len   - the length of the data that you wish to send
272:                       
273:                   Return Values:
274:                       USB_HANDLE - a handle for the transfer.  This information
275:                       should be kept to track the status of the transfer
276:                       
277:                   Remarks:
278:                       None
279:                 
280:                *******************************************************************/
281:                // Implemented as a macro. See usb_function_hid.h
282:               
283:               /********************************************************************
284:                   Function:
285:                       USB_HANDLE HIDRxPacket(uint8_t ep, uint8_t* data, uint16_t len)
286:                       
287:                   Summary:
288:                       Receives the specified data out the specified endpoint
289:                       
290:                   Description:
291:                       Receives the specified data out the specified endpoint.
292:               
293:                       Typical Usage:
294:                       <code>
295:                       //Read 64-uint8_ts from endpoint HID_EP, into the ReceivedDataBuffer array.
296:                       //  Make sure to save the return handle so that we can check it later
297:                       //  to determine when the transfer is complete.
298:                       USBOutHandle = HIDRxPacket(HID_EP,(uint8_t*)&ReceivedDataBuffer,64);
299:                       </code>
300:               
301:                   PreCondition:
302:                       None
303:                       
304:                   Parameters:
305:                       uint8_t ep    - the endpoint you want to receive the data into
306:                       uint8_t* data - pointer to where the data will go when it arrives
307:                       uint16_t len   - the length of the data that you wish to receive
308:                       
309:                   Return Values:
310:                       USB_HANDLE - a handle for the transfer.  This information
311:                       should be kept to track the status of the transfer
312:                       
313:                   Remarks:
314:                       None
315:                 
316:                *******************************************************************/
317:                 // Implemented as a macro. See usb_function_hid.h
318:                 
319:               /*******************************************************************************
320:                End of File
321:               */
---  C:/Users/imada/OneDrive/Documents/MPLAB X/IR_Splitted_KB/IR_Splitted_Master.X/usb_device.c  --------
1:                 // DOM-IGNORE-BEGIN
2:                 /*******************************************************************************
3:                 Copyright 2015 Microchip Technology Inc. (www.microchip.com)
4:                 
5:                 Licensed under the Apache License, Version 2.0 (the "License");
6:                 you may not use this file except in compliance with the License.
7:                 You may obtain a copy of the License at
8:                 
9:                     http://www.apache.org/licenses/LICENSE-2.0
10:                
11:                Unless required by applicable law or agreed to in writing, software
12:                distributed under the License is distributed on an "AS IS" BASIS,
13:                WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
14:                See the License for the specific language governing permissions and
15:                limitations under the License.
16:                
17:                To request to license the code under the MLA license (www.microchip.com/mla_license), 
18:                please contact mla_licensing@microchip.com
19:                *******************************************************************************/
20:                //DOM-IGNORE-END
21:                
22:                /*******************************************************************************
23:                  USB Device Layer
24:                
25:                  Company:
26:                    Microchip Technology Inc.
27:                
28:                  File Name:
29:                    usb_device.c
30:                
31:                  Summary:
32:                   Provides basic USB device functionality, including enumeration and USB
33:                   chapter 9 required behavior.
34:                
35:                  Description:
36:                   Provides basic USB device functionality, including enumeration and USB
37:                   chapter 9 required behavior.
38:                *******************************************************************************/
39:                
40:                // *****************************************************************************
41:                // *****************************************************************************
42:                // Section: Included Files
43:                // *****************************************************************************
44:                // *****************************************************************************
45:                #include <xc.h>
46:                
47:                #include <stdint.h>
48:                #include <stddef.h>
49:                #include <string.h>
50:                
51:                #include "usb_config.h"
52:                
53:                #include "usb.h"
54:                #include "usb_ch9.h"
55:                #include "usb_device.h"
56:                #include "usb_device_local.h"
57:                
58:                #ifndef uintptr_t
59:                    #if  defined(__XC8__) || defined(__XC16__)
60:                        #define uintptr_t uint16_t
61:                    #elif defined (__XC32__)
62:                        #define uintptr_t uint32_t
63:                    #endif
64:                #endif
65:                
66:                #if defined(USB_USE_MSD)
67:                    #include "usb_device_msd.h"
68:                #endif
69:                
70:                // *****************************************************************************
71:                // *****************************************************************************
72:                // Section: File Scope or Global Constants
73:                // *****************************************************************************
74:                // *****************************************************************************
75:                #if !defined(USE_USB_BUS_SENSE_IO)
76:                    //Assume the +5V VBUS is always present (like it would be in a bus powered
77:                    //only application), unless USE_USB_BUS_SENSE_IO and USB_BUS_SENSE have
78:                    //been properly defined elsewhere in the project.
79:                    #undef USB_BUS_SENSE
80:                    #define USB_BUS_SENSE 1
81:                #endif
82:                
83:                #if defined(USB_DEVICE_DISABLE_DTS_CHECKING)
84:                    #define _DTS_CHECKING_ENABLED 0
85:                #else
86:                    #define _DTS_CHECKING_ENABLED _DTSEN
87:                #endif
88:                
89:                #if !defined(self_power)
90:                    //Assume the application is always bus powered, unless self_power has been
91:                    //defined elsewhere in the project
92:                    #define self_power 0    //0 = bus powered
93:                #endif
94:                
95:                #if !defined(USB_MAX_NUM_CONFIG_DSC)
96:                    //Assume the application only implements one configuration descriptor,
97:                    //unless otherwise specified elsewhere in the project
98:                    #define USB_MAX_NUM_CONFIG_DSC      1
99:                #endif
100:               
101:               #if defined(__XC8)
102:                   //Suppress expected/harmless compiler warning message about unused RAM variables
103:                   //and certain function pointer usage.
104:                   //Certain variables and function pointers are not used if you don't use all
105:                   //of the USB stack APIs.  However, these variables should not be
106:                   //removed (since they are still used/needed in some applications, and this
107:                   //is a common file shared by many projects, some of which rely on the "unused"
108:                   //variables/function pointers).
109:                   #pragma warning disable 1090
110:                   #if __XC8_VERSION > 1300
111:                       #pragma warning disable 1471
112:                   #endif
113:               #endif
114:               
115:               // *****************************************************************************
116:               // *****************************************************************************
117:               // Section: File Scope Data Types
118:               // *****************************************************************************
119:               // *****************************************************************************
120:               typedef union
121:               {
122:                   uint8_t Val;
123:                   struct __PACKED
124:                   {
125:                       unsigned b0:1;
126:                       unsigned b1:1;
127:                       unsigned b2:1;
128:                       unsigned b3:1;
129:                       unsigned b4:1;
130:                       unsigned b5:1;
131:                       unsigned b6:1;
132:                       unsigned b7:1;
133:                   } bits;
134:               } uint8_t_VAL, uint8_t_BITS;
135:               
136:               // *****************************************************************************
137:               // *****************************************************************************
138:               // Section: Variables
139:               // *****************************************************************************
140:               // *****************************************************************************
141:               USB_VOLATILE USB_DEVICE_STATE USBDeviceState;
142:               USB_VOLATILE uint8_t USBActiveConfiguration;
143:               USB_VOLATILE uint8_t USBAlternateInterface[USB_MAX_NUM_INT];
144:               volatile BDT_ENTRY *pBDTEntryEP0OutCurrent;
145:               volatile BDT_ENTRY *pBDTEntryEP0OutNext;
146:               volatile BDT_ENTRY *pBDTEntryOut[USB_MAX_EP_NUMBER+1];
147:               volatile BDT_ENTRY *pBDTEntryIn[USB_MAX_EP_NUMBER+1];
148:               USB_VOLATILE uint8_t shortPacketStatus;
149:               USB_VOLATILE uint8_t controlTransferState;
150:               USB_VOLATILE IN_PIPE inPipes[1];
151:               USB_VOLATILE OUT_PIPE outPipes[1];
152:               USB_VOLATILE uint8_t *pDst;
153:               USB_VOLATILE bool RemoteWakeup;
154:               USB_VOLATILE bool USBBusIsSuspended;
155:               USB_VOLATILE USTAT_FIELDS USTATcopy;
156:               USB_VOLATILE uint8_t endpoint_number;
157:               USB_VOLATILE bool BothEP0OutUOWNsSet;
158:               USB_VOLATILE EP_STATUS ep_data_in[USB_MAX_EP_NUMBER+1];
159:               USB_VOLATILE EP_STATUS ep_data_out[USB_MAX_EP_NUMBER+1];
160:               USB_VOLATILE uint8_t USBStatusStageTimeoutCounter;
161:               volatile bool USBDeferStatusStagePacket;
162:               volatile bool USBStatusStageEnabledFlag1;
163:               volatile bool USBStatusStageEnabledFlag2;
164:               volatile bool USBDeferINDataStagePackets;
165:               volatile bool USBDeferOUTDataStagePackets;
166:               USB_VOLATILE uint32_t USB1msTickCount;
167:               USB_VOLATILE uint8_t USBTicksSinceSuspendEnd;
168:               
169:               /** USB FIXED LOCATION VARIABLES ***********************************/
170:               #if defined(COMPILER_MPLAB_C18)
171:                   #pragma udata USB_BDT=USB_BDT_ADDRESS
172:               #endif
173:               
174:               volatile BDT_ENTRY BDT[BDT_NUM_ENTRIES] BDT_BASE_ADDR_TAG;
175:               
176:               /********************************************************************
177:                * EP0 Buffer Space
178:                *******************************************************************/
179:               volatile CTRL_TRF_SETUP SetupPkt CTRL_TRF_SETUP_ADDR_TAG;
180:               volatile uint8_t CtrlTrfData[USB_EP0_BUFF_SIZE] CTRL_TRF_DATA_ADDR_TAG;
181:               
182:               /********************************************************************
183:                * non-EP0 Buffer Space
184:                *******************************************************************/
185:               #if defined(USB_USE_MSD)
186:                   //Check if the MSD application specific USB endpoint buffer placement address 
187:                   //macros have already been defined or not (ex: in a processor specific header)
188:                   //The msd_cbw and msd_csw buffers must be USB module accessible (and therefore
189:                   //must be at a certain address range on certain microcontrollers).
190:                   #if !defined(MSD_CBW_ADDR_TAG)
191:                       //Not previously defined.  Assume in this case all microcontroller RAM is
192:                       //USB module accessible, and therefore, no specific address tag value is needed.
193:                       #define MSD_CBW_ADDR_TAG
194:                       #define MSD_CSW_ADDR_TAG
195:                   #endif
196:               	volatile USB_MSD_CBW msd_cbw MSD_CBW_ADDR_TAG;  //Must be located in USB module accessible RAM
197:               	volatile USB_MSD_CSW msd_csw MSD_CSW_ADDR_TAG;  //Must be located in USB module accessible RAM
198:               
199:                   #if defined(__18CXX) || defined(__XC8)
200:                       volatile char msd_buffer[512] @ MSD_BUFFER_ADDRESS;
201:                   #else
202:                       volatile char msd_buffer[512];
203:               	#endif
204:               #endif
205:               
206:               //Depricated in v2.2 - will be removed in a future revision
207:               #if !defined(USB_USER_DEVICE_DESCRIPTOR)
208:                   //Device descriptor
209:                   extern const USB_DEVICE_DESCRIPTOR device_dsc;
210:               #else
211:                   USB_USER_DEVICE_DESCRIPTOR_INCLUDE;
212:               #endif
213:               
214:               #if !defined(USB_USER_CONFIG_DESCRIPTOR)
215:                   //Array of configuration descriptors
216:                   extern const uint8_t *const USB_CD_Ptr[];
217:               #else
218:                   USB_USER_CONFIG_DESCRIPTOR_INCLUDE;
219:               #endif
220:               
221:               extern const uint8_t *const USB_SD_Ptr[];
222:               
223:               
224:               // *****************************************************************************
225:               // *****************************************************************************
226:               // Section: Private and External Prototypes
227:               // *****************************************************************************
228:               // *****************************************************************************
229:               extern bool USER_USB_CALLBACK_EVENT_HANDLER(USB_EVENT event, void *pdata, uint16_t size);
230:               
231:               static void USBCtrlEPService(void);
232:               static void USBCtrlTrfSetupHandler(void);
233:               static void USBCtrlTrfInHandler(void);
234:               static void USBCheckStdRequest(void);
235:               static void USBStdGetDscHandler(void);
236:               static void USBCtrlEPServiceComplete(void);
237:               static void USBCtrlTrfTxService(void);
238:               static void USBCtrlTrfRxService(void);
239:               static void USBStdSetCfgHandler(void);
240:               static void USBStdGetStatusHandler(void);
241:               static void USBStdFeatureReqHandler(void);
242:               static void USBCtrlTrfOutHandler(void);
243:               static void USBConfigureEndpoint(uint8_t EPNum, uint8_t direction);
244:               static void USBWakeFromSuspend(void);
245:               static void USBSuspend(void);
246:               static void USBStallHandler(void);
247:               
248:               // *****************************************************************************
249:               // *****************************************************************************
250:               // Section: Macros or Functions
251:               // *****************************************************************************
252:               // *****************************************************************************
253:               
254:               /**************************************************************************
255:                   Function:
256:                       void USBDeviceInit(void)
257:                   
258:                   Description:
259:                       This function initializes the device stack it in the default state. The
260:                       USB module will be completely reset including all of the internal
261:                       variables, registers, and interrupt flags.
262:                               
263:                   Precondition:
264:                       This function must be called before any of the other USB Device
265:                       functions can be called, including USBDeviceTasks().
266:                       
267:                   Parameters:
268:                       None
269:                    
270:                   Return Values:
271:                       None
272:                       
273:                   Remarks:
274:                       None
275:                                                                         
276:                 ***************************************************************************/
277:               void USBDeviceInit(void)
278:               {
0004F8  FA0002     LNK #0x2
279:                   uint8_t i;
280:               
281:                   USBDisableInterrupts();
0004FA  A9C09E     BCLR IEC5, #6
282:               
283:                   //Make sure that if a GPIO output driver exists on VBUS, that it is 
284:                   //tri-stated to avoid potential contention with the host
285:                   USB_HAL_VBUSTristate();
0004FC  A8C18A     BSET TRISB, #6
286:                   
287:                   // Clear all USB error flags
288:                   USBClearInterruptRegister(U1EIR);  
0004FE  EB8000     SETM W0
000500  882070     MOV W0, U1EIR
289:                      
290:                   // Clears all USB interrupts          
291:                   USBClearInterruptRegister(U1IR); 
000502  EB8000     SETM W0
000504  882050     MOV W0, U1IR
292:               
293:                   //Clear all of the endpoint control registers
294:                   U1EP0 = 0;
000506  EF242A     CLR U1EP0
295:                   
296:                   DisableNonZeroEndpoints(USB_MAX_EP_NUMBER);
000508  200022     MOV #0x2, W2
00050A  EB0080     CLR W1
00050C  2042C0     MOV #0x42C, W0
00050E  07FF51     RCALL _memset
297:               
298:                   SetConfigurationOptions();
000510  200020     MOV #0x2, W0
000512  882130     MOV W0, U1CNFG1
000514  EF2428     CLR U1CNFG2
000516  A94406     BCLR U1OTGCON, #2
000518  2009F0     MOV #0x9F, W0
00051A  882080     MOV W0, U1EIE
00051C  2009F0     MOV #0x9F, W0
00051E  882060     MOV W0, U1IE
000520  A8C402     BSET U1OTGIE, #6
299:               
300:                   //power up the module (if not already powered)
301:                   USBPowerModule();
000522  A80408     BSET U1PWRC, #0
302:               
303:                   //set the address of the BDT (if applicable)
304:                   USBSetBDTAddress(BDT);
000524  20A000     MOV #0xA00, W0
000526  DE0048     LSR W0, #8, W0
000528  8820C0     MOV W0, U1BDTP1
305:               
306:                   //Clear all of the BDT entries
307:                   for(i = 0; i < (sizeof(BDT)/sizeof(BDT_ENTRY)); i++)
00052A  EB4000     CLR.B W0
00052C  784F00     MOV.B W0, [W14]
00052E  370007     BRA .L2
00053C  E84F1E     INC.B [W14], [W14]
00053E  78401E     MOV.B [W14], W0
000540  504FE7     SUB.B W0, #0x7, [W15]
000542  36FFF6     BRA LEU, .L3
308:                   {
309:                       BDT[i].Val = 0x00;
000530  FB801E     ZE [W14], W0
000532  DD00C2     SL W0, #2, W1
000534  20A000     MOV #0xA00, W0
000536  408100     ADD W1, W0, W2
000538  B80060     MUL.UU W0, #0, W0
00053A  BE8900     MOV.D W0, [W2]
310:                   }
311:               
312:                   // Assert reset request to all of the Ping Pong buffer pointers
313:                   USBPingPongBufferReset = 1;                    
000544  A82414     BSET U1CON, #1
314:               
315:                   // Reset to default address
316:                   U1ADDR = 0x00;                   
000546  EF2416     CLR U1ADDR
317:               
318:                   // Make sure packet processing is enabled
319:                   USBPacketDisable = 0;           
000548  A9A414     BCLR U1CON, #5
320:               
321:                   //Stop trying to reset ping pong buffer pointers
322:                   USBPingPongBufferReset = 0;
00054A  A92414     BCLR U1CON, #1
323:               
324:                   // Flush any pending transactions
325:                   do
326:                   {
327:                       USBClearInterruptFlag(USBTransactionCompleteIFReg,USBTransactionCompleteIFBitNum);
00054C  200080     MOV #0x8, W0
00054E  882050     MOV W0, U1IR
328:                       //Initialize USB stack software state variables
329:                       inPipes[0].info.Val = 0;
000550  208400     MOV #0x840, W0
000552  EB4080     CLR.B W1
000554  784801     MOV.B W1, [W0]
330:                       outPipes[0].info.Val = 0;
000556  208460     MOV #0x846, W0
000558  EB4080     CLR.B W1
00055A  784801     MOV.B W1, [W0]
331:                       outPipes[0].wCount.Val = 0;
00055C  804231     MOV 0x846, W1
00055E  200FF0     MOV #0xFF, W0
000560  608000     AND W1, W0, W0
000562  884230     MOV W0, 0x846
000564  804241     MOV 0x848, W1
000566  2FF000     MOV #0xFF00, W0
000568  608000     AND W1, W0, W0
00056A  884240     MOV W0, 0x848
332:                   }while(USBTransactionCompleteIF == 1);
00056C  802050     MOV U1IR, W0
00056E  600068     AND W0, #0x8, W0
000570  E00000     CP0 W0
000572  3AFFEC     BRA NZ, .L4
333:               
334:                   //Set flags to true, so the USBCtrlEPAllowStatusStage() function knows not to
335:                   //try and arm a status stage, even before the first control transfer starts.
336:                   USBStatusStageEnabledFlag1 = true;
000574  B3C010     MOV.B #0x1, W0
000576  B7E81B     MOV.B WREG, USBStatusStageEnabledFlag1
337:                   USBStatusStageEnabledFlag2 = true;
000578  B3C010     MOV.B #0x1, W0
00057A  B7E81C     MOV.B WREG, USBStatusStageEnabledFlag2
338:                   //Initialize other flags
339:                   USBDeferINDataStagePackets = false;
00057C  EF681D     CLR.B USBDeferINDataStagePackets
340:                   USBDeferOUTDataStagePackets = false;
00057E  EF681E     CLR.B USBDeferOUTDataStagePackets
341:                   USBBusIsSuspended = false;
000580  EF6815     CLR.B USBBusIsSuspended
342:               
343:                   //Initialize all pBDTEntryIn[] and pBDTEntryOut[]
344:                   //pointers to NULL, so they don't get used inadvertently.
345:                   for(i = 0; i < (uint8_t)(USB_MAX_EP_NUMBER+1u); i++)
000582  EB4000     CLR.B W0
000584  784F00     MOV.B W0, [W14]
000586  370017     BRA .L5
0005B4  E84F1E     INC.B [W14], [W14]
0005B6  78401E     MOV.B [W14], W0
0005B8  504FE1     SUB.B W0, #0x1, [W15]
0005BA  36FFE6     BRA LEU, .L6
346:                   {
347:                       pBDTEntryIn[i] = 0u;
000588  FB801E     ZE [W14], W0
00058A  400080     ADD W0, W0, W1
00058C  2080C0     MOV #0x80C, W0
00058E  408000     ADD W1, W0, W0
000590  EB0080     CLR W1
000592  780801     MOV W1, [W0]
348:                       pBDTEntryOut[i] = 0u;
000594  FB801E     ZE [W14], W0
000596  400080     ADD W0, W0, W1
000598  208080     MOV #0x808, W0
00059A  408000     ADD W1, W0, W0
00059C  EB0080     CLR W1
00059E  780801     MOV W1, [W0]
349:                       ep_data_in[i].Val = 0u;
0005A0  FB809E     ZE [W14], W1
0005A2  2084C0     MOV #0x84C, W0
0005A4  408000     ADD W1, W0, W0
0005A6  EB4080     CLR.B W1
0005A8  784801     MOV.B W1, [W0]
350:                       ep_data_out[i].Val = 0u;
0005AA  FB809E     ZE [W14], W1
0005AC  2084E0     MOV #0x84E, W0
0005AE  408000     ADD W1, W0, W0
0005B0  EB4080     CLR.B W1
0005B2  784801     MOV.B W1, [W0]
351:                   }
352:               
353:                   //Get ready for the first packet
354:                   pBDTEntryIn[0] = (volatile BDT_ENTRY*)&BDT[EP0_IN_EVEN];
0005BC  20A080     MOV #0xA08, W0
0005BE  884060     MOV W0, pBDTEntryIn
355:                   // Initialize EP0 as a Ctrl EP
356:                   U1EP0 = EP_CTRL|USB_HANDSHAKE_ENABLED;        
0005C0  2000D0     MOV #0xD, W0
0005C2  882150     MOV W0, U1EP0
357:               	//Prepare for the first SETUP on EP0 OUT
358:                   BDT[EP0_OUT_EVEN].ADR = ConvertToPhysicalAddress(&SetupPkt);
0005C4  208500     MOV #0x850, W0
0005C6  885010     MOV W0, 0xA02
359:                   BDT[EP0_OUT_EVEN].CNT = USB_EP0_BUFF_SIZE;
0005C8  20A000     MOV #0xA00, W0
0005CA  B3C081     MOV.B #0x8, W1
0005CC  784801     MOV.B W1, [W0]
360:                   BDT[EP0_OUT_EVEN].STAT.Val = _DAT0|_BSTALL;
0005CE  20A010     MOV #0xA01, W0
0005D0  B3C041     MOV.B #0x4, W1
0005D2  784801     MOV.B W1, [W0]
361:                   BDT[EP0_OUT_EVEN].STAT.Val |= _USIE;
0005D4  20A010     MOV #0xA01, W0
0005D6  784010     MOV.B [W0], W0
0005D8  784080     MOV.B W0, W1
0005DA  A07401     BSET.B W1, #7
0005DC  20A010     MOV #0xA01, W0
0005DE  784801     MOV.B W1, [W0]
362:               
363:                   // Clear active configuration
364:                   USBActiveConfiguration = 0;     
0005E0  EF6802     CLR.B USBActiveConfiguration
365:               
366:                   USB1msTickCount = 0;            //Keeps track of total number of milliseconds since calling USBDeviceInit() when first initializing the USB module/stack code.
0005E2  EF2820     CLR USB1msTickCount
0005E4  EF2822     CLR 0x822
367:                   USBTicksSinceSuspendEnd = 0;    //Keeps track of the number of milliseconds since a suspend condition has ended.
0005E6  EF6824     CLR.B USBTicksSinceSuspendEnd
368:               
369:                   //Indicate that we are now in the detached state
370:                   USBDeviceState = DETACHED_STATE;
0005E8  EF2800     CLR USBDeviceState
371:               }
0005EA  FA8000     ULNK
0005EC  060000     RETURN
372:               
373:               
374:               
375:               /**************************************************************************
376:                 Function:
377:                       void USBDeviceTasks(void)
378:                   
379:                 Summary:
380:                   This function is the main state machine/transaction handler of the USB 
381:                   device side stack.  When the USB stack is operated in "USB_POLLING" mode 
382:                   (usb_config.h user option) the USBDeviceTasks() function should be called 
383:                   periodically to receive and transmit packets through the stack. This 
384:                   function also takes care of control transfers associated with the USB 
385:                   enumeration process, and detecting various USB events (such as suspend).  
386:                   This function should be called at least once every 1.8ms during the USB 
387:                   enumeration process. After the enumeration process is complete (which can 
388:                   be determined when USBGetDeviceState() returns CONFIGURED_STATE), the 
389:                   USBDeviceTasks() handler may be called the faster of: either once 
390:                   every 9.8ms, or as often as needed to make sure that the hardware USTAT 
391:                   FIFO never gets full.  A good rule of thumb is to call USBDeviceTasks() at
392:                   a minimum rate of either the frequency that USBTransferOnePacket() gets 
393:                   called, or, once/1.8ms, whichever is faster.  See the inline code comments 
394:                   near the top of usb_device.c for more details about minimum timing 
395:                   requirements when calling USBDeviceTasks().
396:                   
397:                   When the USB stack is operated in "USB_INTERRUPT" mode, it is not necessary
398:                   to call USBDeviceTasks() from the main loop context.  In the USB_INTERRUPT
399:                   mode, the USBDeviceTasks() handler only needs to execute when a USB 
400:                   interrupt occurs, and therefore only needs to be called from the interrupt 
401:                   context.
402:               
403:                 Description:
404:                   This function is the main state machine/transaction handler of the USB 
405:                   device side stack.  When the USB stack is operated in "USB_POLLING" mode 
406:                   (usb_config.h user option) the USBDeviceTasks() function should be called 
407:                   periodically to receive and transmit packets through the stack. This 
408:                   function also takes care of control transfers associated with the USB 
409:                   enumeration process, and detecting various USB events (such as suspend).  
410:                   This function should be called at least once every 1.8ms during the USB 
411:                   enumeration process. After the enumeration process is complete (which can 
412:                   be determined when USBGetDeviceState() returns CONFIGURED_STATE), the 
413:                   USBDeviceTasks() handler may be called the faster of: either once 
414:                   every 9.8ms, or as often as needed to make sure that the hardware USTAT 
415:                   FIFO never gets full.  A good rule of thumb is to call USBDeviceTasks() at
416:                   a minimum rate of either the frequency that USBTransferOnePacket() gets 
417:                   called, or, once/1.8ms, whichever is faster.  See the inline code comments 
418:                   near the top of usb_device.c for more details about minimum timing 
419:                   requirements when calling USBDeviceTasks().
420:                   
421:                   When the USB stack is operated in "USB_INTERRUPT" mode, it is not necessary
422:                   to call USBDeviceTasks() from the main loop context.  In the USB_INTERRUPT
423:                   mode, the USBDeviceTasks() handler only needs to execute when a USB 
424:                   interrupt occurs, and therefore only needs to be called from the interrupt 
425:                   context.
426:               
427:                   Typical usage:
428:                   <code>
429:                   void main(void)
430:                   {
431:                       USBDeviceInit();
432:                       while(1)
433:                       {
434:                           USBDeviceTasks(); //Takes care of enumeration and other USB events
435:                           if((USBGetDeviceState() \< CONFIGURED_STATE) ||
436:                              (USBIsDeviceSuspended() == true))
437:                           {
438:                               //Either the device is not configured or we are suspended,
439:                               // so we don't want to execute any USB related application code
440:                               continue;   //go back to the top of the while loop
441:                           }
442:                           else
443:                           {
444:                               //Otherwise we are free to run USB and non-USB related user 
445:                               //application code.
446:                               UserApplication();
447:                           }
448:                       }
449:                   }
450:                   </code>
451:               
452:                 Precondition:
453:                   Make sure the USBDeviceInit() function has been called prior to calling
454:                   USBDeviceTasks() for the first time.
455:                 Remarks:
456:                   USBDeviceTasks() does not need to be called while in the USB suspend mode, 
457:                   if the user application firmware in the USBCBSuspend() callback function
458:                   enables the ACTVIF USB interrupt source and put the microcontroller into 
459:                   sleep mode.  If the application firmware decides not to sleep the 
460:                   microcontroller core during USB suspend (ex: continues running at full 
461:                   frequency, or clock switches to a lower frequency), then the USBDeviceTasks()
462:                   function must still be called periodically, at a rate frequent enough to 
463:                   ensure the 10ms resume recovery interval USB specification is met.  Assuming
464:                   a worst case primary oscillator and PLL start up time of less than 5ms, then
465:                   USBDeviceTasks() should be called once every 5ms in this scenario.
466:                  
467:                   When the USB cable is detached, or the USB host is not actively powering 
468:                   the VBUS line to +5V nominal, the application firmware does not always have 
469:                   to call USBDeviceTasks() frequently, as no USB activity will be taking 
470:                   place.  However, if USBDeviceTasks() is not called regularly, some 
471:                   alternative means of promptly detecting when VBUS is powered (indicating 
472:                   host attachment), or not powered (host powered down or USB cable unplugged)
473:                   is still needed.  For self or dual self/bus powered USB applications, see 
474:                   the USBDeviceAttach() and USBDeviceDetach() API documentation for additional 
475:                   considerations.
476:                   ***************************************************************************/
477:               void USBDeviceTasks(void)
478:               {
0005EE  FA0002     LNK #0x2
479:                   uint8_t i;
480:               
481:                   #ifdef USB_SUPPORT_OTG
482:                       //SRP Time Out Check
483:                       if (USBOTGSRPIsReady())
484:                       {
485:                           if (USBT1MSECIF && USBT1MSECIE)
486:                           {
487:                               if (USBOTGGetSRPTimeOutFlag())
488:                               {
489:                                   if (USBOTGIsSRPTimeOutExpired())
490:                                   {
491:                                       USB_OTGEventHandler(0,OTG_EVENT_SRP_FAILED,0,0);
492:                                   }
493:                               }
494:               
495:                               //Clear Interrupt Flag
496:                               USBClearInterruptFlag(USBT1MSECIFReg,USBT1MSECIFBitNum);
497:                           }
498:                       }
499:                   #endif
500:               
501:                   #if defined(USB_POLLING)
502:                   //If the interrupt option is selected then the customer is required
503:                   //  to notify the stack when the device is attached or removed from the
504:                   //  bus by calling the USBDeviceAttach() and USBDeviceDetach() functions.
505:                   if (USB_BUS_SENSE != 1)
506:                   {
507:                        // Disable module & detach from bus
508:                        U1CON = 0;             
509:               
510:                        // Mask all USB interrupts              
511:                        U1IE = 0;          
512:               
513:                        //Move to the detached state                  
514:                        USBDeviceState = DETACHED_STATE;
515:               
516:                        #ifdef  USB_SUPPORT_OTG    
517:                            //Disable D+ Pullup
518:                            U1OTGCONbits.DPPULUP = 0;
519:               
520:                            //Disable HNP
521:                            USBOTGDisableHnp();
522:               
523:                            //Deactivate HNP
524:                            USBOTGDeactivateHnp();
525:                            
526:                            //If ID Pin Changed State
527:                            if (USBIDIF && USBIDIE)
528:                            {  
529:                                //Re-detect & Initialize
530:                                 USBOTGInitialize();
531:               
532:                                 //Clear ID Interrupt Flag
533:                                 USBClearInterruptFlag(USBIDIFReg,USBIDIFBitNum);
534:                            }
535:                        #endif
536:               
537:                        #if defined __C30__ || defined __XC16__
538:                            //USBClearInterruptFlag(U1OTGIR, 3); 
539:                        #endif
540:                           //return so that we don't go through the rest of 
541:                           //the state machine
542:                        USBClearUSBInterrupt();
543:                        return;
544:                   }
545:               
546:               	#ifdef USB_SUPPORT_OTG
547:                   //If Session Is Started Then
548:                   else
549:               	{
550:                       //If SRP Is Ready
551:                       if (USBOTGSRPIsReady())
552:                       {   
553:                           //Clear SRPReady
554:                           USBOTGClearSRPReady();
555:               
556:                           //Clear SRP Timeout Flag
557:                           USBOTGClearSRPTimeOutFlag();
558:               
559:                           //Indicate Session Started
560:                           UART2PrintString( "\r\n***** USB OTG B Event - Session Started  *****\r\n" );
561:                       }
562:                   }
563:               	#endif	//#ifdef USB_SUPPORT_OTG
564:               
565:                   //if we are in the detached state
566:                   if(USBDeviceState == DETACHED_STATE)
567:                   {
568:               	    //Initialize register to known value
569:                       U1CON = 0;                          
570:               
571:                       // Mask all USB interrupts
572:                       U1IE = 0;                                
573:               
574:                       //Enable/set things like: pull ups, full/low-speed mode, 
575:                       //set the ping pong mode, and set internal transceiver
576:                       SetConfigurationOptions();
577:               
578:                       // Enable module & attach to bus
579:                       while(!U1CONbits.USBEN){U1CONbits.USBEN = 1;}
580:               
581:                       //moved to the attached state
582:                       USBDeviceState = ATTACHED_STATE;
583:               
584:                       #ifdef  USB_SUPPORT_OTG
585:                           U1OTGCON |= USB_OTG_DPLUS_ENABLE | USB_OTG_ENABLE;  
586:                       #endif
587:                   }
588:               	#endif  //#if defined(USB_POLLING)
589:               
590:                   if(USBDeviceState == ATTACHED_STATE)
0005F0  804000     MOV USBDeviceState, W0
0005F2  500FE1     SUB W0, #0x1, [W15]
0005F4  3A000B     BRA NZ, .L8
591:                   {
592:                       /*
593:                        * After enabling the USB module, it takes some time for the
594:                        * voltage on the D+ or D- line to rise high enough to get out
595:                        * of the SE0 condition. The USB Reset interrupt should not be
596:                        * unmasked until the SE0 condition is cleared. This helps
597:                        * prevent the firmware from misinterpreting this unique event
598:                        * as a USB bus reset from the USB host.
599:                        */
600:               
601:                       if(!USBSE0Event)
0005F6  8020A1     MOV U1CON, W1
0005F8  200400     MOV #0x40, W0
0005FA  608000     AND W1, W0, W0
0005FC  E00000     CP0 W0
0005FE  3A0006     BRA NZ, .L8
602:                       {
603:                           //We recently attached, make sure we are in a clean state
604:                           #if defined(__dsPIC33E__) || defined(_PIC24E__) || defined(__PIC32MM__)
605:                               U1IR = 0xFFEF;  //Preserve IDLEIF info, so we can detect suspend
606:                                               //during attach de-bounce interval
607:                           #else
608:                               USBClearInterruptRegister(U1IR);
000600  EB8000     SETM W0
000602  882050     MOV W0, U1IR
609:                           #endif
610:               
611:                           #if defined(USB_POLLING)
612:                               U1IE=0;                        // Mask all USB interrupts
613:                           #endif
614:                           USBResetIE = 1;             // Unmask RESET interrupt
000604  A8040C     BSET U1IE, #0
615:                           USBIdleIE = 1;             // Unmask IDLE interrupt
000606  A8840C     BSET U1IE, #4
616:                           USBDeviceState = POWERED_STATE;
000608  200020     MOV #0x2, W0
00060A  884000     MOV W0, USBDeviceState
617:                       }
618:                   }
619:               
620:                   #ifdef  USB_SUPPORT_OTG
621:                       //If ID Pin Changed State
622:                       if (USBIDIF && USBIDIE)
623:                       {  
624:                           //Re-detect & Initialize
625:                           USBOTGInitialize();
626:               
627:                           USBClearInterruptFlag(USBIDIFReg,USBIDIFBitNum);
628:                       }
629:                   #endif
630:               
631:                   /*
632:                    * Task A: Service USB Activity Interrupt
633:                    */
634:                   if(USBActivityIF && USBActivityIE)
00060C  802000     MOV U1OTGIR, W0
00060E  600070     AND W0, #0x10, W0
000610  E00000     CP0 W0
000612  320007     BRA Z, .L9
000614  802010     MOV U1OTGIE, W0
000616  600070     AND W0, #0x10, W0
000618  E00000     CP0 W0
00061A  320003     BRA Z, .L9
635:                   {
636:                       USBClearInterruptFlag(USBActivityIFReg,USBActivityIFBitNum);
00061C  200100     MOV #0x10, W0
00061E  882000     MOV W0, U1OTGIR
637:                       #if defined(USB_SUPPORT_OTG)
638:                           U1OTGIR = 0x10;        
639:                       #else
640:                           USBWakeFromSuspend();
000620  0704BB     RCALL _USBWakeFromSuspend, .LFE18, .LFB19
641:                       #endif
642:                   }
643:               
644:                   /*
645:                    * Pointless to continue servicing if the device is in suspend mode.
646:                    */
647:                   if(USBSuspendControl==1)
000622  802040     MOV U1PWRC, W0
000624  600062     AND W0, #0x2, W0
000626  E00000     CP0 W0
000628  320002     BRA Z, .L10
648:                   {
649:                       USBClearUSBInterrupt();
00062A  A9C08E     BCLR IFS5, #6
650:                       return;
00062C  3700A3     BRA .L7
651:                   }
652:               
653:                   /*
654:                    * Task B: Service USB Bus Reset Interrupt.
655:                    * When bus reset is received during suspend, ACTVIF will be set first,
656:                    * once the UCONbits.SUSPND is clear, then the URSTIF bit will be asserted.
657:                    * This is why URSTIF is checked after ACTVIF.
658:                    *
659:                    * The USB reset flag is masked when the USB state is in
660:                    * DETACHED_STATE or ATTACHED_STATE, and therefore cannot
661:                    * cause a USB reset event during these two states.
662:                    */
663:                   if(USBResetIF && USBResetIE)
00062E  802050     MOV U1IR, W0
000630  600061     AND W0, #0x1, W0
000632  E00000     CP0 W0
000634  32000A     BRA Z, .L12
000636  802060     MOV U1IE, W0
000638  600061     AND W0, #0x1, W0
00063A  E00000     CP0 W0
00063C  320006     BRA Z, .L12
664:                   {
665:                       USBDeviceInit();
00063E  07FF5C     RCALL USBDeviceInit
666:               
667:                       //Re-enable the interrupts since the USBDeviceInit() function will
668:                       //  disable them.  This will do nothing in a polling setup
669:                       USBUnmaskInterrupts();
000640  A8C09E     BSET IEC5, #6
670:               
671:                       USBDeviceState = DEFAULT_STATE;
000642  200040     MOV #0x4, W0
000644  884000     MOV W0, USBDeviceState
672:               
673:                       #ifdef USB_SUPPORT_OTG
674:                            //Disable HNP
675:                            USBOTGDisableHnp();
676:               
677:                            //Deactivate HNP
678:                            USBOTGDeactivateHnp();
679:                       #endif
680:               
681:                       USBClearInterruptFlag(USBResetIFReg,USBResetIFBitNum);
000646  200010     MOV #0x1, W0
000648  882050     MOV W0, U1IR
682:                   }
683:               
684:                   /*
685:                    * Task C: Service other USB interrupts
686:                    */
687:                   if(USBIdleIF && USBIdleIE)
00064A  802050     MOV U1IR, W0
00064C  600070     AND W0, #0x10, W0
00064E  E00000     CP0 W0
000650  320005     BRA Z, .L13
000652  802060     MOV U1IE, W0
000654  600070     AND W0, #0x10, W0
000656  E00000     CP0 W0
000658  320001     BRA Z, .L13
688:                   { 
689:                       #ifdef  USB_SUPPORT_OTG 
690:                           //If Suspended, Try to switch to Host
691:                           USBOTGSelectRole(ROLE_HOST);
692:                           USBClearInterruptFlag(USBIdleIFReg,USBIdleIFBitNum);
693:                       #else
694:                           USBSuspend();
00065A  070491     RCALL _USBSuspend, .LFE17, .LFB18
695:                       #endif
696:                   }
697:               
698:                   #if defined(__XC16__) || defined(__C30__) || defined(__XC32__)
699:                       //Check if a 1ms interval has elapsed.	
700:                       if(USBT1MSECIF)
00065C  802001     MOV U1OTGIR, W1
00065E  200400     MOV #0x40, W0
000660  608000     AND W1, W0, W0
000662  E00000     CP0 W0
000664  320003     BRA Z, .L14
701:                       {
702:                           USBClearInterruptFlag(USBT1MSECIFReg, USBT1MSECIFBitNum);
000666  200400     MOV #0x40, W0
000668  882000     MOV W0, U1OTGIR
703:                           USBIncrement1msInternalTimers();
00066A  0706F7     RCALL USBIncrement1msInternalTimers
704:                       }
705:                   #endif
706:               
707:                   //Start-of-Frame Interrupt
708:                   if(USBSOFIF)
00066C  802050     MOV U1IR, W0
00066E  600064     AND W0, #0x4, W0
000670  E00000     CP0 W0
000672  320014     BRA Z, .L15
709:                   {
710:                       //Call the user SOF event callback if enabled.
711:                       if(USBSOFIE)
000674  802060     MOV U1IE, W0
000676  600064     AND W0, #0x4, W0
000678  E00000     CP0 W0
00067A  320004     BRA Z, .L16
712:                       {
713:                           USB_SOF_HANDLER(EVENT_SOF,0,1);
00067C  200012     MOV #0x1, W2
00067E  EB0080     CLR W1
000680  200730     MOV #0x73, W0
000682  070A4D     RCALL USER_USB_CALLBACK_EVENT_HANDLER
714:                       }    
715:                       USBClearInterruptFlag(USBSOFIFReg,USBSOFIFBitNum);
000684  200040     MOV #0x4, W0
000686  882050     MOV W0, U1IR
716:               
717:                       #if defined(__XC8__) || defined(__C18__)
718:                           USBIncrement1msInternalTimers();
719:                       #endif
720:               
721:                       #if defined(USB_ENABLE_STATUS_STAGE_TIMEOUTS)
722:                           //Supporting this feature requires a 1ms time base for keeping track of the timeout interval.
723:                           #if(USB_SPEED_OPTION == USB_LOW_SPEED)
724:                               #warning "Double click this message.  See inline code comments."
725:                               //The "USB_ENABLE_STATUS_STAGE_TIMEOUTS" feature is optional and is
726:                               //not strictly needed in all applications (ex: those that never call 
727:                               //USBDeferStatusStage() and don't use host to device (OUT) control
728:                               //transfers with data stage).  
729:                               //However, if this feature is enabled and used in a low speed application,
730:                               //it is required for the application code to periodically call the
731:                               //USBIncrement1msInternalTimers() function at a nominally 1ms rate.
732:                           #endif
733:                           
734:                           //Decrement our status stage counter.
735:                           if(USBStatusStageTimeoutCounter != 0u)
000688  BFC819     MOV.B USBStatusStageTimeoutCounter, WREG
00068A  E00400     CP0.B W0
00068C  320003     BRA Z, .L17
736:                           {
737:                               USBStatusStageTimeoutCounter--;
00068E  BFC819     MOV.B USBStatusStageTimeoutCounter, WREG
000690  E94000     DEC.B W0, W0
000692  B7E819     MOV.B WREG, USBStatusStageTimeoutCounter
738:                           }
739:                           //Check if too much time has elapsed since progress was made in 
740:                           //processing the control transfer, without arming the status stage.  
741:                           //If so, auto-arm the status stage to ensure that the control 
742:                           //transfer can [eventually] complete, within the timing limits
743:                           //dictated by section 9.2.6 of the official USB 2.0 specifications.
744:                           if(USBStatusStageTimeoutCounter == 0)
000694  BFC819     MOV.B USBStatusStageTimeoutCounter, WREG
000696  E00400     CP0.B W0
000698  3A0001     BRA NZ, .L15
745:                           {
746:                               USBCtrlEPAllowStatusStage();    //Does nothing if the status stage was already armed.
00069A  0701A5     RCALL USBCtrlEPAllowStatusStage
747:                           } 
748:                       #endif
749:                   }
750:               
751:                   if(USBStallIF && USBStallIE)
00069C  802051     MOV U1IR, W1
00069E  200800     MOV #0x80, W0
0006A0  608000     AND W1, W0, W0
0006A2  E00000     CP0 W0
0006A4  320006     BRA Z, .L18
0006A6  802061     MOV U1IE, W1
0006A8  200800     MOV #0x80, W0
0006AA  608000     AND W1, W0, W0
0006AC  E00000     CP0 W0
0006AE  320001     BRA Z, .L18
752:                   {
753:                       USBStallHandler();
0006B0  07044A     RCALL _USBStallHandler, .LFE16, .LFB17
754:                   }
755:               
756:                   if(USBErrorIF && USBErrorIE)
0006B2  802050     MOV U1IR, W0
0006B4  600062     AND W0, #0x2, W0
0006B6  E00000     CP0 W0
0006B8  32000C     BRA Z, .L19
0006BA  802060     MOV U1IE, W0
0006BC  600062     AND W0, #0x2, W0
0006BE  E00000     CP0 W0
0006C0  320008     BRA Z, .L19
757:                   {
758:                       USB_ERROR_HANDLER(EVENT_BUS_ERROR,0,1);
0006C2  200012     MOV #0x1, W2
0006C4  EB0080     CLR W1
0006C6  27FFF0     MOV #0x7FFF, W0
0006C8  070A2A     RCALL USER_USB_CALLBACK_EVENT_HANDLER
759:                       USBClearInterruptRegister(U1EIR);               // This clears UERRIF
0006CA  EB8000     SETM W0
0006CC  882070     MOV W0, U1EIR
760:               
761:                       //On PIC18, clearing the source of the error will automatically clear
762:                       //  the interrupt flag.  On other devices the interrupt flag must be 
763:                       //  manually cleared. 
764:                       #if defined(__C32__) || defined(__C30__) || defined __XC16__
765:                           USBClearInterruptFlag( USBErrorIFReg, USBErrorIFBitNum );
0006CE  200020     MOV #0x2, W0
0006D0  882050     MOV W0, U1IR
766:                       #endif
767:                   }
768:               
769:                   /*
770:                    * Pointless to continue servicing if the host has not sent a bus reset.
771:                    * Once bus reset is received, the device transitions into the DEFAULT
772:                    * state and is ready for communication.
773:                    */
774:                   if(USBDeviceState < DEFAULT_STATE)
0006D2  804000     MOV USBDeviceState, W0
0006D4  500FE3     SUB W0, #0x3, [W15]
0006D6  3E0002     BRA GTU, .L20
775:                   {
776:                       USBClearUSBInterrupt();
0006D8  A9C08E     BCLR IFS5, #6
777:                       return;
0006DA  37004C     BRA .L7
778:                   }  
779:               
780:                   /*
781:                    * Task D: Servicing USB Transaction Complete Interrupt
782:                    */
783:                   if(USBTransactionCompleteIE)
0006DC  802060     MOV U1IE, W0
0006DE  600068     AND W0, #0x8, W0
0006E0  E00000     CP0 W0
0006E2  320047     BRA Z, .L21
784:                   {
785:                       for(i = 0; i < 4u; i++)	//Drain or deplete the USAT FIFO entries.  If the USB FIFO ever gets full, USB bandwidth
0006E4  EB4000     CLR.B W0
0006E6  784F00     MOV.B W0, [W14]
0006E8  37003F     BRA .L22
000766  E84F1E     INC.B [W14], [W14]
000768  78401E     MOV.B [W14], W0
00076A  504FE3     SUB.B W0, #0x3, [W15]
00076C  36FFBE     BRA LEU, .L28
00076E  370001     BRA .L21
786:                       {						//utilization can be compromised, and the device won't be able to receive SETUP packets.
787:                           if(USBTransactionCompleteIF)
0006EA  802050     MOV U1IR, W0
0006EC  600068     AND W0, #0x8, W0
0006EE  E00000     CP0 W0
0006F0  32003F     BRA Z, .L29
788:                           {
789:                               //Save and extract USTAT register info.  Will use this info later.
790:                               USTATcopy.Val = U1STAT;
0006F2  802090     MOV U1STAT, W0
0006F4  784000     MOV.B W0, W0
0006F6  B7E816     MOV.B WREG, USTATcopy
791:                               endpoint_number = USBHALGetLastEndpoint(USTATcopy);
0006F8  BFC816     MOV.B USTATcopy, WREG
0006FA  FB8000     ZE W0, W0
0006FC  DE0044     LSR W0, #4, W0
0006FE  784000     MOV.B W0, W0
000700  B7E817     MOV.B WREG, endpoint_number
792:               
793:                               USBClearInterruptFlag(USBTransactionCompleteIFReg,USBTransactionCompleteIFBitNum);
000702  200080     MOV #0x8, W0
000704  882050     MOV W0, U1IR
794:               
795:                               //Keep track of the hardware ping pong state for endpoints other
796:                               //than EP0, if ping pong buffering is enabled.
797:                               #if (USB_PING_PONG_MODE == USB_PING_PONG__ALL_BUT_EP0) || (USB_PING_PONG_MODE == USB_PING_PONG__FULL_PING_PONG)
798:                               if(USBHALGetLastDirection(USTATcopy) == OUT_FROM_HOST)
000706  BFC816     MOV.B USTATcopy, WREG
000708  604068     AND.B W0, #0x8, W0
00070A  E00400     CP0.B W0
00070C  3A0012     BRA NZ, .L24
799:                               {
800:                                   ep_data_out[endpoint_number].bits.ping_pong_state ^= 1;
00070E  BFC817     MOV.B endpoint_number, WREG
000710  FB8100     ZE W0, W2
000712  FB8080     ZE W0, W1
000714  2084E0     MOV #0x84E, W0
000716  408000     ADD W1, W0, W0
000718  784090     MOV.B [W0], W1
00071A  60C061     AND.B W1, #0x1, W0
00071C  A20400     BTG.B W0, #0
00071E  6040E1     AND.B W0, #0x1, W1
000720  2084E0     MOV #0x84E, W0
000722  410000     ADD W2, W0, W0
000724  60C0E1     AND.B W1, #0x1, W1
000726  784190     MOV.B [W0], W3
000728  B3CFE2     MOV.B #0xFE, W2
00072A  61C102     AND.B W3, W2, W2
00072C  714081     IOR.B W2, W1, W1
00072E  784801     MOV.B W1, [W0]
000730  370011     BRA .L25
801:                               }
802:                               else
803:                               {
804:                                   ep_data_in[endpoint_number].bits.ping_pong_state ^= 1;
000732  BFC817     MOV.B endpoint_number, WREG
000734  FB8100     ZE W0, W2
000736  FB8080     ZE W0, W1
000738  2084C0     MOV #0x84C, W0
00073A  408000     ADD W1, W0, W0
00073C  784090     MOV.B [W0], W1
00073E  60C061     AND.B W1, #0x1, W0
000740  A20400     BTG.B W0, #0
000742  6040E1     AND.B W0, #0x1, W1
000744  2084C0     MOV #0x84C, W0
000746  410000     ADD W2, W0, W0
000748  60C0E1     AND.B W1, #0x1, W1
00074A  784190     MOV.B [W0], W3
00074C  B3CFE2     MOV.B #0xFE, W2
00074E  61C102     AND.B W3, W2, W2
000750  714081     IOR.B W2, W1, W1
000752  784801     MOV.B W1, [W0]
805:                               }
806:                               #endif
807:               
808:                               //USBCtrlEPService only services transactions over EP0.
809:                               //It ignores all other EP transactions.
810:                               if(endpoint_number == 0)
000754  BFC817     MOV.B endpoint_number, WREG
000756  E00400     CP0.B W0
000758  3A0002     BRA NZ, .L26
811:                               {
812:                                   USBCtrlEPService();
00075A  07042A     RCALL _USBCtrlEPService, .LFE19, .LFB20
00075C  370004     BRA .L27
813:                               }
814:                               else
815:                               {
816:                                   USB_TRANSFER_COMPLETE_HANDLER(EVENT_TRANSFER, (uint8_t*)&USTATcopy.Val, 0);
00075E  EB0100     CLR W2
000760  208161     MOV #0x816, W1
000762  200720     MOV #0x72, W0
000764  0709DC     RCALL USER_USB_CALLBACK_EVENT_HANDLER
817:                               }
818:                           }//end if(USBTransactionCompleteIF)
819:                           else
820:                           {
821:                               break;	//USTAT FIFO must be empty.
000770  000000     NOP
822:                           }
823:                       }//end for()
824:                   }//end if(USBTransactionCompleteIE)
825:               
826:                   USBClearUSBInterrupt();
000772  A9C08E     BCLR IFS5, #6
827:               }//end of USBDeviceTasks()
000774  FA8000     ULNK
000776  060000     RETURN
828:               
829:               /*******************************************************************************
830:                 Function:
831:                       void USBEnableEndpoint(uint8_t ep, uint8_t options)
832:                   
833:                 Summary:
834:                   This function will enable the specified endpoint with the specified
835:                   options
836:                 Description:
837:                   This function will enable the specified endpoint with the specified
838:                   options.
839:                   
840:                   Typical Usage:
841:                   <code>
842:                   void USBCBInitEP(void)
843:                   {
844:                       USBEnableEndpoint(MSD_DATA_IN_EP,USB_IN_ENABLED|USB_OUT_ENABLED|USB_HANDSHAKE_ENABLED|USB_DISALLOW_SETUP);
845:                       USBMSDInit();
846:                   }
847:                   </code>
848:                   
849:                   In the above example endpoint number MSD_DATA_IN_EP is being configured
850:                   for both IN and OUT traffic with handshaking enabled. Also since
851:                   MSD_DATA_IN_EP is not endpoint 0 (MSD does not allow this), then we can
852:                   explicitly disable SETUP packets on this endpoint.
853:                 Conditions:
854:                   None
855:                 Input:
856:                   uint8_t ep -       the endpoint to be configured
857:                   uint8_t options -  optional settings for the endpoint. The options should
858:                                   be ORed together to form a single options string. The
859:                                   available optional settings for the endpoint. The
860:                                   options should be ORed together to form a single options
861:                                   string. The available options are the following\:
862:                                   * USB_HANDSHAKE_ENABLED enables USB handshaking (ACK,
863:                                     NAK)
864:                                   * USB_HANDSHAKE_DISABLED disables USB handshaking (ACK,
865:                                     NAK)
866:                                   * USB_OUT_ENABLED enables the out direction
867:                                   * USB_OUT_DISABLED disables the out direction
868:                                   * USB_IN_ENABLED enables the in direction
869:                                   * USB_IN_DISABLED disables the in direction
870:                                   * USB_ALLOW_SETUP enables control transfers
871:                                   * USB_DISALLOW_SETUP disables control transfers
872:                                   * USB_STALL_ENDPOINT STALLs this endpoint
873:                 Return:
874:                   None
875:                 Remarks:
876:                   None                                                                                                          
877:                 *****************************************************************************/
878:               void USBEnableEndpoint(uint8_t ep, uint8_t options)
879:               {
000778  FA0004     LNK #0x4
00077A  984720     MOV.B W0, [W14+2]
00077C  984731     MOV.B W1, [W14+3]
880:                   unsigned char* p;
881:                       
882:                   //Use USBConfigureEndpoint() to set up the pBDTEntryIn/Out[ep] pointer and 
883:                   //starting DTS state in the BDT entry.
884:                   if(options & USB_OUT_ENABLED)
00077E  90403E     MOV.B [W14+3], W0
000780  FB8000     ZE W0, W0
000782  600068     AND W0, #0x8, W0
000784  E00000     CP0 W0
000786  320003     BRA Z, .L31
885:                   {
886:                       USBConfigureEndpoint(ep, OUT_FROM_HOST);
000788  EB4080     CLR.B W1
00078A  90402E     MOV.B [W14+2], W0
00078C  07019B     RCALL _USBConfigureEndpoint, .LFE9, .LFB10
887:                   }
888:                   if(options & USB_IN_ENABLED)
00078E  90403E     MOV.B [W14+3], W0
000790  FB8000     ZE W0, W0
000792  600064     AND W0, #0x4, W0
000794  E00000     CP0 W0
000796  320003     BRA Z, .L32
889:                   {
890:                       USBConfigureEndpoint(ep, IN_TO_HOST);
000798  B3C011     MOV.B #0x1, W1
00079A  90402E     MOV.B [W14+2], W0
00079C  070193     RCALL _USBConfigureEndpoint, .LFE9, .LFB10
891:                   }
892:               
893:                   //Update the relevant UEPx register to actually enable the endpoint with
894:                   //the specified options (ex: handshaking enabled, control transfers allowed,
895:                   //etc.)
896:                   #if defined(__C32__)
897:                       p = (unsigned char*)(&U1EP0+(4*ep));
898:                   #else
899:                       p = (unsigned char*)(&U1EP0+ep);
00079E  2042A1     MOV #0x42A, W1
0007A0  90402E     MOV.B [W14+2], W0
0007A2  FB8000     ZE W0, W0
0007A4  400000     ADD W0, W0, W0
0007A6  408F00     ADD W1, W0, [W14]
900:                   #endif
901:                   *p = options;
0007A8  78001E     MOV [W14], W0
0007AA  9040BE     MOV.B [W14+3], W1
0007AC  784801     MOV.B W1, [W0]
902:               }
0007AE  FA8000     ULNK
0007B0  060000     RETURN
903:               
904:               
905:               /*************************************************************************
906:                 Function:
907:                   USB_HANDLE USBTransferOnePacket(uint8_t ep, uint8_t dir, uint8_t* data, uint8_t len)
908:                   
909:                 Summary:
910:                   Transfers a single packet (one transaction) of data on the USB bus.
911:               
912:                 Description:
913:                   The USBTransferOnePacket() function prepares a USB endpoint
914:                   so that it may send data to the host (an IN transaction), or 
915:                   receive data from the host (an OUT transaction).  The 
916:                   USBTransferOnePacket() function can be used both to receive	and 
917:                   send data to the host.  This function is the primary API function 
918:                   provided by the USB stack firmware for sending or receiving application 
919:                   data over the USB port.  
920:               
921:                   The USBTransferOnePacket() is intended for use with all application 
922:                   endpoints.  It is not used for sending or receiving application data 
923:                   through endpoint 0 by using control transfers.  Separate API 
924:                   functions, such as USBEP0Receive(), USBEP0SendRAMPtr(), and
925:                   USBEP0SendROMPtr() are provided for this purpose.
926:               
927:                   The	USBTransferOnePacket() writes to the Buffer Descriptor Table (BDT)
928:                   entry associated with an endpoint buffer, and sets the UOWN bit, which 
929:                   prepares the USB hardware to allow the transaction to complete.  The 
930:                   application firmware can use the USBHandleBusy() macro to check the 
931:                   status of the transaction, to see if the data has been successfully 
932:                   transmitted yet.
933:               
934:               
935:                   Typical Usage
936:                   <code>
937:                   //make sure that the we are in the configured state
938:                   if(USBGetDeviceState() == CONFIGURED_STATE)
939:                   {
940:                       //make sure that the last transaction isn't busy by checking the handle
941:                       if(!USBHandleBusy(USBInHandle))
942:                       {
943:               	        //Write the new data that we wish to send to the host to the INPacket[] array
944:               	        INPacket[0] = USEFUL_APPLICATION_VALUE1;
945:               	        INPacket[1] = USEFUL_APPLICATION_VALUE2;
946:               	        //INPacket[2] = ... (fill in the rest of the packet data)
947:               	      
948:                           //Send the data contained in the INPacket[] array through endpoint "EP_NUM"
949:                           USBInHandle = USBTransferOnePacket(EP_NUM,IN_TO_HOST,(uint8_t*)&INPacket[0],sizeof(INPacket));
950:                       }
951:                   }
952:                   </code>
953:               
954:                 Conditions:
955:                   Before calling USBTransferOnePacket(), the following should be true.
956:                   1.  The USB stack has already been initialized (USBDeviceInit() was called).
957:                   2.  A transaction is not already pending on the specified endpoint.  This
958:                       is done by checking the previous request using the USBHandleBusy() 
959:                       macro (see the typical usage example).
960:                   3.  The host has already sent a set configuration request and the 
961:                       enumeration process is complete.
962:                       This can be checked by verifying that the USBGetDeviceState() 
963:                       macro returns "CONFIGURED_STATE", prior to calling 
964:                       USBTransferOnePacket().
965:                					
966:                 Input:
967:                   uint8_t ep - The endpoint number that the data will be transmitted or
968:               	          received on
969:                   uint8_t dir - The direction of the transfer
970:                              This value is either OUT_FROM_HOST or IN_TO_HOST
971:                   uint8_t* data - For IN transactions: pointer to the RAM buffer containing
972:                                the data to be sent to the host.  For OUT transactions: pointer
973:                                to the RAM buffer that the received data should get written to.
974:                  uint8_t len - Length of the data needing to be sent (for IN transactions).
975:                             For OUT transactions, the len parameter should normally be set
976:                             to the endpoint size specified in the endpoint descriptor.    
977:               
978:                 Return Values:
979:                   USB_HANDLE - handle to the transfer.  The handle is a pointer to 
980:                                the BDT entry associated with this transaction.  The
981:                                status of the transaction (ex: if it is complete or still
982:                                pending) can be checked using the USBHandleBusy() macro
983:                                and supplying the USB_HANDLE provided by
984:                                USBTransferOnePacket().
985:               
986:                 Remarks:
987:                   If calling the USBTransferOnePacket() function from within the USBCBInitEP()
988:                   callback function, the set configuration is still being processed and the
989:                   USBDeviceState may not be == CONFIGURED_STATE yet.  In this	special case, 
990:                   the USBTransferOnePacket() may still be called, but make sure that the 
991:                   endpoint has been enabled and initialized by the USBEnableEndpoint() 
992:                   function first.  
993:                   
994:                 *************************************************************************/
995:               USB_HANDLE USBTransferOnePacket(uint8_t ep,uint8_t dir,uint8_t* data,uint8_t len)
996:               {
0007B2  FA0008     LNK #0x8
0007B4  984720     MOV.B W0, [W14+2]
0007B6  984731     MOV.B W1, [W14+3]
0007B8  980722     MOV W2, [W14+4]
0007BA  984763     MOV.B W3, [W14+6]
997:                   volatile BDT_ENTRY* handle;
998:               
999:                   //If the direction is IN
1000:                  if(dir != 0)
0007BC  90403E     MOV.B [W14+3], W0
0007BE  E00400     CP0.B W0
0007C0  320007     BRA Z, .L34
1001:                  {
1002:                      //point to the IN BDT of the specified endpoint
1003:                      handle = pBDTEntryIn[ep];
0007C2  90402E     MOV.B [W14+2], W0
0007C4  FB8000     ZE W0, W0
0007C6  400080     ADD W0, W0, W1
0007C8  2080C0     MOV #0x80C, W0
0007CA  408000     ADD W1, W0, W0
0007CC  780F10     MOV [W0], [W14]
0007CE  370006     BRA .L35
1004:                  }
1005:                  else
1006:                  {
1007:                      //else point to the OUT BDT of the specified endpoint
1008:                      handle = pBDTEntryOut[ep];
0007D0  90402E     MOV.B [W14+2], W0
0007D2  FB8000     ZE W0, W0
0007D4  400080     ADD W0, W0, W1
0007D6  208080     MOV #0x808, W0
0007D8  408000     ADD W1, W0, W0
0007DA  780F10     MOV [W0], [W14]
1009:                  }
1010:                  
1011:                  //Error checking code.  Make sure the handle (pBDTEntryIn[ep] or
1012:                  //pBDTEntryOut[ep]) is initialized before using it.
1013:                  if(handle == 0)
0007DC  78001E     MOV [W14], W0
0007DE  E00000     CP0 W0
0007E0  3A0002     BRA NZ, .L36
1014:                  {
1015:                      return 0;
0007E2  EB0000     CLR W0
0007E4  370037     BRA .L37
1016:                  }
1017:              
1018:                  //Toggle the DTS bit if required
1019:                  #if (USB_PING_PONG_MODE == USB_PING_PONG__NO_PING_PONG)
1020:                      handle->STAT.Val ^= _DTSMASK;
1021:                  #elif (USB_PING_PONG_MODE == USB_PING_PONG__EP0_OUT_ONLY)
1022:                      if(ep != 0)
1023:                      {
1024:                          handle->STAT.Val ^= _DTSMASK;
1025:                      }
1026:                  #endif
1027:              
1028:                  //Set the data pointer, data length, and enable the endpoint
1029:                  handle->ADR = ConvertToPhysicalAddress(data);
0007E6  9000AE     MOV [W14+4], W1
0007E8  78001E     MOV [W14], W0
0007EA  980011     MOV W1, [W0+2]
1030:                  handle->CNT = len;
0007EC  78001E     MOV [W14], W0
0007EE  9040EE     MOV.B [W14+6], W1
0007F0  784801     MOV.B W1, [W0]
1031:                  handle->STAT.Val &= _DTSMASK;
0007F2  78001E     MOV [W14], W0
0007F4  904010     MOV.B [W0+1], W0
0007F6  B3C402     MOV.B #0x40, W2
0007F8  604082     AND.B W0, W2, W1
0007FA  78001E     MOV [W14], W0
0007FC  984011     MOV.B W1, [W0+1]
1032:                  handle->STAT.Val |= (_DTSEN & _DTS_CHECKING_ENABLED);
0007FE  78001E     MOV [W14], W0
000800  904010     MOV.B [W0+1], W0
000802  784080     MOV.B W0, W1
000804  A03401     BSET.B W1, #3
000806  78001E     MOV [W14], W0
000808  984011     MOV.B W1, [W0+1]
1033:                  handle->STAT.Val |= _USIE;
00080A  78001E     MOV [W14], W0
00080C  904010     MOV.B [W0+1], W0
00080E  784080     MOV.B W0, W1
000810  A07401     BSET.B W1, #7
000812  78001E     MOV [W14], W0
000814  984011     MOV.B W1, [W0+1]
1034:              
1035:                  //Point to the next buffer for ping pong purposes.
1036:                  if(dir != OUT_FROM_HOST)
000816  90403E     MOV.B [W14+3], W0
000818  E00400     CP0.B W0
00081A  32000E     BRA Z, .L38
1037:                  {
1038:                      //toggle over the to the next buffer for an IN endpoint
1039:                      pBDTEntryIn[ep] = (BDT_ENTRY*)(((uintptr_t)pBDTEntryIn[ep]) ^ USB_NEXT_PING_PONG);
00081C  90402E     MOV.B [W14+2], W0
00081E  FB8000     ZE W0, W0
000820  9040AE     MOV.B [W14+2], W1
000822  FB8081     ZE W1, W1
000824  408101     ADD W1, W1, W2
000826  2080C1     MOV #0x80C, W1
000828  410081     ADD W2, W1, W1
00082A  780091     MOV [W1], W1
00082C  A22001     BTG W1, #2
00082E  400100     ADD W0, W0, W2
000830  2080C0     MOV #0x80C, W0
000832  410000     ADD W2, W0, W0
000834  780801     MOV W1, [W0]
000836  37000D     BRA .L39
1040:                  }
1041:                  else
1042:                  {
1043:                      //toggle over the to the next buffer for an OUT endpoint
1044:                      pBDTEntryOut[ep] = (BDT_ENTRY*)(((uintptr_t)pBDTEntryOut[ep]) ^ USB_NEXT_PING_PONG);
000838  90402E     MOV.B [W14+2], W0
00083A  FB8000     ZE W0, W0
00083C  9040AE     MOV.B [W14+2], W1
00083E  FB8081     ZE W1, W1
000840  408101     ADD W1, W1, W2
000842  208081     MOV #0x808, W1
000844  410081     ADD W2, W1, W1
000846  780091     MOV [W1], W1
000848  A22001     BTG W1, #2
00084A  400100     ADD W0, W0, W2
00084C  208080     MOV #0x808, W0
00084E  410000     ADD W2, W0, W0
000850  780801     MOV W1, [W0]
1045:                  }
1046:                  return (USB_HANDLE)handle;
000852  78001E     MOV [W14], W0
1047:              }
000854  FA8000     ULNK
000856  060000     RETURN
1048:              
1049:              
1050:              /********************************************************************
1051:                  Function:
1052:                      void USBStallEndpoint(uint8_t ep, uint8_t dir)
1053:                      
1054:                  Summary:
1055:                       Configures the specified endpoint to send STALL to the host, the next
1056:                       time the host tries to access the endpoint.
1057:                  
1058:                  PreCondition:
1059:                      None
1060:                      
1061:                  Parameters:
1062:                      uint8_t ep - The endpoint number that should be configured to send STALL.
1063:                      uint8_t dir - The direction of the endpoint to STALL, either
1064:                                 IN_TO_HOST or OUT_FROM_HOST.
1065:                      
1066:                  Return Values:
1067:                      None
1068:                      
1069:                  Remarks:
1070:                      None
1071:              
1072:               *******************************************************************/
1073:              void USBStallEndpoint(uint8_t ep, uint8_t dir)
1074:              {
000858  FA0004     LNK #0x4
00085A  984720     MOV.B W0, [W14+2]
00085C  984731     MOV.B W1, [W14+3]
1075:                  BDT_ENTRY *p;
1076:              
1077:                  if(ep == 0)
00085E  90402E     MOV.B [W14+2], W0
000860  E00400     CP0.B W0
000862  3A0017     BRA NZ, .L41
1078:                  {
1079:                      //For control endpoints (ex: EP0), we need to STALL both IN and OUT
1080:                      //endpoints.  EP0 OUT must also be prepared to receive the next SETUP 
1081:                      //packet that will arrive.
1082:                      pBDTEntryEP0OutNext->CNT = USB_EP0_BUFF_SIZE;
000864  804030     MOV pBDTEntryEP0OutNext, W0
000866  B3C081     MOV.B #0x8, W1
000868  784801     MOV.B W1, [W0]
1083:                      pBDTEntryEP0OutNext->ADR = ConvertToPhysicalAddress(&SetupPkt);
00086A  804030     MOV pBDTEntryEP0OutNext, W0
00086C  208501     MOV #0x850, W1
00086E  980011     MOV W1, [W0+2]
1084:                      pBDTEntryEP0OutNext->STAT.Val = _DAT0|(_DTSEN & _DTS_CHECKING_ENABLED)|_BSTALL;
000870  804030     MOV pBDTEntryEP0OutNext, W0
000872  B3C0C1     MOV.B #0xC, W1
000874  984011     MOV.B W1, [W0+1]
1085:                      pBDTEntryEP0OutNext->STAT.Val |= _USIE;
000876  804030     MOV pBDTEntryEP0OutNext, W0
000878  804031     MOV pBDTEntryEP0OutNext, W1
00087A  904091     MOV.B [W1+1], W1
00087C  A07401     BSET.B W1, #7
00087E  984011     MOV.B W1, [W0+1]
1086:                      pBDTEntryIn[0]->STAT.Val = _BSTALL; 
000880  804060     MOV pBDTEntryIn, W0
000882  B3C041     MOV.B #0x4, W1
000884  984011     MOV.B W1, [W0+1]
1087:                      pBDTEntryIn[0]->STAT.Val |= _USIE;
000886  804060     MOV pBDTEntryIn, W0
000888  804061     MOV pBDTEntryIn, W1
00088A  904091     MOV.B [W1+1], W1
00088C  A07401     BSET.B W1, #7
00088E  984011     MOV.B W1, [W0+1]
000890  37002E     BRA .L40
1088:                             
1089:                  }
1090:                  else
1091:                  {
1092:                      p = (BDT_ENTRY*)(&BDT[EP(ep,dir,0)]);
000892  90402E     MOV.B [W14+2], W0
000894  FB8000     ZE W0, W0
000896  400000     ADD W0, W0, W0
000898  780080     MOV W0, W1
00089A  90403E     MOV.B [W14+3], W0
00089C  FB8000     ZE W0, W0
00089E  408000     ADD W1, W0, W0
0008A0  DD0043     SL W0, #3, W0
0008A2  780080     MOV W0, W1
0008A4  20A000     MOV #0xA00, W0
0008A6  408F00     ADD W1, W0, [W14]
1093:                      p->STAT.Val |= _BSTALL;
0008A8  78001E     MOV [W14], W0
0008AA  904010     MOV.B [W0+1], W0
0008AC  784080     MOV.B W0, W1
0008AE  A02401     BSET.B W1, #2
0008B0  78001E     MOV [W14], W0
0008B2  984011     MOV.B W1, [W0+1]
1094:                      p->STAT.Val |= _USIE;
0008B4  78001E     MOV [W14], W0
0008B6  904010     MOV.B [W0+1], W0
0008B8  784080     MOV.B W0, W1
0008BA  A07401     BSET.B W1, #7
0008BC  78001E     MOV [W14], W0
0008BE  984011     MOV.B W1, [W0+1]
1095:                  
1096:                      //If the device is in FULL or ALL_BUT_EP0 ping pong modes
1097:                      //then stall that entry as well
1098:                      #if (USB_PING_PONG_MODE == USB_PING_PONG__FULL_PING_PONG) || (USB_PING_PONG_MODE == USB_PING_PONG__ALL_BUT_EP0)
1099:                      p = (BDT_ENTRY*)(&BDT[EP(ep,dir,1)]);
0008C0  90402E     MOV.B [W14+2], W0
0008C2  FB8000     ZE W0, W0
0008C4  400000     ADD W0, W0, W0
0008C6  780080     MOV W0, W1
0008C8  90403E     MOV.B [W14+3], W0
0008CA  FB8000     ZE W0, W0
0008CC  408000     ADD W1, W0, W0
0008CE  DD0043     SL W0, #3, W0
0008D0  4000E4     ADD W0, #0x4, W1
0008D2  20A000     MOV #0xA00, W0
0008D4  408F00     ADD W1, W0, [W14]
1100:                      p->STAT.Val |= _BSTALL;
0008D6  78001E     MOV [W14], W0
0008D8  904010     MOV.B [W0+1], W0
0008DA  784080     MOV.B W0, W1
0008DC  A02401     BSET.B W1, #2
0008DE  78001E     MOV [W14], W0
0008E0  984011     MOV.B W1, [W0+1]
1101:                      p->STAT.Val |= _USIE;
0008E2  78001E     MOV [W14], W0
0008E4  904010     MOV.B [W0+1], W0
0008E6  784080     MOV.B W0, W1
0008E8  A07401     BSET.B W1, #7
0008EA  78001E     MOV [W14], W0
0008EC  984011     MOV.B W1, [W0+1]
1102:                      #endif
1103:                  }
1104:              }
0008EE  FA8000     ULNK
0008F0  060000     RETURN
1105:              
1106:              /**************************************************************************
1107:                  Function:
1108:                      void USBCancelIO(uint8_t endpoint)
1109:                  
1110:                  Description:
1111:                      This function cancels the transfers pending on the specified endpoint.
1112:                      This function can only be used after a SETUP packet is received and 
1113:                      before that setup packet is handled.  This is the time period in which
1114:                      the EVENT_EP0_REQUEST is thrown, before the event handler function
1115:                      returns to the stack.
1116:              
1117:                  Precondition:
1118:                
1119:                  Parameters:
1120:                      uint8_t endpoint - the endpoint number you wish to cancel the transfers for
1121:                   
1122:                  Return Values:
1123:                      None
1124:                      
1125:                  Remarks:
1126:                      None
1127:                                                                        
1128:                **************************************************************************/
1129:              void USBCancelIO(uint8_t endpoint)
1130:              {
0008F2  FA0002     LNK #0x2
0008F4  784F00     MOV.B W0, [W14]
1131:                  if(USBPacketDisable == 1)
0008F6  8020A1     MOV U1CON, W1
0008F8  200200     MOV #0x20, W0
0008FA  608000     AND W1, W0, W0
0008FC  E00000     CP0 W0
0008FE  320051     BRA Z, .L43
1132:                  {
1133:                  	//The PKTDIS bit is currently set right now.  It is therefore "safe"
1134:                  	//to mess with the BDT right now.
1135:                  	pBDTEntryIn[endpoint]->Val &= _DTSMASK;	//Makes UOWN = 0 (_UCPU mode).  Deactivates endpoint.  Only sends NAKs.
000900  FB801E     ZE [W14], W0
000902  400080     ADD W0, W0, W1
000904  2080C0     MOV #0x80C, W0
000906  408000     ADD W1, W0, W0
000908  780210     MOV [W0], W4
00090A  FB801E     ZE [W14], W0
00090C  400080     ADD W0, W0, W1
00090E  2080C0     MOV #0x80C, W0
000910  408000     ADD W1, W0, W0
000912  780010     MOV [W0], W0
000914  BE0110     MOV.D [W0], W2
000916  200400     MOV #0x40, W0
000918  200001     MOV #0x0, W1
00091A  780282     MOV W2, W5
00091C  780103     MOV W3, W2
00091E  780180     MOV W0, W3
000920  780001     MOV W1, W0
000922  628283     AND W5, W3, W5
000924  610000     AND W2, W0, W0
000926  EB0080     CLR W1
000928  DD00C0     SL W0, #0, W1
00092A  200000     MOV #0x0, W0
00092C  BE0100     MOV.D W0, W2
00092E  B82861     MUL.UU W5, #1, W0
000930  710100     IOR W2, W0, W2
000932  718181     IOR W3, W1, W3
000934  BE8A02     MOV.D W2, [W4]
1136:                  	pBDTEntryIn[endpoint]->Val ^= _DTSMASK;	//Toggle the DTS bit.  This packet didn't get sent yet, and the next call to USBTransferOnePacket() will re-toggle the DTS bit back to the original (correct) value.
000936  FB801E     ZE [W14], W0
000938  400080     ADD W0, W0, W1
00093A  2080C0     MOV #0x80C, W0
00093C  408000     ADD W1, W0, W0
00093E  780210     MOV [W0], W4
000940  FB801E     ZE [W14], W0
000942  400080     ADD W0, W0, W1
000944  2080C0     MOV #0x80C, W0
000946  408000     ADD W1, W0, W0
000948  780010     MOV [W0], W0
00094A  BE0110     MOV.D [W0], W2
00094C  200400     MOV #0x40, W0
00094E  200001     MOV #0x0, W1
000950  690000     XOR W2, W0, W0
000952  698081     XOR W3, W1, W1
000954  BE8A00     MOV.D W0, [W4]
1137:                  	
1138:                  	//Need to do additional handling if ping-pong buffering is being used
1139:                      #if ((USB_PING_PONG_MODE == USB_PING_PONG__FULL_PING_PONG) || (USB_PING_PONG_MODE == USB_PING_PONG__ALL_BUT_EP0))
1140:                      //Point to the next buffer for ping pong purposes.  UOWN getting cleared
1141:                      //(either due to SIE clearing it after a transaction, or the firmware
1142:                      //clearing it) makes hardware ping pong pointer advance.
1143:                      pBDTEntryIn[endpoint] = (BDT_ENTRY*)(((uintptr_t)pBDTEntryIn[endpoint]) ^ USB_NEXT_PING_PONG);
000956  FB801E     ZE [W14], W0
000958  FB809E     ZE [W14], W1
00095A  408101     ADD W1, W1, W2
00095C  2080C1     MOV #0x80C, W1
00095E  410081     ADD W2, W1, W1
000960  780091     MOV [W1], W1
000962  A22001     BTG W1, #2
000964  400100     ADD W0, W0, W2
000966  2080C0     MOV #0x80C, W0
000968  410000     ADD W2, W0, W0
00096A  780801     MOV W1, [W0]
1144:                      
1145:                  	pBDTEntryIn[endpoint]->STAT.Val &= _DTSMASK;
00096C  FB801E     ZE [W14], W0
00096E  400080     ADD W0, W0, W1
000970  2080C0     MOV #0x80C, W0
000972  408000     ADD W1, W0, W0
000974  780090     MOV [W0], W1
000976  FB801E     ZE [W14], W0
000978  400100     ADD W0, W0, W2
00097A  2080C0     MOV #0x80C, W0
00097C  410000     ADD W2, W0, W0
00097E  780010     MOV [W0], W0
000980  904010     MOV.B [W0+1], W0
000982  B24400     AND.B #0x40, W0
000984  984090     MOV.B W0, [W1+1]
1146:                  	pBDTEntryIn[endpoint]->STAT.Val ^= _DTSMASK;
000986  FB801E     ZE [W14], W0
000988  400080     ADD W0, W0, W1
00098A  2080C0     MOV #0x80C, W0
00098C  408000     ADD W1, W0, W0
00098E  780090     MOV [W0], W1
000990  FB801E     ZE [W14], W0
000992  400100     ADD W0, W0, W2
000994  2080C0     MOV #0x80C, W0
000996  410000     ADD W2, W0, W0
000998  780010     MOV [W0], W0
00099A  904110     MOV.B [W0+1], W2
00099C  B3C400     MOV.B #0x40, W0
00099E  694000     XOR.B W2, W0, W0
0009A0  984090     MOV.B W0, [W1+1]
1147:                      #endif
1148:                  }
1149:              }
0009A2  FA8000     ULNK
0009A4  060000     RETURN
1150:              
1151:              /**************************************************************************
1152:                  Function:
1153:                      void USBDeviceDetach(void)
1154:                 
1155:                  Summary:
1156:                      This function configures the USB module to "soft detach" itself from
1157:                      the USB host.
1158:                      
1159:                  Description:
1160:                      This function configures the USB module to perform a "soft detach"
1161:                      operation, by disabling the D+ (or D-) ~1.5k pull up resistor, which
1162:                      lets the host know the device is present and attached.  This will make
1163:                      the host think that the device has been unplugged.  This is potentially
1164:                      useful, as it allows the USB device to force the host to re-enumerate
1165:                      the device (on the firmware has re-enabled the USB module/pull up, by
1166:                      calling USBDeviceAttach(), to "soft re-attach" to the host).
1167:                      
1168:                  Precondition:
1169:                      Should only be called when USB_INTERRUPT is defined.  See remarks
1170:                      section if USB_POLLING mode option is being used (usb_config.h option).
1171:              
1172:                      Additionally, this function should only be called from the main() loop 
1173:                      context.  Do not call this function from within an interrupt handler, as 
1174:                      this function may modify global interrupt enable bits and settings.
1175:                      
1176:                  Parameters:
1177:                      None
1178:                   
1179:                  Return Values:
1180:                      None
1181:                      
1182:                  Remarks:
1183:                      If the application firmware calls USBDeviceDetach(), it is strongly
1184:                      recommended that the firmware wait at least >= 80ms before calling
1185:                      USBDeviceAttach().  If the firmware performs a soft detach, and then
1186:                      re-attaches too soon (ex: after a few micro seconds for instance), some
1187:                      hosts may interpret this as an unexpected "glitch" rather than as a
1188:                      physical removal/re-attachment of the USB device.  In this case the host
1189:                      may simply ignore the event without re-enumerating the device.  To 
1190:                      ensure that the host properly detects and processes the device soft
1191:                      detach/re-attach, it is recommended to make sure the device remains 
1192:                      detached long enough to mimic a real human controlled USB 
1193:                      unplug/re-attach event (ex: after calling USBDeviceDetach(), do not
1194:                      call USBDeviceAttach() for at least 80+ms, preferably longer.
1195:                      
1196:                      Neither the USBDeviceDetach() or USBDeviceAttach() functions are blocking
1197:                      or take long to execute.  It is the application firmwares 
1198:                      responsibility for adding the 80+ms delay, when using these API 
1199:                      functions.
1200:                      
1201:                      Note: The Windows plug and play event handler processing is fairly 
1202:                      slow, especially in certain versions of Windows, and for certain USB
1203:                      device classes.  It has been observed that some device classes need to
1204:                      provide even more USB detach dwell interval (before calling 
1205:                      USBDeviceAttach()), in order to work correctly after re-enumeration.
1206:                      If the USB device is a CDC class device, it is recommended to wait
1207:                      at least 1.5 seconds or longer, before soft re-attaching to the host,
1208:                      to provide the plug and play event handler enough time to finish 
1209:                      processing the removal event, before the re-attach occurs.
1210:                      
1211:                      If the application is using the USB_POLLING mode option, then the 
1212:                      USBDeviceDetach() and USBDeviceAttach() functions are not available.  
1213:                      In this mode, the USB stack relies on the "#define USE_USB_BUS_SENSE_IO" 
1214:                      and "#define USB_BUS_SENSE" options in the 
1215:                      HardwareProfile – [platform name].h file. 
1216:              
1217:                      When using the USB_POLLING mode option, and the 
1218:                      "#define USE_USB_BUS_SENSE_IO" definition has been commented out, then 
1219:                      the USB stack assumes that it should always enable the USB module at 
1220:                      pretty much all times.  Basically, anytime the application firmware 
1221:                      calls USBDeviceTasks(), the firmware will automatically enable the USB 
1222:                      module.  This mode would typically be selected if the application was 
1223:                      designed to be a purely bus powered device.  In this case, the 
1224:                      application is powered from the +5V VBUS supply from the USB port, so 
1225:                      it is correct and sensible in this type of application to power up and 
1226:                      turn on the USB module, at anytime that the microcontroller is 
1227:                      powered (which implies the USB cable is attached and the host is also 
1228:                      powered).
1229:              
1230:                      In a self powered application, the USB stack is designed with the 
1231:                      intention that the user will enable the "#define USE_USB_BUS_SENSE_IO" 
1232:                      option in the HardwareProfile – [platform name].h file.  When this 
1233:                      option is defined, then the USBDeviceTasks() function will automatically 
1234:                      check the I/O pin port value of the designated pin (based on the 
1235:                      #define USB_BUS_SENSE option in the HardwareProfile – [platform name].h 
1236:                      file), every time the application calls USBDeviceTasks().  If the 
1237:                      USBDeviceTasks() function is executed and finds that the pin defined by 
1238:                      the #define USB_BUS_SENSE is in a logic low state, then it will 
1239:                      automatically disable the USB module and tri-state the D+ and D- pins.  
1240:                      If however the USBDeviceTasks() function is executed and finds the pin 
1241:                      defined by the #define USB_BUS_SENSE is in a logic high state, then it 
1242:                      will automatically enable the USB module, if it has not already been 
1243:                      enabled.        
1244:                                                                        
1245:                **************************************************************************/
1246:              #if defined(USB_INTERRUPT)
1247:              void USBDeviceDetach(void)
1248:              {
0009A6  FA0000     LNK #0x0
1249:                  //If the interrupt option is selected then the customer is required
1250:                  //  to notify the stack when the device is attached or removed from the
1251:                  //  bus by calling the USBDeviceAttach() and USBDeviceDetach() functions.
1252:              #ifdef USB_SUPPORT_OTG
1253:                  if (USB_BUS_SENSE != 1)
1254:              #endif
1255:                  {
1256:                       // Disable module & detach from bus
1257:                       U1CON = 0;             
0009A8  EF2414     CLR U1CON
1258:              
1259:                       // Mask all USB interrupts              
1260:                       U1IE = 0;          
0009AA  EF240C     CLR U1IE
1261:              
1262:                       //Move to the detached state                  
1263:                       USBDeviceState = DETACHED_STATE;
0009AC  EF2800     CLR USBDeviceState
1264:              
1265:                       #ifdef  USB_SUPPORT_OTG    
1266:                           //Disable D+ Pull-up
1267:                           U1OTGCONbits.DPPULUP = 0;
1268:              
1269:                           //Disable HNP
1270:                           USBOTGDisableHnp();
1271:              
1272:                           //Deactivate HNP
1273:                           USBOTGDeactivateHnp();
1274:                           
1275:                           //If ID Pin Changed State
1276:                           if (USBIDIF && USBIDIE)
1277:                           {  
1278:                               //Re-detect & Initialize
1279:                                USBOTGInitialize();
1280:              
1281:                                //Clear ID Interrupt Flag
1282:                                USBClearInterruptFlag(USBIDIFReg,USBIDIFBitNum);
1283:                           }
1284:                       #endif
1285:              
1286:                       #if defined __C30__ || defined __XC16__
1287:                           //USBClearInterruptFlag(U1OTGIR, 3); 
1288:                       #endif
1289:                          //return so that we don't go through the rest of 
1290:                          //the state machine
1291:                        return;
1292:                  }
1293:              
1294:              #ifdef USB_SUPPORT_OTG
1295:                  //If Session Is Started Then
1296:                 else
1297:                 {
1298:                      //If SRP Is Ready
1299:                      if (USBOTGSRPIsReady())
1300:                      {   
1301:                          //Clear SRPReady
1302:                          USBOTGClearSRPReady();
1303:              
1304:                          //Clear SRP Timeout Flag
1305:                          USBOTGClearSRPTimeOutFlag();
1306:              
1307:                          //Indicate Session Started
1308:                          UART2PrintString( "\r\n***** USB OTG B Event - Session Started  *****\r\n" );
1309:                      }
1310:                  }
1311:              #endif
1312:              }
0009AE  FA8000     ULNK
0009B0  060000     RETURN
1313:              #endif  //#if defined(USB_INTERRUPT)
1314:              /**************************************************************************
1315:                  Function:
1316:                      void USBDeviceAttach(void)
1317:                  
1318:                  Summary:
1319:                      Checks if VBUS is present, and that the USB module is not already 
1320:                      initialized, and if so, enables the USB module so as to signal device 
1321:                      attachment to the USB host.   
1322:              
1323:                  Description:
1324:                      This function indicates to the USB host that the USB device has been
1325:                      attached to the bus.  This function needs to be called in order for the
1326:                      device to start to enumerate on the bus.
1327:                              
1328:                  Precondition:
1329:                      Should only be called when USB_INTERRUPT is defined.  Also, should only 
1330:                      be called from the main() loop context.  Do not call USBDeviceAttach()
1331:                      from within an interrupt handler, as the USBDeviceAttach() function
1332:                      may modify global interrupt enable bits and settings.
1333:              
1334:                      For normal USB devices:
1335:                      Make sure that if the module was previously on, that it has been turned off 
1336:                      for a long time (ex: 100ms+) before calling this function to re-enable the module.
1337:                      If the device turns off the D+ (for full speed) or D- (for low speed) ~1.5k ohm
1338:                      pull up resistor, and then turns it back on very quickly, common hosts will sometimes 
1339:                      reject this event, since no human could ever unplug and re-attach a USB device in a 
1340:                      microseconds (or nanoseconds) timescale.  The host could simply treat this as some kind 
1341:                      of glitch and ignore the event altogether.  
1342:                  Parameters:
1343:                      None
1344:                   
1345:                  Return Values:
1346:                      None       
1347:                  
1348:                  Remarks: 
1349:              		See also the USBDeviceDetach() API function documentation.                                                 
1350:              ****************************************************************************/
1351:              #if defined(USB_INTERRUPT)
1352:              void USBDeviceAttach(void)
1353:              {
0009B2  FA0000     LNK #0x0
1354:                  //if we are in the detached state
1355:                  if(USBDeviceState == DETACHED_STATE)
0009B4  804000     MOV USBDeviceState, W0
0009B6  E00000     CP0 W0
0009B8  3A0014     BRA NZ, .L46
1356:                  {
1357:                      if(USB_BUS_SENSE == 1)
1358:                      {
1359:                  	    //Initialize registers to known states.
1360:                          U1CON = 0;          
0009BA  EF2414     CLR U1CON
1361:                  
1362:                          // Mask all USB interrupts
1363:                          U1IE = 0;                                
0009BC  EF240C     CLR U1IE
1364:                  
1365:                          //Configure things like: pull ups, full/low-speed mode, 
1366:                          //set the ping pong mode, and set internal transceiver
1367:                          SetConfigurationOptions();
0009BE  200020     MOV #0x2, W0
0009C0  882130     MOV W0, U1CNFG1
0009C2  EF2428     CLR U1CNFG2
0009C4  A94406     BCLR U1OTGCON, #2
0009C6  2009F0     MOV #0x9F, W0
0009C8  882080     MOV W0, U1EIE
0009CA  2009F0     MOV #0x9F, W0
0009CC  882060     MOV W0, U1IE
0009CE  A8C402     BSET U1OTGIE, #6
1368:                  
1369:                          USBEnableInterrupts();  //Modifies global interrupt settings
0009D0  A8C09E     BSET IEC5, #6
1370:                  
1371:                          // Enable module & attach to bus
1372:                          while(!U1CONbits.USBEN){U1CONbits.USBEN = 1;}
0009D2  370001     BRA .L48
0009D4  A80414     BSET U1CON, #0
0009D6  8020A0     MOV U1CON, W0
0009D8  600061     AND W0, #0x1, W0
0009DA  E00000     CP0 W0
0009DC  32FFFB     BRA Z, .L49
1373:                  
1374:                          //moved to the attached state
1375:                          USBDeviceState = ATTACHED_STATE;
0009DE  200010     MOV #0x1, W0
0009E0  884000     MOV W0, USBDeviceState
1376:                  
1377:                          #ifdef  USB_SUPPORT_OTG
1378:                              U1OTGCON = USB_OTG_DPLUS_ENABLE | USB_OTG_ENABLE;  
1379:                          #endif
1380:                      }
1381:                  }
1382:              }
0009E2  FA8000     ULNK
0009E4  060000     RETURN
1383:              #endif  //#if defined(USB_INTERRUPT)
1384:              
1385:              
1386:              /*******************************************************************************
1387:                Function: void USBCtrlEPAllowStatusStage(void);
1388:              
1389:                Summary: This function prepares the proper endpoint 0 IN or endpoint 0 OUT
1390:                          (based on the controlTransferState) to allow the status stage packet
1391:                          of a control transfer to complete.  This function gets used
1392:                          internally by the USB stack itself, but it may also be called from
1393:                          the application firmware, IF the application firmware called
1394:                          the USBDeferStatusStage() function during the initial processing
1395:                          of the control transfer request.  In this case, the application
1396:                          must call the USBCtrlEPAllowStatusStage() once, after it has fully
1397:                          completed processing and handling the data stage portion of the
1398:                          request.
1399:              
1400:                          If the application firmware has no need for delaying control
1401:                          transfers, and therefore never calls USBDeferStatusStage(), then the
1402:                          application firmware should not call USBCtrlEPAllowStatusStage().
1403:              
1404:                Description:
1405:              
1406:                Conditions:
1407:                  None
1408:              
1409:                Input:
1410:              
1411:                Return:
1412:              
1413:                Remarks:
1414:                  None
1415:                *****************************************************************************/
1416:              void USBCtrlEPAllowStatusStage(void)
1417:              {
0009E6  FA0000     LNK #0x0
1418:                  //Check and set two flags, prior to actually modifying any BDT entries.
1419:                  //This double checking is necessary to make certain that 
1420:                  //USBCtrlEPAllowStatusStage() can be called twice simultaneously (ex: once 
1421:                  //in main loop context, while simultaneously getting an interrupt which 
1422:                  //tries to call USBCtrlEPAllowStatusStage() again, at the same time).
1423:                  if(USBStatusStageEnabledFlag1 == false)
0009E8  BFC81B     MOV.B USBStatusStageEnabledFlag1, WREG
0009EA  A20400     BTG.B W0, #0
0009EC  E00400     CP0.B W0
0009EE  320034     BRA Z, .L50
1424:                  {
1425:                      USBStatusStageEnabledFlag1 = true;
0009F0  B3C010     MOV.B #0x1, W0
0009F2  B7E81B     MOV.B WREG, USBStatusStageEnabledFlag1
1426:                      if(USBStatusStageEnabledFlag2 == false)
0009F4  BFC81C     MOV.B USBStatusStageEnabledFlag2, WREG
0009F6  A20400     BTG.B W0, #0
0009F8  E00400     CP0.B W0
0009FA  32002E     BRA Z, .L50
1427:                      {
1428:                          USBStatusStageEnabledFlag2 = true;
0009FC  B3C010     MOV.B #0x1, W0
0009FE  B7E81C     MOV.B WREG, USBStatusStageEnabledFlag2
1429:                      
1430:                          //Determine which endpoints (EP0 IN or OUT needs arming for the status
1431:                          //stage), based on the type of control transfer currently pending.
1432:                          if(controlTransferState == CTRL_TRF_RX)
000A00  BFC811     MOV.B controlTransferState, WREG
000A02  504FE2     SUB.B W0, #0x2, [W15]
000A04  3A000C     BRA NZ, .L52
1433:                          {
1434:                              pBDTEntryIn[0]->CNT = 0;
000A06  804060     MOV pBDTEntryIn, W0
000A08  EB4080     CLR.B W1
000A0A  784801     MOV.B W1, [W0]
1435:                              pBDTEntryIn[0]->STAT.Val = _DAT1|(_DTSEN & _DTS_CHECKING_ENABLED);        
000A0C  804060     MOV pBDTEntryIn, W0
000A0E  B3C481     MOV.B #0x48, W1
000A10  984011     MOV.B W1, [W0+1]
1436:                              pBDTEntryIn[0]->STAT.Val |= _USIE;
000A12  804060     MOV pBDTEntryIn, W0
000A14  804061     MOV pBDTEntryIn, W1
000A16  904091     MOV.B [W1+1], W1
000A18  A07401     BSET.B W1, #7
000A1A  984011     MOV.B W1, [W0+1]
000A1C  37001D     BRA .L50
1437:                          }
1438:                          else if(controlTransferState == CTRL_TRF_TX)
000A1E  BFC811     MOV.B controlTransferState, WREG
000A20  504FE1     SUB.B W0, #0x1, [W15]
000A22  3A001A     BRA NZ, .L50
1439:                          {
1440:                              BothEP0OutUOWNsSet = false;	//Indicator flag used in USBCtrlTrfOutHandler()
000A24  EF6818     CLR.B BothEP0OutUOWNsSet
1441:              
1442:                              //This buffer (when ping pong buffering is enabled on EP0 OUT) receives the
1443:                              //next SETUP packet.
1444:                              #if((USB_PING_PONG_MODE == USB_PING_PONG__EP0_OUT_ONLY) || (USB_PING_PONG_MODE == USB_PING_PONG__FULL_PING_PONG))
1445:                                  pBDTEntryEP0OutCurrent->CNT = USB_EP0_BUFF_SIZE;
000A26  804020     MOV pBDTEntryEP0OutCurrent, W0
000A28  B3C081     MOV.B #0x8, W1
000A2A  784801     MOV.B W1, [W0]
1446:                                  pBDTEntryEP0OutCurrent->ADR = ConvertToPhysicalAddress(&SetupPkt);
000A2C  804020     MOV pBDTEntryEP0OutCurrent, W0
000A2E  208501     MOV #0x850, W1
000A30  980011     MOV W1, [W0+2]
1447:                                  pBDTEntryEP0OutCurrent->STAT.Val = _BSTALL; //Prepare endpoint to accept a SETUP transaction
000A32  804020     MOV pBDTEntryEP0OutCurrent, W0
000A34  B3C041     MOV.B #0x4, W1
000A36  984011     MOV.B W1, [W0+1]
1448:                                  pBDTEntryEP0OutCurrent->STAT.Val |= _USIE;
000A38  804020     MOV pBDTEntryEP0OutCurrent, W0
000A3A  804021     MOV pBDTEntryEP0OutCurrent, W1
000A3C  904091     MOV.B [W1+1], W1
000A3E  A07401     BSET.B W1, #7
000A40  984011     MOV.B W1, [W0+1]
1449:                                  BothEP0OutUOWNsSet = true;	//Indicator flag used in USBCtrlTrfOutHandler()
000A42  B3C010     MOV.B #0x1, W0
000A44  B7E818     MOV.B WREG, BothEP0OutUOWNsSet
1450:                              #endif
1451:              
1452:                              //This EP0 OUT buffer receives the 0-byte OUT status stage packet.
1453:                              pBDTEntryEP0OutNext->CNT = USB_EP0_BUFF_SIZE;
000A46  804030     MOV pBDTEntryEP0OutNext, W0
000A48  B3C081     MOV.B #0x8, W1
000A4A  784801     MOV.B W1, [W0]
1454:                              pBDTEntryEP0OutNext->ADR = ConvertToPhysicalAddress(&SetupPkt);
000A4C  804030     MOV pBDTEntryEP0OutNext, W0
000A4E  208501     MOV #0x850, W1
000A50  980011     MOV W1, [W0+2]
1455:                              pBDTEntryEP0OutNext->STAT.Val = _USIE;           // Note: DTSEN is 0
000A52  804030     MOV pBDTEntryEP0OutNext, W0
000A54  B3C801     MOV.B #0x80, W1
000A56  984011     MOV.B W1, [W0+1]
1456:                          }
1457:                      }    
1458:                  }
1459:              }   
000A58  FA8000     ULNK
000A5A  060000     RETURN
1460:              
1461:              
1462:              /*******************************************************************************
1463:                Function: void USBCtrlEPAllowDataStage(void);
1464:                  
1465:                Summary: This function allows the data stage of either a host-to-device or
1466:                          device-to-host control transfer (with data stage) to complete.
1467:                          This function is meant to be used in conjunction with either the
1468:                          USBDeferOUTDataStage() or USBDeferINDataStage().  If the firmware
1469:                          does not call either USBDeferOUTDataStage() or USBDeferINDataStage(),
1470:                          then the firmware does not need to manually call 
1471:                          USBCtrlEPAllowDataStage(), as the USB stack will call this function
1472:                          instead.
1473:                   
1474:                Description:
1475:                  
1476:                Conditions: A control transfer (with data stage) should already be pending, 
1477:                              if the firmware calls this function.  Additionally, the firmware
1478:                              should have called either USBDeferOUTDataStage() or 
1479:                              USBDeferINDataStage() at the start of the control transfer, if
1480:                              the firmware will be calling this function manually.
1481:              
1482:                Input:
1483:              
1484:                Return:
1485:              
1486:                Remarks: 
1487:                *****************************************************************************/
1488:              void USBCtrlEPAllowDataStage(void)
1489:              {
000A5C  FA0000     LNK #0x0
1490:                  USBDeferINDataStagePackets = false;
000A5E  EF681D     CLR.B USBDeferINDataStagePackets
1491:                  USBDeferOUTDataStagePackets = false;
000A60  EF681E     CLR.B USBDeferOUTDataStagePackets
1492:              
1493:                  if(controlTransferState == CTRL_TRF_RX) //(<setup><out><out>...<out><in>)
000A62  BFC811     MOV.B controlTransferState, WREG
000A64  504FE2     SUB.B W0, #0x2, [W15]
000A66  3A000F     BRA NZ, .L54
1494:                  {
1495:                      //Prepare EP0 OUT to receive the first OUT data packet in the data stage sequence.
1496:                      pBDTEntryEP0OutNext->CNT = USB_EP0_BUFF_SIZE;
000A68  804030     MOV pBDTEntryEP0OutNext, W0
000A6A  B3C081     MOV.B #0x8, W1
000A6C  784801     MOV.B W1, [W0]
1497:                      pBDTEntryEP0OutNext->ADR = ConvertToPhysicalAddress(&CtrlTrfData);
000A6E  804030     MOV pBDTEntryEP0OutNext, W0
000A70  208581     MOV #0x858, W1
000A72  980011     MOV W1, [W0+2]
1498:                      pBDTEntryEP0OutNext->STAT.Val = _DAT1|(_DTSEN & _DTS_CHECKING_ENABLED);
000A74  804030     MOV pBDTEntryEP0OutNext, W0
000A76  B3C481     MOV.B #0x48, W1
000A78  984011     MOV.B W1, [W0+1]
1499:                      pBDTEntryEP0OutNext->STAT.Val |= _USIE;
000A7A  804030     MOV pBDTEntryEP0OutNext, W0
000A7C  804031     MOV pBDTEntryEP0OutNext, W1
000A7E  904091     MOV.B [W1+1], W1
000A80  A07401     BSET.B W1, #7
000A82  984011     MOV.B W1, [W0+1]
000A84  37001D     BRA .L53
1500:                  }   
1501:                  else    //else must be controlTransferState == CTRL_TRF_TX (<setup><in><in>...<in><out>)
1502:                  {
1503:                      //Error check the data stage byte count.  Make sure the user specified
1504:                      //value was no greater than the number of bytes the host requested.
1505:              		if(SetupPkt.wLength < inPipes[0].wCount.Val)
000A86  208560     MOV #0x856, W0
000A88  FB8010     ZE [W0], W0
000A8A  208571     MOV #0x857, W1
000A8C  FB8091     ZE [W1], W1
000A8E  DD08C8     SL W1, #8, W1
000A90  700001     IOR W0, W1, W0
000A92  780080     MOV W0, W1
000A94  804210     MOV 0x842, W0
000A96  508F80     SUB W1, W0, [W15]
000A98  310007     BRA C, .L56
1506:              		{
1507:              			inPipes[0].wCount.Val = SetupPkt.wLength;
000A9A  208560     MOV #0x856, W0
000A9C  FB8010     ZE [W0], W0
000A9E  208571     MOV #0x857, W1
000AA0  FB8091     ZE [W1], W1
000AA2  DD08C8     SL W1, #8, W1
000AA4  700001     IOR W0, W1, W0
000AA6  884210     MOV W0, 0x842
1508:              		}
1509:              		USBCtrlTrfTxService();  //Copies one IN data packet worth of data from application buffer
000AA8  070098     RCALL _USBCtrlTrfTxService, .LFE11, .LFB12
1510:              		                        //to CtrlTrfData buffer.  Also keeps track of how many bytes remaining.
1511:              
1512:              	    //Cnt should have been initialized by responsible request owner (ex: by
1513:              	    //using the USBEP0SendRAMPtr() or USBEP0SendROMPtr() API function).
1514:              		pBDTEntryIn[0]->ADR = ConvertToPhysicalAddress(&CtrlTrfData);
000AAA  804060     MOV pBDTEntryIn, W0
000AAC  208581     MOV #0x858, W1
000AAE  980011     MOV W1, [W0+2]
1515:              		pBDTEntryIn[0]->STAT.Val = _DAT1|(_DTSEN & _DTS_CHECKING_ENABLED);
000AB0  804060     MOV pBDTEntryIn, W0
000AB2  B3C481     MOV.B #0x48, W1
000AB4  984011     MOV.B W1, [W0+1]
1516:                      pBDTEntryIn[0]->STAT.Val |= _USIE;
000AB6  804060     MOV pBDTEntryIn, W0
000AB8  804061     MOV pBDTEntryIn, W1
000ABA  904091     MOV.B [W1+1], W1
000ABC  A07401     BSET.B W1, #7
000ABE  984011     MOV.B W1, [W0+1]
1517:                  }     
1518:              }    
000AC0  FA8000     ULNK
000AC2  060000     RETURN
1519:              
1520:              
1521:              /******************************************************************************/
1522:              /** Internal Functions *********************************************************/
1523:              /******************************************************************************/
1524:              
1525:              /********************************************************************
1526:               * Function:        void USBConfigureEndpoint(uint8_t EPNum, uint8_t direction)
1527:               *
1528:               * PreCondition:    None
1529:               *
1530:               * Input:           uint8_t EPNum - the endpoint to be configured
1531:               *                  uint8_t direction - the direction to be configured
1532:               *                                   (either OUT_FROM_HOST or IN_TO_HOST)
1533:               *
1534:               * Output:          None
1535:               *
1536:               * Side Effects:    None
1537:               *
1538:               * Overview:        This function will configure the specified 
1539:               *                  endpoint
1540:               *
1541:               * Note:            None
1542:               *******************************************************************/
1543:              static void USBConfigureEndpoint(uint8_t EPNum, uint8_t direction)
1544:              {
000AC4  FA0004     LNK #0x4
000AC6  984720     MOV.B W0, [W14+2]
000AC8  984731     MOV.B W1, [W14+3]
1545:                  volatile BDT_ENTRY* handle;
1546:              
1547:                  //Compute a pointer to the even BDT entry corresponding to the
1548:                  //EPNum and direction values passed to this function.
1549:                  handle = (volatile BDT_ENTRY*)&BDT[EP0_OUT_EVEN]; //Get address of start of BDT
000ACA  20A000     MOV #0xA00, W0
000ACC  780F00     MOV W0, [W14]
1550:                  handle += EP(EPNum,direction,0u);     //Add in offset to the BDT of interest
000ACE  90402E     MOV.B [W14+2], W0
000AD0  FB8000     ZE W0, W0
000AD2  400000     ADD W0, W0, W0
000AD4  780080     MOV W0, W1
000AD6  90403E     MOV.B [W14+3], W0
000AD8  FB8000     ZE W0, W0
000ADA  408000     ADD W1, W0, W0
000ADC  DD0043     SL W0, #3, W0
000ADE  400F1E     ADD W0, [W14], [W14]
1551:                  
1552:                  handle->STAT.UOWN = 0;  //mostly redundant, since USBStdSetCfgHandler() 
000AE0  78001E     MOV [W14], W0
000AE2  780110     MOV [W0], W2
000AE4  27FFF1     MOV #0x7FFF, W1
000AE6  610081     AND W2, W1, W1
000AE8  780801     MOV W1, [W0]
1553:                  //already cleared the entire BDT table
1554:              
1555:                  //Make sure our pBDTEntryIn/Out[] pointer is initialized.  Needed later
1556:                  //for USBTransferOnePacket() API calls.
1557:                  if(direction == OUT_FROM_HOST)
000AEA  90403E     MOV.B [W14+3], W0
000AEC  E00400     CP0.B W0
000AEE  3A0007     BRA NZ, .L58
1558:                  {
1559:                      pBDTEntryOut[EPNum] = handle;
000AF0  90402E     MOV.B [W14+2], W0
000AF2  FB8000     ZE W0, W0
000AF4  400080     ADD W0, W0, W1
000AF6  208080     MOV #0x808, W0
000AF8  408000     ADD W1, W0, W0
000AFA  78081E     MOV [W14], [W0]
000AFC  370006     BRA .L59
1560:                  }
1561:                  else
1562:                  {
1563:                      pBDTEntryIn[EPNum] = handle;
000AFE  90402E     MOV.B [W14+2], W0
000B00  FB8000     ZE W0, W0
000B02  400080     ADD W0, W0, W1
000B04  2080C0     MOV #0x80C, W0
000B06  408000     ADD W1, W0, W0
000B08  78081E     MOV [W14], [W0]
1564:                  }
1565:              
1566:                  #if (USB_PING_PONG_MODE == USB_PING_PONG__FULL_PING_PONG)
1567:                      handle->STAT.DTS = 0;
000B0A  78001E     MOV [W14], W0
000B0C  780110     MOV [W0], W2
000B0E  2BFFF1     MOV #0xBFFF, W1
000B10  610081     AND W2, W1, W1
000B12  780801     MOV W1, [W0]
1568:                      (handle+1)->STAT.DTS = 1;
000B14  78009E     MOV [W14], W1
000B16  408064     ADD W1, #0x4, W0
000B18  780090     MOV [W0], W1
000B1A  A0E001     BSET W1, #14
000B1C  780801     MOV W1, [W0]
1569:                  #elif (USB_PING_PONG_MODE == USB_PING_PONG__NO_PING_PONG)
1570:                      //Set DTS to one because the first thing we will do
1571:                      //when transmitting is toggle the bit
1572:                      handle->STAT.DTS = 1;
1573:                  #elif (USB_PING_PONG_MODE == USB_PING_PONG__EP0_OUT_ONLY)
1574:                      if(EPNum != 0)
1575:                      {
1576:                          handle->STAT.DTS = 1;
1577:                      }
1578:                  #elif (USB_PING_PONG_MODE == USB_PING_PONG__ALL_BUT_EP0)    
1579:                      if(EPNum != 0)
1580:                      {
1581:                          handle->STAT.DTS = 0;
1582:                          (handle+1)->STAT.DTS = 1;
1583:                      }
1584:                  #endif
1585:              }
000B1E  FA8000     ULNK
000B20  060000     RETURN
1586:              
1587:              
1588:              /******************************************************************************
1589:               * Function:        void USBCtrlEPServiceComplete(void)
1590:               *
1591:               * PreCondition:    None
1592:               *
1593:               * Input:           None
1594:               *
1595:               * Output:          None
1596:               *
1597:               * Side Effects:    None
1598:               *
1599:               * Overview:        This routine wrap up the remaining tasks in servicing
1600:               *                  a Setup Request. Its main task is to set the endpoint
1601:               *                  controls appropriately for a given situation. See code
1602:               *                  below.
1603:               *                  There are three main scenarios:
1604:               *                  a) There was no handler for the Request, in this case
1605:               *                     a STALL should be sent out.
1606:               *                  b) The host has requested a read control transfer,
1607:               *                     endpoints are required to be setup in a specific way.
1608:               *                  c) The host has requested a write control transfer, or
1609:               *                     a control data stage is not required, endpoints are
1610:               *                     required to be setup in a specific way.
1611:               *
1612:               *                  Packet processing is resumed by clearing PKTDIS bit.
1613:               *
1614:               * Note:            None
1615:               *****************************************************************************/
1616:              static void USBCtrlEPServiceComplete(void)
1617:              {
000B22  FA0000     LNK #0x0
1618:                  /*
1619:                   * PKTDIS bit is set when a Setup Transaction is received.
1620:                   * Clear to resume packet processing.
1621:                   */
1622:                  USBPacketDisable = 0;
000B24  A9A414     BCLR U1CON, #5
1623:              
1624:              	//Check the busy bits and the SetupPtk.DataDir variables to determine what type of
1625:              	//control transfer is currently in progress.  We need to know the type of control
1626:              	//transfer that is currently pending, in order to know how to properly arm the 
1627:              	//EP0 IN and EP0 OUT endpoints.
1628:                  if(inPipes[0].info.bits.busy == 0)
000B26  804201     MOV 0x840, W1
000B28  200800     MOV #0x80, W0
000B2A  608000     AND W1, W0, W0
000B2C  E00000     CP0 W0
000B2E  3A0027     BRA NZ, .L61
1629:                  {
1630:                      if(outPipes[0].info.bits.busy == 1)
000B30  208460     MOV #0x846, W0
000B32  784090     MOV.B [W0], W1
000B34  B3C800     MOV.B #0x80, W0
000B36  60C000     AND.B W1, W0, W0
000B38  E00400     CP0.B W0
000B3A  32000A     BRA Z, .L62
1631:                      {
1632:                          controlTransferState = CTRL_TRF_RX;
000B3C  B3C020     MOV.B #0x2, W0
000B3E  B7E811     MOV.B WREG, controlTransferState
1633:                          /*
1634:                           * Control Write:
1635:                           * <SETUP[0]><OUT[1]><OUT[0]>...<IN[1]> | <SETUP[0]>
1636:                           */
1637:              
1638:                          //1. Prepare OUT EP to receive data, unless a USB class request handler
1639:                          //   function decided to defer the data stage (ex: because the intended
1640:                          //   RAM buffer wasn't available yet) by calling USBDeferDataStage().
1641:                          //   If it did so, it is then responsible for calling USBCtrlEPAllowDataStage(),
1642:                          //   once it is ready to begin receiving the data.
1643:                          if(USBDeferOUTDataStagePackets == false)
000B40  BFC81E     MOV.B USBDeferOUTDataStagePackets, WREG
000B42  A20400     BTG.B W0, #0
000B44  E00400     CP0.B W0
000B46  320001     BRA Z, .L63
1644:                          {
1645:                              USBCtrlEPAllowDataStage();
000B48  07FF89     RCALL USBCtrlEPAllowDataStage
1646:                          }
1647:                          
1648:                          //2.  IN endpoint 0 status stage will be armed by USBCtrlEPAllowStatusStage() 
1649:                          //after all of the OUT data has been received and consumed, or if a timeout occurs.
1650:                          USBStatusStageEnabledFlag2 = false;
000B4A  EF681C     CLR.B USBStatusStageEnabledFlag2
1651:                          USBStatusStageEnabledFlag1 = false;
000B4C  EF681B     CLR.B USBStatusStageEnabledFlag1
000B4E  370043     BRA .L60
1652:                      }
1653:                      else
1654:                      {
1655:                          /*
1656:                           * If no one knows how to service this request then stall.
1657:                           * Must also prepare EP0 to receive the next SETUP transaction.
1658:                           */
1659:                          pBDTEntryEP0OutNext->CNT = USB_EP0_BUFF_SIZE;
000B50  804030     MOV pBDTEntryEP0OutNext, W0
000B52  B3C081     MOV.B #0x8, W1
000B54  784801     MOV.B W1, [W0]
1660:                          pBDTEntryEP0OutNext->ADR = ConvertToPhysicalAddress(&SetupPkt);
000B56  804030     MOV pBDTEntryEP0OutNext, W0
000B58  208501     MOV #0x850, W1
000B5A  980011     MOV W1, [W0+2]
1661:                          pBDTEntryEP0OutNext->STAT.Val = _DAT0|(_DTSEN & _DTS_CHECKING_ENABLED)|_BSTALL;
000B5C  804030     MOV pBDTEntryEP0OutNext, W0
000B5E  B3C0C1     MOV.B #0xC, W1
000B60  984011     MOV.B W1, [W0+1]
1662:                          pBDTEntryEP0OutNext->STAT.Val |= _USIE;
000B62  804030     MOV pBDTEntryEP0OutNext, W0
000B64  804031     MOV pBDTEntryEP0OutNext, W1
000B66  904091     MOV.B [W1+1], W1
000B68  A07401     BSET.B W1, #7
000B6A  984011     MOV.B W1, [W0+1]
1663:                          pBDTEntryIn[0]->STAT.Val = _BSTALL;
000B6C  804060     MOV pBDTEntryIn, W0
000B6E  B3C041     MOV.B #0x4, W1
000B70  984011     MOV.B W1, [W0+1]
1664:                          pBDTEntryIn[0]->STAT.Val |= _USIE;
000B72  804060     MOV pBDTEntryIn, W0
000B74  804061     MOV pBDTEntryIn, W1
000B76  904091     MOV.B [W1+1], W1
000B78  A07401     BSET.B W1, #7
000B7A  984011     MOV.B W1, [W0+1]
000B7C  37002C     BRA .L60
1665:                      }
1666:                  }
1667:                  else    // A module has claimed ownership of the control transfer session.
1668:                  {
1669:              		if(SetupPkt.DataDir == USB_SETUP_DEVICE_TO_HOST_BITFIELD)
000B7E  208500     MOV #0x850, W0
000B80  784090     MOV.B [W0], W1
000B82  B3C800     MOV.B #0x80, W0
000B84  60C000     AND.B W1, W0, W0
000B86  E00400     CP0.B W0
000B88  32000F     BRA Z, .L65
1670:              		{
1671:              			controlTransferState = CTRL_TRF_TX;
000B8A  B3C010     MOV.B #0x1, W0
000B8C  B7E811     MOV.B WREG, controlTransferState
1672:              			/*
1673:              			 * Control Read:
1674:              			 * <SETUP[0]><IN[1]><IN[0]>...<OUT[1]> | <SETUP[0]>
1675:              			 *
1676:              			 * 1. Prepare IN EP to transfer data to the host.  If however the data
1677:              			 *    wasn't ready yet (ex: because the firmware needs to go and read it from
1678:              			 *    some slow/currently unavailable resource, such as an external I2C EEPconst),
1679:              			 *    Then the class request handler responsible should call the USBDeferDataStage()
1680:              			 *    macro.  In this case, the firmware may wait up to 500ms, before it is required
1681:              			 *    to transmit the first IN data packet.  Once the data is ready, and the firmware
1682:              			 *    is ready to begin sending the data, it should then call the 
1683:              			 *    USBCtrlEPAllowDataStage() function to start the data stage.
1684:              			 */
1685:              			if(USBDeferINDataStagePackets == false)
000B8E  BFC81D     MOV.B USBDeferINDataStagePackets, WREG
000B90  A20400     BTG.B W0, #0
000B92  E00400     CP0.B W0
000B94  320001     BRA Z, .L66
1686:                          {
1687:                              USBCtrlEPAllowDataStage();
000B96  07FF62     RCALL USBCtrlEPAllowDataStage
1688:              			}
1689:              
1690:                          // 2. (Optionally) allow the status stage now, to prepare for early termination.
1691:                          //    Note: If a class request handler decided to set USBDeferStatusStagePacket == true,
1692:                          //    then it is responsible for eventually calling USBCtrlEPAllowStatusStage() once it
1693:                          //    is ready.  If the class request handler does this, it needs to be careful to
1694:                          //    be written so that it can handle the early termination scenario.
1695:                          //    Ex: It should call USBCtrlEPAllowStatusStage() when any of the following occurs:
1696:                          //    1.  The desired total number of bytes were sent to the host.
1697:                          //    2.  The number of bytes that the host originally requested (in the SETUP packet that 
1698:                          //        started the control transfer) has been reached.
1699:                          //    3.  Or, if a timeout occurs (ex: <50ms since the last successful EP0 IN transaction), regardless 
1700:                          //        of how many bytes have actually been sent.  This is necessary to prevent a deadlock situation
1701:                          //        (where the control transfer can't complete, due to continuous NAK on status stage) if the
1702:                          //        host performs early termination.  If enabled, the USB_ENABLE_STATUS_STAGE_TIMEOUTS usb_config.h
1703:                          //        option can take care of this for you.
1704:                          //    Note: For this type of control transfer, there is normally no harm in simply arming the
1705:                          //    status stage packet right now, even if the IN data is not ready yet.  This allows for
1706:                          //    immediate early termination, without adding unnecessary delay.  Therefore, it is generally not
1707:                          //    recommended for the USB class handler firmware to call USBDeferStatusStage(), for this 
1708:                          //    type of control transfer.  If the USB class handler firmware needs more time to fetch the IN
1709:                          //    data that needs to be sent to the host, it should instead use the USBDeferDataStage() function.
1710:                          USBStatusStageEnabledFlag2 = false;
000B98  EF681C     CLR.B USBStatusStageEnabledFlag2
1711:                          USBStatusStageEnabledFlag1 = false;
000B9A  EF681B     CLR.B USBStatusStageEnabledFlag1
1712:                          if(USBDeferStatusStagePacket == false)
000B9C  BFC81A     MOV.B USBDeferStatusStagePacket, WREG
000B9E  A20400     BTG.B W0, #0
000BA0  E00400     CP0.B W0
000BA2  320019     BRA Z, .L60
1713:                          {
1714:                              USBCtrlEPAllowStatusStage();
000BA4  07FF20     RCALL USBCtrlEPAllowStatusStage
000BA6  370017     BRA .L60
1715:                          } 
1716:              		}
1717:              		else   // (SetupPkt.DataDir == USB_SETUP_DIRECTION_HOST_TO_DEVICE)
1718:              		{
1719:              			//This situation occurs for special types of control transfers,
1720:              			//such as that which occurs when the host sends a SET_ADDRESS
1721:              			//control transfer.  Ex:
1722:              			//
1723:              			//<SETUP[0]><IN[1]> | <SETUP[0]>
1724:              				
1725:              			//Although the data direction is HOST_TO_DEVICE, there is no data stage
1726:              			//(hence: outPipes[0].info.bits.busy == 0).  There is however still
1727:              			//an IN status stage.
1728:              
1729:              			controlTransferState = CTRL_TRF_RX;     //Since this is a HOST_TO_DEVICE control transfer
000BA8  B3C020     MOV.B #0x2, W0
000BAA  B7E811     MOV.B WREG, controlTransferState
1730:              			
1731:              			//1. Prepare OUT EP to receive the next SETUP packet.
1732:              			pBDTEntryEP0OutNext->CNT = USB_EP0_BUFF_SIZE;
000BAC  804030     MOV pBDTEntryEP0OutNext, W0
000BAE  B3C081     MOV.B #0x8, W1
000BB0  784801     MOV.B W1, [W0]
1733:              			pBDTEntryEP0OutNext->ADR = ConvertToPhysicalAddress(&SetupPkt);
000BB2  804030     MOV pBDTEntryEP0OutNext, W0
000BB4  208501     MOV #0x850, W1
000BB6  980011     MOV W1, [W0+2]
1734:              			pBDTEntryEP0OutNext->STAT.Val = _BSTALL;
000BB8  804030     MOV pBDTEntryEP0OutNext, W0
000BBA  B3C041     MOV.B #0x4, W1
000BBC  984011     MOV.B W1, [W0+1]
1735:                          pBDTEntryEP0OutNext->STAT.Val |= _USIE;
000BBE  804030     MOV pBDTEntryEP0OutNext, W0
000BC0  804031     MOV pBDTEntryEP0OutNext, W1
000BC2  904091     MOV.B [W1+1], W1
000BC4  A07401     BSET.B W1, #7
000BC6  984011     MOV.B W1, [W0+1]
1736:              				
1737:              			//2. Prepare for IN status stage of the control transfer
1738:                          USBStatusStageEnabledFlag2 = false;
000BC8  EF681C     CLR.B USBStatusStageEnabledFlag2
1739:                          USBStatusStageEnabledFlag1 = false;
000BCA  EF681B     CLR.B USBStatusStageEnabledFlag1
1740:              			if(USBDeferStatusStagePacket == false)
000BCC  BFC81A     MOV.B USBDeferStatusStagePacket, WREG
000BCE  A20400     BTG.B W0, #0
000BD0  E00400     CP0.B W0
000BD2  320001     BRA Z, .L60
1741:                          {
1742:                              USBCtrlEPAllowStatusStage();
000BD4  07FF08     RCALL USBCtrlEPAllowStatusStage
1743:                          } 
1744:              		}
1745:              
1746:                  }//end if(ctrl_trf_session_owner == MUID_NULL)
1747:              
1748:              }//end USBCtrlEPServiceComplete
000BD6  FA8000     ULNK
000BD8  060000     RETURN
1749:              
1750:              
1751:              /******************************************************************************
1752:               * Function:        void USBCtrlTrfTxService(void)
1753:               *
1754:               * PreCondition:    pSrc, wCount, and usb_stat.ctrl_trf_mem are setup properly.
1755:               *
1756:               * Input:           None
1757:               *
1758:               * Output:          None
1759:               *
1760:               * Side Effects:    None
1761:               *
1762:               * Overview:        This routine is used for device to host control transfers 
1763:               *					(IN transactions).  This function takes care of managing a
1764:               *                  transfer over multiple USB transactions.
1765:               *					This routine should be called from only two places.
1766:               *                  One from USBCtrlEPServiceComplete() and one from
1767:               *                  USBCtrlTrfInHandler().
1768:               *
1769:               * Note:            
1770:               *****************************************************************************/
1771:              static void USBCtrlTrfTxService(void)
1772:              {
000BDA  FA0002     LNK #0x2
1773:                  uint8_t byteToSend;
1774:              
1775:                  //Figure out how many bytes of data to send in the next IN transaction.
1776:                  //Assume a full size packet, unless otherwise determined below.
1777:                  byteToSend = USB_EP0_BUFF_SIZE;         
000BDC  B3C080     MOV.B #0x8, W0
000BDE  784F00     MOV.B W0, [W14]
1778:                  if(inPipes[0].wCount.Val < (uint8_t)USB_EP0_BUFF_SIZE)
000BE0  804210     MOV 0x842, W0
000BE2  500FE7     SUB W0, #0x7, [W15]
000BE4  3E000D     BRA GTU, .L68
1779:                  {
1780:                      byteToSend = inPipes[0].wCount.Val;
000BE6  804210     MOV 0x842, W0
000BE8  784F00     MOV.B W0, [W14]
1781:              
1782:                      //Keep track of whether or not we have sent a "short packet" yet.
1783:                      //This is useful so that later on, we can configure EP0 IN to STALL,
1784:                      //after we have sent all of the intended data.  This makes sure the
1785:                      //hardware STALLs if the host erroneously tries to send more IN token 
1786:                      //packets, requesting more data than intended in the control transfer.
1787:                      if(shortPacketStatus == SHORT_PKT_NOT_USED)
000BEA  BFC810     MOV.B shortPacketStatus, WREG
000BEC  E00400     CP0.B W0
000BEE  3A0003     BRA NZ, .L69
1788:                      {
1789:                          shortPacketStatus = SHORT_PKT_PENDING;
000BF0  B3C010     MOV.B #0x1, W0
000BF2  B7E810     MOV.B WREG, shortPacketStatus
000BF4  370005     BRA .L68
1790:                      }
1791:                      else if(shortPacketStatus == SHORT_PKT_PENDING)
000BF6  BFC810     MOV.B shortPacketStatus, WREG
000BF8  504FE1     SUB.B W0, #0x1, [W15]
000BFA  3A0002     BRA NZ, .L68
1792:                      {
1793:                          shortPacketStatus = SHORT_PKT_SENT;
000BFC  B3C020     MOV.B #0x2, W0
000BFE  B7E810     MOV.B WREG, shortPacketStatus
1794:                      }
1795:                  }
1796:              
1797:                  //Keep track of how many bytes remain to be sent in the transfer, by
1798:                  //subtracting the number of bytes about to be sent from the total.
1799:                  inPipes[0].wCount.Val -= byteToSend;
000C00  804211     MOV 0x842, W1
000C02  FB801E     ZE [W14], W0
000C04  508000     SUB W1, W0, W0
000C06  884210     MOV W0, 0x842
1800:                  
1801:                  //Next, load the number of bytes to send to BC7..0 in buffer descriptor.
1802:                  //Note: Control endpoints may never have a max packet size of > 64 bytes.
1803:                  //Therefore, the BC8 and BC9 bits should always be maintained clear.
1804:                  pBDTEntryIn[0]->CNT = byteToSend;
000C08  804060     MOV pBDTEntryIn, W0
000C0A  78481E     MOV.B [W14], [W0]
1805:              
1806:                  //Now copy the data from the source location, to the CtrlTrfData[] buffer,
1807:                  //which we will send to the host.
1808:                  pDst = (USB_VOLATILE uint8_t*)CtrlTrfData;                // Set destination pointer
000C0C  208580     MOV #0x858, W0
000C0E  884090     MOV W0, pDst
1809:                  if(inPipes[0].info.bits.ctrl_trf_mem == USB_EP0_ROM)   // Determine type of memory source
000C10  804200     MOV 0x840, W0
000C12  600061     AND W0, #0x1, W0
000C14  E00000     CP0 W0
000C16  3A0017     BRA NZ, .L74
1810:                  {
1811:                      while(byteToSend)
000C18  370009     BRA .L71
000C2C  78401E     MOV.B [W14], W0
000C2E  E00400     CP0.B W0
000C30  3AFFF4     BRA NZ, .L72
000C32  37000C     BRA .L67
1812:                      {
1813:                          *pDst++ = *inPipes[0].pSrc.bRom++;
000C1A  804091     MOV pDst, W1
000C1C  8041F0     MOV inPipes, W0
000C1E  784110     MOV.B [W0], W2
000C20  784882     MOV.B W2, [W1]
000C22  E80081     INC W1, W1
000C24  884091     MOV W1, pDst
000C26  E80000     INC W0, W0
000C28  8841F0     MOV W0, inPipes
1814:                          byteToSend--;
000C2A  E94F1E     DEC.B [W14], [W14]
1815:                      }//end while(byte_to_send.Val)
1816:                  }
1817:                  else  // RAM
1818:                  {
1819:                      while(byteToSend)
000C46  78401E     MOV.B [W14], W0
000C48  E00400     CP0.B W0
000C4A  3AFFF4     BRA NZ, .L75
1820:                      {
1821:                          *pDst++ = *inPipes[0].pSrc.bRam++;
000C34  804091     MOV pDst, W1
000C36  8041F0     MOV inPipes, W0
000C38  784110     MOV.B [W0], W2
000C3A  784882     MOV.B W2, [W1]
000C3C  E80081     INC W1, W1
000C3E  884091     MOV W1, pDst
000C40  E80000     INC W0, W0
000C42  8841F0     MOV W0, inPipes
1822:                          byteToSend--;
000C44  E94F1E     DEC.B [W14], [W14]
1823:                      }//end while(byte_to_send.Val)
1824:                  }//end if(usb_stat.ctrl_trf_mem == _const)
1825:              }//end USBCtrlTrfTxService
000C4C  FA8000     ULNK
000C4E  060000     RETURN
1826:              
1827:              /******************************************************************************
1828:               * Function:        void USBCtrlTrfRxService(void)
1829:               *
1830:               * PreCondition:    pDst and wCount are setup properly.
1831:               *                  pSrc is always &CtrlTrfData
1832:               *                  usb_stat.ctrl_trf_mem is always USB_EP0_RAM.
1833:               *                  wCount should be set to 0 at the start of each control
1834:               *                  transfer.
1835:               *
1836:               * Input:           None
1837:               *
1838:               * Output:          None
1839:               *
1840:               * Side Effects:    None
1841:               *
1842:               * Overview:        This routine is used for host to device control transfers
1843:               *					(uses OUT transactions).  This function receives the data that arrives
1844:               *					on EP0 OUT, and copies it into the appropriate outPipes[0].pDst.bRam
1845:               *					buffer.  Once the host has sent all the data it was intending
1846:               *					to send, this function will call the appropriate outPipes[0].pFunc()
1847:               *					handler (unless it is NULL), so that it can be used by the
1848:               *					intended target firmware.
1849:               *
1850:               * Note:            None
1851:               *****************************************************************************/
1852:              static void USBCtrlTrfRxService(void)
1853:              {
000C50  FA0002     LNK #0x2
1854:                  uint8_t byteToRead;
1855:                  uint8_t i;
1856:              
1857:                  //Load byteToRead with the number of bytes the host just sent us in the 
1858:                  //last OUT transaction.
1859:                  byteToRead = pBDTEntryEP0OutCurrent->CNT;   
000C52  804020     MOV pBDTEntryEP0OutCurrent, W0
000C54  784F10     MOV.B [W0], [W14]
1860:              
1861:                  //Update the "outPipes[0].wCount.Val", which keeps track of the total number
1862:                  //of remaining bytes expected to be received from the host, in the control
1863:                  //transfer.  First check to see if the host sent us more bytes than the
1864:                  //application firmware was expecting to receive.
1865:                  if(byteToRead > outPipes[0].wCount.Val)
000C56  FB809E     ZE [W14], W1
000C58  804230     MOV 0x846, W0
000C5A  DE0048     LSR W0, #8, W0
000C5C  804243     MOV 0x848, W3
000C5E  200FF2     MOV #0xFF, W2
000C60  618102     AND W3, W2, W2
000C62  DD1148     SL W2, #8, W2
000C64  700002     IOR W0, W2, W0
000C66  508F80     SUB W1, W0, [W15]
000C68  360008     BRA LEU, .L77
1866:                  {
1867:                      byteToRead = outPipes[0].wCount.Val;
000C6A  804230     MOV 0x846, W0
000C6C  DE0048     LSR W0, #8, W0
000C6E  804242     MOV 0x848, W2
000C70  200FF1     MOV #0xFF, W1
000C72  610081     AND W2, W1, W1
000C74  DD08C8     SL W1, #8, W1
000C76  700001     IOR W0, W1, W0
000C78  784F00     MOV.B W0, [W14]
1868:                  }	
1869:                  //Reduce the number of remaining bytes by the number we just received.
1870:                  outPipes[0].wCount.Val -= byteToRead;
000C7A  804230     MOV 0x846, W0
000C7C  DE0048     LSR W0, #8, W0
000C7E  804242     MOV 0x848, W2
000C80  200FF1     MOV #0xFF, W1
000C82  610081     AND W2, W1, W1
000C84  DD08C8     SL W1, #8, W1
000C86  700001     IOR W0, W1, W0
000C88  780080     MOV W0, W1
000C8A  FB801E     ZE [W14], W0
000C8C  508000     SUB W1, W0, W0
000C8E  200FF1     MOV #0xFF, W1
000C90  600081     AND W0, W1, W1
000C92  DD08C8     SL W1, #8, W1
000C94  804233     MOV 0x846, W3
000C96  200FF2     MOV #0xFF, W2
000C98  618102     AND W3, W2, W2
000C9A  708082     IOR W1, W2, W1
000C9C  884231     MOV W1, 0x846
000C9E  DE00C8     LSR W0, #8, W1
000CA0  200FF0     MOV #0xFF, W0
000CA2  608000     AND W1, W0, W0
000CA4  804242     MOV 0x848, W2
000CA6  2FF001     MOV #0xFF00, W1
000CA8  610081     AND W2, W1, W1
000CAA  700001     IOR W0, W1, W0
000CAC  884240     MOV W0, 0x848
1871:              
1872:                  //Copy the OUT DATAx packet bytes that we just received from the host,
1873:                  //into the user application buffer space.
1874:                  for(i=0;i<byteToRead;i++)
000CAE  EB4000     CLR.B W0
000CB0  984710     MOV.B W0, [W14+1]
000CB2  37000C     BRA .L78
000CC6  90401E     MOV.B [W14+1], W0
000CC8  E84000     INC.B W0, W0
000CCA  984710     MOV.B W0, [W14+1]
000CCC  90401E     MOV.B [W14+1], W0
000CCE  504F9E     SUB.B W0, [W14], [W15]
000CD0  39FFF1     BRA NC, .L79
1875:                  {
1876:                      *outPipes[0].pDst.bRam++ = CtrlTrfData[i];
000CB4  804220     MOV outPipes, W0
000CB6  90409E     MOV.B [W14+1], W1
000CB8  FB8101     ZE W1, W2
000CBA  208581     MOV #0x858, W1
000CBC  410081     ADD W2, W1, W1
000CBE  784091     MOV.B [W1], W1
000CC0  784801     MOV.B W1, [W0]
000CC2  E80000     INC W0, W0
000CC4  884220     MOV W0, outPipes
1877:                  }//end while(byteToRead.Val)
1878:              
1879:                  //If there is more data to receive, prepare EP0 OUT so that it can receive 
1880:              	//the next packet in the sequence.
1881:                  if(outPipes[0].wCount.Val > 0)
000CD2  804230     MOV 0x846, W0
000CD4  DE0048     LSR W0, #8, W0
000CD6  804242     MOV 0x848, W2
000CD8  200FF1     MOV #0xFF, W1
000CDA  610081     AND W2, W1, W1
000CDC  DD08C8     SL W1, #8, W1
000CDE  700001     IOR W0, W1, W0
000CE0  E00000     CP0 W0
000CE2  32001E     BRA Z, .L80
1882:                  {
1883:                      pBDTEntryEP0OutNext->CNT = USB_EP0_BUFF_SIZE;
000CE4  804030     MOV pBDTEntryEP0OutNext, W0
000CE6  B3C081     MOV.B #0x8, W1
000CE8  784801     MOV.B W1, [W0]
1884:                      pBDTEntryEP0OutNext->ADR = ConvertToPhysicalAddress(&CtrlTrfData);
000CEA  804030     MOV pBDTEntryEP0OutNext, W0
000CEC  208581     MOV #0x858, W1
000CEE  980011     MOV W1, [W0+2]
1885:                      if(pBDTEntryEP0OutCurrent->STAT.DTS == 0)
000CF0  804020     MOV pBDTEntryEP0OutCurrent, W0
000CF2  780090     MOV [W0], W1
000CF4  240000     MOV #0x4000, W0
000CF6  608000     AND W1, W0, W0
000CF8  E00000     CP0 W0
000CFA  3A0009     BRA NZ, .L81
1886:                      {
1887:                          pBDTEntryEP0OutNext->STAT.Val = _DAT1|(_DTSEN & _DTS_CHECKING_ENABLED);
000CFC  804030     MOV pBDTEntryEP0OutNext, W0
000CFE  B3C481     MOV.B #0x48, W1
000D00  984011     MOV.B W1, [W0+1]
1888:                          pBDTEntryEP0OutNext->STAT.Val |= _USIE;
000D02  804030     MOV pBDTEntryEP0OutNext, W0
000D04  804031     MOV pBDTEntryEP0OutNext, W1
000D06  904091     MOV.B [W1+1], W1
000D08  A07401     BSET.B W1, #7
000D0A  984011     MOV.B W1, [W0+1]
000D0C  370031     BRA .L76
1889:                      }
1890:                      else
1891:                      {
1892:                          pBDTEntryEP0OutNext->STAT.Val = _DAT0|(_DTSEN & _DTS_CHECKING_ENABLED);
000D0E  804030     MOV pBDTEntryEP0OutNext, W0
000D10  B3C081     MOV.B #0x8, W1
000D12  984011     MOV.B W1, [W0+1]
1893:                          pBDTEntryEP0OutNext->STAT.Val |= _USIE;
000D14  804030     MOV pBDTEntryEP0OutNext, W0
000D16  804031     MOV pBDTEntryEP0OutNext, W1
000D18  904091     MOV.B [W1+1], W1
000D1A  A07401     BSET.B W1, #7
000D1C  984011     MOV.B W1, [W0+1]
000D1E  370028     BRA .L76
1894:                      }
1895:                  }
1896:                  else
1897:                  {
1898:              	    //We have received all OUT packets that we were expecting to
1899:              	    //receive for the control transfer.  Prepare EP0 OUT to receive
1900:              		//the next SETUP transaction that may arrive.
1901:                      pBDTEntryEP0OutNext->CNT = USB_EP0_BUFF_SIZE;
000D20  804030     MOV pBDTEntryEP0OutNext, W0
000D22  B3C081     MOV.B #0x8, W1
000D24  784801     MOV.B W1, [W0]
1902:                      pBDTEntryEP0OutNext->ADR = ConvertToPhysicalAddress(&SetupPkt);
000D26  804030     MOV pBDTEntryEP0OutNext, W0
000D28  208501     MOV #0x850, W1
000D2A  980011     MOV W1, [W0+2]
1903:                      //Configure EP0 OUT to receive the next SETUP transaction for any future
1904:                      //control transfers.  However, set BSTALL in case the host tries to send
1905:                      //more data than it claims it was going to send.
1906:                      pBDTEntryEP0OutNext->STAT.Val = _BSTALL;
000D2C  804030     MOV pBDTEntryEP0OutNext, W0
000D2E  B3C041     MOV.B #0x4, W1
000D30  984011     MOV.B W1, [W0+1]
1907:                      pBDTEntryEP0OutNext->STAT.Val |= _USIE;
000D32  804030     MOV pBDTEntryEP0OutNext, W0
000D34  804031     MOV pBDTEntryEP0OutNext, W1
000D36  904091     MOV.B [W1+1], W1
000D38  A07401     BSET.B W1, #7
000D3A  984011     MOV.B W1, [W0+1]
1908:              
1909:              		//All data bytes for the host to device control write (OUT) have now been
1910:              		//received successfully.
1911:              		//Go ahead and call the user specified callback function, to use/consume
1912:              		//the control transfer data (ex: if the "void (*function)" parameter 
1913:              		//was non-NULL when USBEP0Receive() was called).
1914:                      if(outPipes[0].pFunc != NULL)
000D3C  804240     MOV 0x848, W0
000D3E  DE0048     LSR W0, #8, W0
000D40  804252     MOV 0x84A, W2
000D42  200FF1     MOV #0xFF, W1
000D44  610081     AND W2, W1, W1
000D46  DD08C8     SL W1, #8, W1
000D48  700001     IOR W0, W1, W0
000D4A  E00000     CP0 W0
000D4C  320008     BRA Z, .L83
1915:                      {
1916:                          #if defined(__XC8)
1917:                              //Special pragmas to suppress an expected/harmless warning
1918:                              //message when building with the XC8 compiler
1919:                              #pragma warning push
1920:                              #pragma warning disable 1088
1921:                              outPipes[0].pFunc();    //Call the user's callback function
1922:                              #pragma warning pop
1923:                          #else
1924:                              outPipes[0].pFunc();    //Call the user's callback function
000D4E  804240     MOV 0x848, W0
000D50  DE0048     LSR W0, #8, W0
000D52  804252     MOV 0x84A, W2
000D54  200FF1     MOV #0xFF, W1
000D56  610081     AND W2, W1, W1
000D58  DD08C8     SL W1, #8, W1
000D5A  700001     IOR W0, W1, W0
000D5C  010000     CALL W0
1925:                          #endif
1926:                      }
1927:                      outPipes[0].info.bits.busy = 0;    
000D5E  804231     MOV 0x846, W1
000D60  2FF7F0     MOV #0xFF7F, W0
000D62  608000     AND W1, W0, W0
000D64  884230     MOV W0, 0x846
1928:              
1929:                      //Ready to arm status stage IN transaction now, if the application
1930:                      //firmware has completed processing the request.  If it is still busy
1931:                      //and needs more time to finish handling the request, then the user
1932:                      //callback (the one called by the outPipes[0].pFunc();) should set the
1933:                      //USBDeferStatusStagePacket to true (by calling USBDeferStatusStage()).  In
1934:                      //this case, it is the application's firmware responsibility to call 
1935:                      //the USBCtrlEPAllowStatusStage() function, once it is fully done handling the request.
1936:                      //Note: The application firmware must process the request and call
1937:                      //USBCtrlEPAllowStatusStage() in a semi-timely fashion.  "Semi-timely"
1938:                      //means either 50ms, 500ms, or 5 seconds, depending on the type of
1939:                      //control transfer.  See the USB 2.0 specification section 9.2.6 for
1940:                      //more details.
1941:                      if(USBDeferStatusStagePacket == false)
000D66  BFC81A     MOV.B USBDeferStatusStagePacket, WREG
000D68  A20400     BTG.B W0, #0
000D6A  E00400     CP0.B W0
000D6C  320001     BRA Z, .L76
1942:                      {
1943:                          USBCtrlEPAllowStatusStage();
000D6E  07FE3B     RCALL USBCtrlEPAllowStatusStage
1944:                      }            
1945:                  }    
1946:              
1947:              }//end USBCtrlTrfRxService
000D70  FA8000     ULNK
000D72  060000     RETURN
1948:              
1949:              
1950:              /********************************************************************
1951:               * Function:        void USBStdSetCfgHandler(void)
1952:               *
1953:               * PreCondition:    None
1954:               *
1955:               * Input:           None
1956:               *
1957:               * Output:          None
1958:               *
1959:               * Side Effects:    None
1960:               *
1961:               * Overview:        This routine first disables all endpoints by
1962:               *                  clearing UEP registers. It then configures
1963:               *                  (initializes) endpoints by calling the callback
1964:               *                  function USBCBInitEP().
1965:               *
1966:               * Note:            None
1967:               *******************************************************************/
1968:              static void USBStdSetCfgHandler(void)
1969:              {
000D74  FA0002     LNK #0x2
1970:                  uint8_t i;
1971:              
1972:                  // This will generate a zero length packet
1973:                  inPipes[0].info.bits.busy = 1;            
000D76  804200     MOV 0x840, W0
000D78  A07000     BSET W0, #7
000D7A  884200     MOV W0, 0x840
1974:              
1975:                  //Clear all of the endpoint control registers
1976:                  DisableNonZeroEndpoints(USB_MAX_EP_NUMBER);
000D7C  200022     MOV #0x2, W2
000D7E  EB0080     CLR W1
000D80  2042C0     MOV #0x42C, W0
000D82  07FB17     RCALL _memset
1977:              
1978:                  //Clear all of the BDT entries
1979:                  memset((void*)&BDT[0], 0x00, sizeof(BDT));
000D84  200202     MOV #0x20, W2
000D86  EB0080     CLR W1
000D88  20A000     MOV #0xA00, W0
000D8A  07FB13     RCALL _memset
1980:              
1981:                  // Assert reset request to all of the Ping Pong buffer pointers
1982:                  USBPingPongBufferReset = 1;                                   
000D8C  A82414     BSET U1CON, #1
1983:              
1984:              	//Re-Initialize all ping pong software state bits to 0 (which corresponds to
1985:              	//the EVEN buffer being the next one that will be used), since we are also 
1986:              	//doing a hardware ping pong pointer reset above.
1987:              	for(i = 0; i < (uint8_t)(USB_MAX_EP_NUMBER+1u); i++)
000D8E  EB4000     CLR.B W0
000D90  784F00     MOV.B W0, [W14]
000D92  37000B     BRA .L85
000DA8  E84F1E     INC.B [W14], [W14]
000DAA  78401E     MOV.B [W14], W0
000DAC  504FE1     SUB.B W0, #0x1, [W15]
000DAE  36FFF2     BRA LEU, .L86
1988:              	{
1989:              		ep_data_in[i].Val = 0u;
000D94  FB809E     ZE [W14], W1
000D96  2084C0     MOV #0x84C, W0
000D98  408000     ADD W1, W0, W0
000D9A  EB4080     CLR.B W1
000D9C  784801     MOV.B W1, [W0]
1990:                      ep_data_out[i].Val = 0u;
000D9E  FB809E     ZE [W14], W1
000DA0  2084E0     MOV #0x84E, W0
000DA2  408000     ADD W1, W0, W0
000DA4  EB4080     CLR.B W1
000DA6  784801     MOV.B W1, [W0]
1991:              	}
1992:              
1993:                  //clear the alternate interface settings
1994:                  memset((void*)&USBAlternateInterface,0x00,USB_MAX_NUM_INT);
000DB0  200012     MOV #0x1, W2
000DB2  EB0080     CLR W1
000DB4  208030     MOV #0x803, W0
000DB6  07FAFD     RCALL _memset
1995:              
1996:                  //Stop trying to reset ping pong buffer pointers
1997:                  USBPingPongBufferReset = 0;
000DB8  A92414     BCLR U1CON, #1
1998:              
1999:                  pBDTEntryIn[0] = (volatile BDT_ENTRY*)&BDT[EP0_IN_EVEN];
000DBA  20A080     MOV #0xA08, W0
000DBC  884060     MOV W0, pBDTEntryIn
2000:              
2001:              	//Set the next out to the current out packet
2002:                  pBDTEntryEP0OutCurrent = (volatile BDT_ENTRY*)&BDT[EP0_OUT_EVEN];
000DBE  20A000     MOV #0xA00, W0
000DC0  884020     MOV W0, pBDTEntryEP0OutCurrent
2003:                  pBDTEntryEP0OutNext = pBDTEntryEP0OutCurrent;
000DC2  804020     MOV pBDTEntryEP0OutCurrent, W0
000DC4  884030     MOV W0, pBDTEntryEP0OutNext
2004:              
2005:                  //set the current configuration
2006:                  USBActiveConfiguration = SetupPkt.bConfigurationValue;
000DC6  208520     MOV #0x852, W0
000DC8  784010     MOV.B [W0], W0
000DCA  B7E802     MOV.B WREG, USBActiveConfiguration
2007:              
2008:                  //if the configuration value == 0
2009:                  if(USBActiveConfiguration == 0)
000DCC  BFC802     MOV.B USBActiveConfiguration, WREG
000DCE  E00400     CP0.B W0
000DD0  3A0003     BRA NZ, .L87
2010:                  {
2011:                      //Go back to the addressed state
2012:                      USBDeviceState = ADDRESS_STATE;
000DD2  200100     MOV #0x10, W0
000DD4  884000     MOV W0, USBDeviceState
000DD6  370006     BRA .L84
2013:                  }
2014:                  else
2015:                  {
2016:                      //initialize the required endpoints
2017:                      USB_SET_CONFIGURATION_HANDLER(EVENT_CONFIGURED,(void*)&USBActiveConfiguration,1);
000DD8  200012     MOV #0x1, W2
000DDA  208021     MOV #0x802, W1
000DDC  200010     MOV #0x1, W0
000DDE  07069F     RCALL USER_USB_CALLBACK_EVENT_HANDLER
2018:              
2019:                      //Otherwise go to the configured state.  Update the state variable last,
2020:                      //after performing all of the set configuration related initialization
2021:                      //tasks.
2022:                      USBDeviceState = CONFIGURED_STATE;		
000DE0  200200     MOV #0x20, W0
000DE2  884000     MOV W0, USBDeviceState
2023:                  }//end if(SetupPkt.bConfigurationValue == 0)
2024:              }//end USBStdSetCfgHandler
000DE4  FA8000     ULNK
000DE6  060000     RETURN
2025:              
2026:              
2027:              /********************************************************************
2028:               * Function:        void USBStdGetDscHandler(void)
2029:               *
2030:               * PreCondition:    None
2031:               *
2032:               * Input:           None
2033:               *
2034:               * Output:          None
2035:               *
2036:               * Side Effects:    None
2037:               *
2038:               * Overview:        This routine handles the standard GET_DESCRIPTOR
2039:               *                  request.
2040:               *
2041:               * Note:            None
2042:               *******************************************************************/
2043:              static void USBStdGetDscHandler(void)
2044:              {
000DE8  FA0000     LNK #0x0
2045:                  if(SetupPkt.bmRequestType == 0x80)
000DEA  208500     MOV #0x850, W0
000DEC  784090     MOV.B [W0], W1
000DEE  B3C800     MOV.B #0x80, W0
000DF0  50CF80     SUB.B W1, W0, [W15]
000DF2  3A0047     BRA NZ, .L89
2046:                  {
2047:                      inPipes[0].info.Val = USB_EP0_ROM | USB_EP0_BUSY | USB_EP0_INCLUDE_ZERO;
000DF4  208400     MOV #0x840, W0
000DF6  B3CC01     MOV.B #0xC0, W1
000DF8  784801     MOV.B W1, [W0]
2048:              
2049:                      switch(SetupPkt.bDescriptorType)
000DFA  208530     MOV #0x853, W0
000DFC  784010     MOV.B [W0], W0
000DFE  FB8000     ZE W0, W0
000E00  500FE2     SUB W0, #0x2, [W15]
000E02  320009     BRA Z, .L93
000E04  500FE3     SUB W0, #0x3, [W15]
000E06  320023     BRA Z, .L94
000E08  500FE1     SUB W0, #0x1, [W15]
000E0A  3A0037     BRA NZ, .L99
2050:                      {
2051:                          case USB_DESCRIPTOR_DEVICE:
2052:                              #if !defined(USB_USER_DEVICE_DESCRIPTOR)
2053:                                  inPipes[0].pSrc.bRom = (const uint8_t*)&device_dsc;
000E0C  284600     MOV #0x8460, W0
000E0E  8841F0     MOV W0, inPipes
2054:                              #else
2055:                                  inPipes[0].pSrc.bRom = (const uint8_t*)USB_USER_DEVICE_DESCRIPTOR;
2056:                              #endif
2057:                              inPipes[0].wCount.Val = sizeof(device_dsc);
000E10  200120     MOV #0x12, W0
000E12  884210     MOV W0, 0x842
2058:                              break;
000E14  370036     BRA .L89
2059:                          case USB_DESCRIPTOR_CONFIGURATION:
2060:                              //First perform error case check, to make sure the host is requesting a 
2061:                              //legal descriptor index.  If the request index is illegal, don't do 
2062:                              //anything (so that the default STALL response will be sent).
2063:                              if(SetupPkt.bDscIndex < USB_MAX_NUM_CONFIG_DSC)
000E16  208520     MOV #0x852, W0
000E18  784010     MOV.B [W0], W0
000E1A  E00400     CP0.B W0
000E1C  3A0014     BRA NZ, .L95
2064:                              {
2065:                                  #if !defined(USB_USER_CONFIG_DESCRIPTOR)
2066:                                      inPipes[0].pSrc.bRom = *(USB_CD_Ptr+SetupPkt.bDscIndex);
000E1E  208520     MOV #0x852, W0
000E20  784010     MOV.B [W0], W0
000E22  FB8000     ZE W0, W0
000E24  400000     ADD W0, W0, W0
000E26  780080     MOV W0, W1
000E28  284F00     MOV #0x84F0, W0
000E2A  408000     ADD W1, W0, W0
000E2C  780010     MOV [W0], W0
000E2E  8841F0     MOV W0, inPipes
2067:                                  #else
2068:                                      inPipes[0].pSrc.bRom = *(USB_USER_CONFIG_DESCRIPTOR+SetupPkt.bDscIndex);
2069:                                  #endif
2070:              
2071:                                  //This must be loaded using byte addressing.  The source pointer
2072:                                  //  may not be word aligned for the 16 or 32 bit machines resulting
2073:                                  //  in an address error on the dereference.
2074:                                  inPipes[0].wCount.byte.LB = *(inPipes[0].pSrc.bRom+2);
000E30  8041F0     MOV inPipes, W0
000E32  E88000     INC2 W0, W0
000E34  784090     MOV.B [W0], W1
000E36  208420     MOV #0x842, W0
000E38  784801     MOV.B W1, [W0]
2075:                                  inPipes[0].wCount.byte.HB = *(inPipes[0].pSrc.bRom+3);
000E3A  8041F0     MOV inPipes, W0
000E3C  400063     ADD W0, #0x3, W0
000E3E  784090     MOV.B [W0], W1
000E40  208430     MOV #0x843, W0
000E42  784801     MOV.B W1, [W0]
2076:                              }
2077:              				else
2078:              				{
2079:              					inPipes[0].info.Val = 0;
000E46  208400     MOV #0x840, W0
000E48  EB4080     CLR.B W1
000E4A  784801     MOV.B W1, [W0]
2080:              				}
2081:                              break;
000E44  37001E     BRA .L89
000E4C  37001A     BRA .L89
2082:                          case USB_DESCRIPTOR_STRING:
2083:                              //USB_NUM_STRING_DESCRIPTORS was introduced as optional in release v2.3.  In v2.4 and
2084:                              //  later it is now mandatory.  This should be defined in usb_config.h and should
2085:                              //  indicate the number of string descriptors.
2086:                              if(SetupPkt.bDscIndex<USB_NUM_STRING_DESCRIPTORS)
000E4E  208520     MOV #0x852, W0
000E50  784010     MOV.B [W0], W0
000E52  504FE2     SUB.B W0, #0x2, [W15]
000E54  3E000E     BRA GTU, .L97
2087:                              {
2088:                                  //Get a pointer to the String descriptor requested
2089:                                  inPipes[0].pSrc.bRom = *(USB_SD_Ptr+SetupPkt.bDscIndex);
000E56  208520     MOV #0x852, W0
000E58  784010     MOV.B [W0], W0
000E5A  FB8000     ZE W0, W0
000E5C  400000     ADD W0, W0, W0
000E5E  780080     MOV W0, W1
000E60  284F20     MOV #0x84F2, W0
000E62  408000     ADD W1, W0, W0
000E64  780010     MOV [W0], W0
000E66  8841F0     MOV W0, inPipes
2090:                                  // Set data count
2091:                                  inPipes[0].wCount.Val = *inPipes[0].pSrc.bRom;                    
000E68  8041F0     MOV inPipes, W0
000E6A  784010     MOV.B [W0], W0
000E6C  FB8000     ZE W0, W0
000E6E  884210     MOV W0, 0x842
2092:                              }
2093:                              #if defined(IMPLEMENT_MICROSOFT_OS_DESCRIPTOR)
2094:                              else if(SetupPkt.bDscIndex == MICROSOFT_OS_DESCRIPTOR_INDEX)
2095:                              {
2096:                                  //Get a pointer to the special MS OS string descriptor requested
2097:                                  inPipes[0].pSrc.bRom = (const uint8_t*)&MSOSDescriptor;
2098:                                  // Set data count
2099:                                  inPipes[0].wCount.Val = *inPipes[0].pSrc.bRom;                    
2100:                              }    
2101:                              #endif
2102:                              else
2103:                              {
2104:                                  inPipes[0].info.Val = 0;
000E72  208400     MOV #0x840, W0
000E74  EB4080     CLR.B W1
000E76  784801     MOV.B W1, [W0]
2105:                              }
2106:                              break;
000E70  370008     BRA .L89
000E78  370004     BRA .L89
2107:                          default:
2108:                              inPipes[0].info.Val = 0;
000E7A  208400     MOV #0x840, W0
000E7C  EB4080     CLR.B W1
000E7E  784801     MOV.B W1, [W0]
2109:                              break;
000E80  000000     NOP
2110:                      }//end switch
2111:                  }//end if
2112:              }//end USBStdGetDscHandler
000E82  FA8000     ULNK
000E84  060000     RETURN
2113:              
2114:              /********************************************************************
2115:               * Function:        void USBStdGetStatusHandler(void)
2116:               *
2117:               * PreCondition:    None
2118:               *
2119:               * Input:           None
2120:               *
2121:               * Output:          None
2122:               *
2123:               * Side Effects:    None
2124:               *
2125:               * Overview:        This routine handles the standard GET_STATUS request
2126:               *
2127:               * Note:            None
2128:               *******************************************************************/
2129:              static void USBStdGetStatusHandler(void)
2130:              {
000E86  FA0002     LNK #0x2
2131:                  CtrlTrfData[0] = 0;                 // Initialize content
000E88  208580     MOV #0x858, W0
000E8A  EB4080     CLR.B W1
000E8C  784801     MOV.B W1, [W0]
2132:                  CtrlTrfData[1] = 0;
000E8E  208590     MOV #0x859, W0
000E90  EB4080     CLR.B W1
000E92  784801     MOV.B W1, [W0]
2133:              
2134:                  switch(SetupPkt.Recipient)
000E94  208500     MOV #0x850, W0
000E96  784090     MOV.B [W0], W1
000E98  60C07F     AND.B W1, #0x1F, W0
000E9A  FB8000     ZE W0, W0
000E9C  500FE1     SUB W0, #0x1, [W15]
000E9E  320011     BRA Z, .L103
000EA0  500FE2     SUB W0, #0x2, [W15]
000EA2  320013     BRA Z, .L104
000EA4  E00000     CP0 W0
000EA6  3A0040     BRA NZ, .L101
2135:                  {
2136:                      case USB_SETUP_RECIPIENT_DEVICE_BITFIELD:
2137:                          inPipes[0].info.bits.busy = 1;
000EA8  804200     MOV 0x840, W0
000EAA  A07000     BSET W0, #7
000EAC  884200     MOV W0, 0x840
2138:                          /*
2139:                           * [0]: bit0: Self-Powered Status [0] Bus-Powered [1] Self-Powered
2140:                           *      bit1: RemoteWakeup        [0] Disabled    [1] Enabled
2141:                           */
2142:                          if(self_power == 1) // self_power is defined in HardwareProfile.h
2143:                          {
2144:                              CtrlTrfData[0]|=0x01;
2145:                          }
2146:              
2147:                          if(RemoteWakeup == true)
000EAE  BFC814     MOV.B RemoteWakeup, WREG
000EB0  E00400     CP0.B W0
000EB2  320035     BRA Z, .L110, .LBE2
2148:                          {
2149:                              CtrlTrfData[0]|=0x02;
000EB4  208580     MOV #0x858, W0
000EB6  784010     MOV.B [W0], W0
000EB8  784080     MOV.B W0, W1
000EBA  A01401     BSET.B W1, #1
000EBC  208580     MOV #0x858, W0
000EBE  784801     MOV.B W1, [W0]
2150:                          }
2151:                          break;
000EC0  370033     BRA .L101
000F1E  000000     NOP
000F20  370003     BRA .L101
2152:                      case USB_SETUP_RECIPIENT_INTERFACE_BITFIELD:
2153:                          inPipes[0].info.bits.busy = 1;     // No data to update
000EC2  804200     MOV 0x840, W0
000EC4  A07000     BSET W0, #7
000EC6  884200     MOV W0, 0x840
2154:                          break;
000EC8  37002F     BRA .L101
2155:                      case USB_SETUP_RECIPIENT_ENDPOINT_BITFIELD:
2156:                          inPipes[0].info.bits.busy = 1;
000ECA  804200     MOV 0x840, W0
000ECC  A07000     BSET W0, #7
000ECE  884200     MOV W0, 0x840
2157:                          /*
2158:                           * [0]: bit0: Halt Status [0] Not Halted [1] Halted
2159:                           */
2160:                          {
2161:                              BDT_ENTRY *p;
2162:              
2163:                              if(SetupPkt.EPDir == 0)
000ED0  208540     MOV #0x854, W0
000ED2  784090     MOV.B [W0], W1
000ED4  B3C800     MOV.B #0x80, W0
000ED6  60C000     AND.B W1, W0, W0
000ED8  E00400     CP0.B W0
000EDA  3A0009     BRA NZ, .L106
2164:                              {
2165:                                  p = (BDT_ENTRY*)pBDTEntryOut[SetupPkt.EPNum];
000EDC  208540     MOV #0x854, W0
000EDE  784090     MOV.B [W0], W1
000EE0  60C06F     AND.B W1, #0xF, W0
000EE2  FB8000     ZE W0, W0
000EE4  400080     ADD W0, W0, W1
000EE6  208080     MOV #0x808, W0
000EE8  408000     ADD W1, W0, W0
000EEA  780F10     MOV [W0], [W14]
000EEC  370008     BRA .L107
2166:                              }
2167:                              else
2168:                              {
2169:                                  p = (BDT_ENTRY*)pBDTEntryIn[SetupPkt.EPNum];
000EEE  208540     MOV #0x854, W0
000EF0  784090     MOV.B [W0], W1
000EF2  60C06F     AND.B W1, #0xF, W0
000EF4  FB8000     ZE W0, W0
000EF6  400080     ADD W0, W0, W1
000EF8  2080C0     MOV #0x80C, W0
000EFA  408000     ADD W1, W0, W0
000EFC  780F10     MOV [W0], [W14]
2170:                              }
2171:              
2172:                              if((p->STAT.UOWN == 1) && (p->STAT.BSTALL == 1))
000EFE  78001E     MOV [W14], W0
000F00  780090     MOV [W0], W1
000F02  280000     MOV #0x8000, W0
000F04  608000     AND W1, W0, W0
000F06  E00000     CP0 W0
000F08  32000C     BRA Z, .L111
000F0A  78001E     MOV [W14], W0
000F0C  780090     MOV [W0], W1
000F0E  204000     MOV #0x400, W0
000F10  608000     AND W1, W0, W0
000F12  E00000     CP0 W0
000F14  320008     BRA Z, .L112
2173:                                  CtrlTrfData[0]=0x01;    // Set bit0
000F16  208580     MOV #0x858, W0
000F18  B3C011     MOV.B #0x1, W1
000F1A  784801     MOV.B W1, [W0]
2174:                              break;
000F1C  370005     BRA .L101
000F22  000000     NOP
000F24  370001     BRA .L101
000F26  000000     NOP
2175:                          }
2176:                  }//end switch
2177:              
2178:                  if(inPipes[0].info.bits.busy == 1)
000F28  804201     MOV 0x840, W1
000F2A  200800     MOV #0x80, W0
000F2C  608000     AND W1, W0, W0
000F2E  E00000     CP0 W0
000F30  320008     BRA Z, .L100
2179:                  {
2180:                      inPipes[0].pSrc.bRam = (uint8_t*)&CtrlTrfData;        // Set Source
000F32  208580     MOV #0x858, W0
000F34  8841F0     MOV W0, inPipes
2181:                      inPipes[0].info.bits.ctrl_trf_mem = USB_EP0_RAM;      // Set memory type
000F36  804200     MOV 0x840, W0
000F38  A00000     BSET W0, #0
000F3A  884200     MOV W0, 0x840
2182:                      inPipes[0].wCount.v[0] = 2;                           // Set data count
000F3C  208420     MOV #0x842, W0
000F3E  B3C021     MOV.B #0x2, W1
000F40  784801     MOV.B W1, [W0]
2183:                  }//end if(...)
2184:              }//end USBStdGetStatusHandler
000F42  FA8000     ULNK
000F44  060000     RETURN
2185:              
2186:              /********************************************************************
2187:               * Function:        void USBStallHandler(void)
2188:               *
2189:               * PreCondition:    None
2190:               *
2191:               * Input:           None
2192:               *
2193:               * Output:          None
2194:               *
2195:               * Side Effects:    
2196:               *
2197:               * Overview:        This function handles the event of a STALL 
2198:               *                  occurring on the bus
2199:               *
2200:               * Note:            None
2201:               *******************************************************************/
2202:              static void USBStallHandler(void)
2203:              {
000F46  FA0000     LNK #0x0
2204:                  /*
2205:                   * Does not really have to do anything here,
2206:                   * even for the control endpoint.
2207:                   * All BDs of Endpoint 0 are owned by SIE right now,
2208:                   * but once a Setup Transaction is received, the ownership
2209:                   * for EP0_OUT will be returned to CPU.
2210:                   * When the Setup Transaction is serviced, the ownership
2211:                   * for EP0_IN will then be forced back to CPU by firmware.
2212:                   */
2213:              
2214:                  if(U1EP0bits.EPSTALL == 1)
000F48  802150     MOV U1EP0, W0
000F4A  600062     AND W0, #0x2, W0
000F4C  E00000     CP0 W0
000F4E  320013     BRA Z, .L114
2215:                  {
2216:                      // UOWN - if 0, owned by CPU, if 1, owned by SIE
2217:                      if((pBDTEntryEP0OutCurrent->STAT.Val == _USIE) && (pBDTEntryIn[0]->STAT.Val == (_USIE|_BSTALL)))
000F50  804020     MOV pBDTEntryEP0OutCurrent, W0
000F52  904090     MOV.B [W0+1], W1
000F54  B3C800     MOV.B #0x80, W0
000F56  50CF80     SUB.B W1, W0, [W15]
000F58  3A000D     BRA NZ, .L115
000F5A  804060     MOV pBDTEntryIn, W0
000F5C  904090     MOV.B [W0+1], W1
000F5E  B3C840     MOV.B #0x84, W0
000F60  50CF80     SUB.B W1, W0, [W15]
000F62  3A0008     BRA NZ, .L115
2218:                      {
2219:                          // Set ep0Bo to stall also
2220:                          pBDTEntryEP0OutCurrent->STAT.Val = _DAT0|(_DTSEN & _DTS_CHECKING_ENABLED)|_BSTALL;
000F64  804020     MOV pBDTEntryEP0OutCurrent, W0
000F66  B3C0C1     MOV.B #0xC, W1
000F68  984011     MOV.B W1, [W0+1]
2221:                          pBDTEntryEP0OutCurrent->STAT.Val |= _USIE;
000F6A  804020     MOV pBDTEntryEP0OutCurrent, W0
000F6C  804021     MOV pBDTEntryEP0OutCurrent, W1
000F6E  904091     MOV.B [W1+1], W1
000F70  A07401     BSET.B W1, #7
000F72  984011     MOV.B W1, [W0+1]
2222:                      }//end if
2223:                      U1EP0bits.EPSTALL = 0;               // Clear stall status
000F74  A9242A     BCLR U1EP0, #1
2224:                  }//end if
2225:              
2226:                  USBClearInterruptFlag(USBStallIFReg,USBStallIFBitNum);
000F76  200800     MOV #0x80, W0
000F78  882050     MOV W0, U1IR
2227:              }
000F7A  FA8000     ULNK
000F7C  060000     RETURN
2228:              
2229:              /********************************************************************
2230:               * Function:        void USBSuspend(void)
2231:               *
2232:               * PreCondition:    None
2233:               *
2234:               * Input:           None
2235:               *
2236:               * Output:          None
2237:               *
2238:               * Side Effects:    
2239:               *
2240:               * Overview:        This function handles if the host tries to 
2241:               *                  suspend the device
2242:               *
2243:               * Note:            None
2244:               *******************************************************************/
2245:              static void USBSuspend(void)
2246:              {
000F7E  FA0000     LNK #0x0
2247:                  /*
2248:                   * NOTE: Do not clear UIRbits.ACTVIF here!
2249:                   * Reason:
2250:                   * ACTVIF is only generated once an IDLEIF has been generated.
2251:                   * This is a 1:1 ratio interrupt generation.
2252:                   * For every IDLEIF, there will be only one ACTVIF regardless of
2253:                   * the number of subsequent bus transitions.
2254:                   *
2255:                   * If the ACTIF is cleared here, a problem could occur when:
2256:                   * [       IDLE       ][bus activity ->
2257:                   * <--- 3 ms ----->     ^
2258:                   *                ^     ACTVIF=1
2259:                   *                IDLEIF=1
2260:                   *  #           #           #           #   (#=Program polling flags)
2261:                   *                          ^
2262:                   *                          This polling loop will see both
2263:                   *                          IDLEIF=1 and ACTVIF=1.
2264:                   *                          However, the program services IDLEIF first
2265:                   *                          because ACTIVIE=0.
2266:                   *                          If this routine clears the only ACTIVIF,
2267:                   *                          then it can never get out of the suspend
2268:                   *                          mode.
2269:                   */
2270:                  USBActivityIE = 1;                     // Enable bus activity interrupt
000F80  A88402     BSET U1OTGIE, #4
2271:                  USBClearInterruptFlag(USBIdleIFReg,USBIdleIFBitNum);
000F82  200100     MOV #0x10, W0
000F84  882050     MOV W0, U1IR
2272:              
2273:                  #if defined(__18CXX) || defined(_PIC14E) || defined(__XC8)
2274:                      U1CONbits.SUSPND = 1;                   // Put USB module in power conserve
2275:                                                              // mode, SIE clock inactive
2276:                  #endif
2277:                  USBBusIsSuspended = true;
000F86  B3C010     MOV.B #0x1, W0
000F88  B7E815     MOV.B WREG, USBBusIsSuspended
2278:                  USBTicksSinceSuspendEnd = 0;
000F8A  EF6824     CLR.B USBTicksSinceSuspendEnd
2279:               
2280:                  /*
2281:                   * At this point the PIC can go into sleep,idle, or
2282:                   * switch to a slower clock, etc.  This should be done in the
2283:                   * USBCBSuspend() if necessary.
2284:                   */
2285:                  USB_SUSPEND_HANDLER(EVENT_SUSPEND,0,0);
000F8C  EB0100     CLR W2
000F8E  EB0080     CLR W1
000F90  200750     MOV #0x75, W0
000F92  0705C5     RCALL USER_USB_CALLBACK_EVENT_HANDLER
2286:              }
000F94  FA8000     ULNK
000F96  060000     RETURN
2287:              
2288:              /********************************************************************
2289:               * Function:        void USBWakeFromSuspend(void)
2290:               *
2291:               * PreCondition:    None
2292:               *
2293:               * Input:           None
2294:               *
2295:               * Output:          None
2296:               *
2297:               * Side Effects:    None
2298:               *
2299:               * Overview:
2300:               *
2301:               * Note:            None
2302:               *******************************************************************/
2303:              static void USBWakeFromSuspend(void)
2304:              {
000F98  FA0000     LNK #0x0
2305:                  USBBusIsSuspended = false;
000F9A  EF6815     CLR.B USBBusIsSuspended
2306:              
2307:                  /*
2308:                   * If using clock switching, the place to restore the original
2309:                   * microcontroller core clock frequency is in the USBCBWakeFromSuspend() callback
2310:                   */
2311:                  USB_WAKEUP_FROM_SUSPEND_HANDLER(EVENT_RESUME,0,0);
000F9C  EB0100     CLR W2
000F9E  EB0080     CLR W1
000FA0  200740     MOV #0x74, W0
000FA2  0705BD     RCALL USER_USB_CALLBACK_EVENT_HANDLER
2312:              
2313:                  #if defined(__18CXX) || defined(_PIC14E) || defined(__XC8)
2314:                      //To avoid improperly clocking the USB module, make sure the oscillator
2315:                      //settings are consistent with USB operation before clearing the SUSPND bit.
2316:                      //Make sure the correct oscillator settings are selected in the 
2317:                      //"USB_WAKEUP_FROM_SUSPEND_HANDLER(EVENT_RESUME,0,0)" handler.
2318:                      U1CONbits.SUSPND = 0;   // Bring USB module out of power conserve
2319:                                              // mode.
2320:                  #endif
2321:              
2322:              
2323:                  USBActivityIE = 0;
000FA4  A98402     BCLR U1OTGIE, #4
2324:              
2325:                  /********************************************************************
2326:                  Bug Fix: Feb 26, 2007 v2.1
2327:                  *********************************************************************
2328:                  The ACTVIF bit cannot be cleared immediately after the USB module wakes
2329:                  up from Suspend or while the USB module is suspended. A few clock cycles
2330:                  are required to synchronize the internal hardware state machine before
2331:                  the ACTIVIF bit can be cleared by firmware. Clearing the ACTVIF bit
2332:                  before the internal hardware is synchronized may not have an effect on
2333:                  the value of ACTVIF. Additionally, if the USB module uses the clock from
2334:                  the 96 MHz PLL source, then after clearing the SUSPND bit, the USB
2335:                  module may not be immediately operational while waiting for the 96 MHz
2336:                  PLL to lock.
2337:                  ********************************************************************/
2338:              
2339:                  // UIRbits.ACTVIF = 0;                      // Removed
2340:                  #if defined(__18CXX) || defined(__XC8)
2341:                  while(USBActivityIF)
2342:                  #endif
2343:                  {
2344:                      USBClearInterruptFlag(USBActivityIFReg,USBActivityIFBitNum);
000FA6  200100     MOV #0x10, W0
000FA8  882000     MOV W0, U1OTGIR
2345:                  }  // Added
2346:              
2347:                  USBTicksSinceSuspendEnd = 0;
000FAA  EF6824     CLR.B USBTicksSinceSuspendEnd
2348:              
2349:              }//end USBWakeFromSuspend
000FAC  FA8000     ULNK
000FAE  060000     RETURN
2350:              
2351:              /********************************************************************
2352:               * Function:        void USBCtrlEPService(void)
2353:               *
2354:               * PreCondition:    USTAT is loaded with a valid endpoint address.
2355:               *
2356:               * Input:           None
2357:               *
2358:               * Output:          None
2359:               *
2360:               * Side Effects:    None
2361:               *
2362:               * Overview:        USBCtrlEPService checks for three transaction
2363:               *                  types that it knows how to service and services
2364:               *                  them:
2365:               *                  1. EP0 SETUP
2366:               *                  2. EP0 OUT
2367:               *                  3. EP0 IN
2368:               *                  It ignores all other types (i.e. EP1, EP2, etc.)
2369:               *
2370:               * Note:            None
2371:               *******************************************************************/
2372:              static void USBCtrlEPService(void)
2373:              {
000FB0  FA0000     LNK #0x0
2374:                  //If we get to here, that means a successful transaction has just occurred 
2375:                  //on EP0.  This means "progress" has occurred in the currently pending 
2376:                  //control transfer, so we should re-initialize our timeout counter.
2377:                  #if defined(USB_ENABLE_STATUS_STAGE_TIMEOUTS)
2378:                      USBStatusStageTimeoutCounter = USB_STATUS_STAGE_TIMEOUT;
000FB2  B3C2D0     MOV.B #0x2D, W0
000FB4  B7E819     MOV.B WREG, USBStatusStageTimeoutCounter
2379:                  #endif
2380:              	
2381:              	//Check if the last transaction was on EP0 OUT endpoint (of any kind, to either the even or odd buffer if ping pong buffers used)
2382:                  if((USTATcopy.Val & USTAT_EP0_PP_MASK) == USTAT_EP0_OUT_EVEN)
000FB6  BFC816     MOV.B USTATcopy, WREG
000FB8  FB8080     ZE W0, W1
000FBA  2FFFB0     MOV #0xFFFB, W0
000FBC  608000     AND W1, W0, W0
000FBE  E00000     CP0 W0
000FC0  3A001F     BRA NZ, .L119
2383:                  {
2384:              		//Point to the EP0 OUT buffer of the buffer that arrived
2385:                      #if defined (_PIC14E) || defined(__18CXX) || defined(__XC8)
2386:                          pBDTEntryEP0OutCurrent = (volatile BDT_ENTRY*)&BDT[(USTATcopy.Val & USTAT_EP_MASK)>>1];
2387:                      #elif defined(__C30__) || defined(__C32__) || defined __XC16__
2388:                          pBDTEntryEP0OutCurrent = (volatile BDT_ENTRY*)&BDT[(USTATcopy.Val & USTAT_EP_MASK)>>2];
000FC2  BFC816     MOV.B USTATcopy, WREG
000FC4  FB8000     ZE W0, W0
000FC6  DE0042     LSR W0, #2, W0
000FC8  784000     MOV.B W0, W0
000FCA  FB8000     ZE W0, W0
000FCC  DD00C2     SL W0, #2, W1
000FCE  20A000     MOV #0xA00, W0
000FD0  408000     ADD W1, W0, W0
000FD2  884020     MOV W0, pBDTEntryEP0OutCurrent
2389:                      #else
2390:                          #error "unimplemented"
2391:                      #endif
2392:              
2393:              		//Set the next out to the current out packet
2394:                      pBDTEntryEP0OutNext = pBDTEntryEP0OutCurrent;
000FD4  804020     MOV pBDTEntryEP0OutCurrent, W0
000FD6  884030     MOV W0, pBDTEntryEP0OutNext
2395:              		//Toggle it to the next ping pong buffer (if applicable)
2396:                      pBDTEntryEP0OutNext = (volatile BDT_ENTRY*)(((uintptr_t)pBDTEntryEP0OutNext) ^ USB_NEXT_EP0_OUT_PING_PONG);
000FD8  804030     MOV pBDTEntryEP0OutNext, W0
000FDA  A22000     BTG W0, #2
000FDC  884030     MOV W0, pBDTEntryEP0OutNext
2397:              
2398:              		//If the current EP0 OUT buffer has a SETUP packet
2399:                      if(pBDTEntryEP0OutCurrent->STAT.PID == PID_SETUP)
000FDE  804020     MOV pBDTEntryEP0OutCurrent, W0
000FE0  780090     MOV [W0], W1
000FE2  23C000     MOV #0x3C00, W0
000FE4  608080     AND W1, W0, W1
000FE6  234000     MOV #0x3400, W0
000FE8  508F80     SUB W1, W0, [W15]
000FEA  3A0008     BRA NZ, .L120
2400:                      {
2401:              	        //The SETUP transaction data may have gone into the the CtrlTrfData 
2402:              	        //buffer, or elsewhere, depending upon how the BDT was prepared
2403:              	        //before the transaction.  Therefore, we should copy the data to the 
2404:              	        //SetupPkt buffer so it can be processed correctly by USBCtrlTrfSetupHandler().		    
2405:                          memcpy((uint8_t*)&SetupPkt, (uint8_t*)ConvertToVirtualAddress(pBDTEntryEP0OutCurrent->ADR), 8);
000FEC  804020     MOV pBDTEntryEP0OutCurrent, W0
000FEE  900010     MOV [W0+2], W0
000FF0  200082     MOV #0x8, W2
000FF2  780080     MOV W0, W1
000FF4  208500     MOV #0x850, W0
000FF6  07F9D6     RCALL _memcpy
2406:              
2407:              			//Handle the control transfer (parse the 8-byte SETUP command and figure out what to do)
2408:                          USBCtrlTrfSetupHandler();
000FF8  07000C     RCALL _USBCtrlTrfSetupHandler, .LFE20, .LFB21
000FFA  370009     BRA .L118
2409:                      }
2410:                      else
2411:                      {
2412:              			//Handle the DATA transfer
2413:                          USBCtrlTrfOutHandler();
000FFC  07003E     RCALL _USBCtrlTrfOutHandler, .LFE21, .LFB22
000FFE  370007     BRA .L118
2414:                      }
2415:                  }
2416:                  else if((USTATcopy.Val & USTAT_EP0_PP_MASK) == USTAT_EP0_IN)
001000  BFC816     MOV.B USTATcopy, WREG
001002  FB8080     ZE W0, W1
001004  2FFFB0     MOV #0xFFFB, W0
001006  608000     AND W1, W0, W0
001008  500FE8     SUB W0, #0x8, [W15]
00100A  3A0001     BRA NZ, .L118
2417:                  {
2418:              		//Otherwise the transmission was and EP0 IN
2419:              		//  so take care of the IN transfer
2420:                      USBCtrlTrfInHandler();
00100C  070053     RCALL _USBCtrlTrfInHandler, .LFE22, .LFB23
2421:                  }
2422:              
2423:              }//end USBCtrlEPService
00100E  FA8000     ULNK
001010  060000     RETURN
2424:              
2425:              /********************************************************************
2426:               * Function:        void USBCtrlTrfSetupHandler(void)
2427:               *
2428:               * PreCondition:    SetupPkt buffer is loaded with valid USB Setup Data
2429:               *
2430:               * Input:           None
2431:               *
2432:               * Output:          None
2433:               *
2434:               * Side Effects:    None
2435:               *
2436:               * Overview:        This routine is a task dispatcher and has 3 stages.
2437:               *                  1. It initializes the control transfer state machine.
2438:               *                  2. It calls on each of the module that may know how to
2439:               *                     service the Setup Request from the host.
2440:               *                     Module Example: USBD, HID, CDC, MSD, ...
2441:               *                     A callback function, USBCBCheckOtherReq(),
2442:               *                     is required to call other module handlers.
2443:               *                  3. Once each of the modules has had a chance to check if
2444:               *                     it is responsible for servicing the request, stage 3
2445:               *                     then checks direction of the transfer to determine how
2446:               *                     to prepare EP0 for the control transfer.
2447:               *                     Refer to USBCtrlEPServiceComplete() for more details.
2448:               *
2449:               * Note:            Microchip USB Firmware has three different states for
2450:               *                  the control transfer state machine:
2451:               *                  1. WAIT_SETUP
2452:               *                  2. CTRL_TRF_TX (device sends data to host through IN transactions)
2453:               *                  3. CTRL_TRF_RX (device receives data from host through OUT transactions)
2454:               *                  Refer to firmware manual to find out how one state
2455:               *                  is transitioned to another.
2456:               *
2457:               *                  A Control Transfer is composed of many USB transactions.
2458:               *                  When transferring data over multiple transactions,
2459:               *                  it is important to keep track of data source, data
2460:               *                  destination, and data count. These three parameters are
2461:               *                  stored in pSrc,pDst, and wCount. A flag is used to
2462:               *                  note if the data source is from const or RAM.
2463:               *
2464:               *******************************************************************/
2465:              static void USBCtrlTrfSetupHandler(void)
2466:              {
001012  FA0000     LNK #0x0
2467:                  //--------------------------------------------------------------------------
2468:                  //1. Re-initialize state tracking variables related to control transfers.
2469:                  //--------------------------------------------------------------------------
2470:                  shortPacketStatus = SHORT_PKT_NOT_USED;  
001014  EF6810     CLR.B shortPacketStatus
2471:                  USBDeferStatusStagePacket = false;
001016  EF681A     CLR.B USBDeferStatusStagePacket
2472:                  USBDeferINDataStagePackets = false;
001018  EF681D     CLR.B USBDeferINDataStagePackets
2473:                  USBDeferOUTDataStagePackets = false;
00101A  EF681E     CLR.B USBDeferOUTDataStagePackets
2474:                  BothEP0OutUOWNsSet = false;
00101C  EF6818     CLR.B BothEP0OutUOWNsSet
2475:                  controlTransferState = WAIT_SETUP;
00101E  EF6811     CLR.B controlTransferState
2476:              
2477:                  //Abandon any previous control transfers that might have been using EP0.
2478:                  //Ordinarily, nothing actually needs abandoning, since the previous control
2479:                  //transfer would have completed successfully prior to the host sending the next
2480:                  //SETUP packet.  However, in a timeout error case, or after an EP0 STALL event,
2481:                  //one or more UOWN bits might still be set.  If so, we should clear the UOWN bits,
2482:                  //so the EP0 IN/OUT endpoints are in a known inactive state, ready for re-arming
2483:                  //by the class request handler that will be called next.
2484:                  pBDTEntryIn[0]->STAT.Val &= ~(_USIE);  
001020  804060     MOV pBDTEntryIn, W0
001022  804061     MOV pBDTEntryIn, W1
001024  904091     MOV.B [W1+1], W1
001026  A17401     BCLR.B W1, #7
001028  984011     MOV.B W1, [W0+1]
2485:                  
2486:                  pBDTEntryIn[0] = (volatile BDT_ENTRY*)(((uintptr_t)pBDTEntryIn[0]) ^ USB_NEXT_EP0_IN_PING_PONG);
00102A  804060     MOV pBDTEntryIn, W0
00102C  A22000     BTG W0, #2
00102E  884060     MOV W0, pBDTEntryIn
2487:                  pBDTEntryIn[0]->STAT.Val &= ~(_USIE);      
001030  804060     MOV pBDTEntryIn, W0
001032  804061     MOV pBDTEntryIn, W1
001034  904091     MOV.B [W1+1], W1
001036  A17401     BCLR.B W1, #7
001038  984011     MOV.B W1, [W0+1]
2488:                  pBDTEntryIn[0] = (volatile BDT_ENTRY*)(((uintptr_t)pBDTEntryIn[0]) ^ USB_NEXT_EP0_IN_PING_PONG);
00103A  804060     MOV pBDTEntryIn, W0
00103C  A22000     BTG W0, #2
00103E  884060     MOV W0, pBDTEntryIn
2489:                  pBDTEntryEP0OutNext->STAT.Val &= ~(_USIE);         
001040  804030     MOV pBDTEntryEP0OutNext, W0
001042  804031     MOV pBDTEntryEP0OutNext, W1
001044  904091     MOV.B [W1+1], W1
001046  A17401     BCLR.B W1, #7
001048  984011     MOV.B W1, [W0+1]
2490:              
2491:                  inPipes[0].info.Val = 0;
00104A  208400     MOV #0x840, W0
00104C  EB4080     CLR.B W1
00104E  784801     MOV.B W1, [W0]
2492:                  inPipes[0].wCount.Val = 0;
001050  EB0000     CLR W0
001052  884210     MOV W0, 0x842
2493:                  outPipes[0].info.Val = 0;
001054  208460     MOV #0x846, W0
001056  EB4080     CLR.B W1
001058  784801     MOV.B W1, [W0]
2494:                  outPipes[0].wCount.Val = 0;
00105A  804231     MOV 0x846, W1
00105C  200FF0     MOV #0xFF, W0
00105E  608000     AND W1, W0, W0
001060  884230     MOV W0, 0x846
001062  804241     MOV 0x848, W1
001064  2FF000     MOV #0xFF00, W0
001066  608000     AND W1, W0, W0
001068  884240     MOV W0, 0x848
2495:                  
2496:              
2497:                  //--------------------------------------------------------------------------
2498:                  //2. Now find out what was in the SETUP packet, and begin handling the request.
2499:                  //--------------------------------------------------------------------------
2500:                  USBCheckStdRequest();                                               //Check for standard USB "Chapter 9" requests.
00106A  070084     RCALL _USBCheckStdRequest, .LFE23, .LFB24
2501:                  USB_NONSTANDARD_EP0_REQUEST_HANDLER(EVENT_EP0_REQUEST,0,0); //Check for USB device class specific requests
00106C  EB0100     CLR W2
00106E  EB0080     CLR W1
001070  200030     MOV #0x3, W0
001072  070555     RCALL USER_USB_CALLBACK_EVENT_HANDLER
2502:              
2503:              
2504:                  //--------------------------------------------------------------------------
2505:                  //3. Re-arm EP0 IN and EP0 OUT endpoints, based on the control transfer in 
2506:                  //   progress.  If one of the above handlers (in step 2) knew how to process
2507:                  //   the request, it will have set one of the inPipes[0].info.bits.busy or
2508:                  //   outPipes[0].info.bits.busy flags = 1.  This lets the
2509:                  //   USBCtrlEPServiceComplete() function know how and which endpoints to 
2510:                  //   arm.  If both info.bits.busy flags are = 0, then no one knew how to
2511:                  //   process the request.  In this case, the default behavior will be to
2512:                  //   perform protocol STALL on EP0.
2513:                  //-------------------------------------------------------------------------- 
2514:                  USBCtrlEPServiceComplete();
001074  07FD56     RCALL _USBCtrlEPServiceComplete, .LFE10, .LFB11
2515:              }//end USBCtrlTrfSetupHandler
001076  FA8000     ULNK
001078  060000     RETURN
2516:              
2517:              
2518:              /******************************************************************************
2519:               * Function:        void USBCtrlTrfOutHandler(void)
2520:               *
2521:               * PreCondition:    None
2522:               *
2523:               * Input:           None
2524:               *
2525:               * Output:          None
2526:               *
2527:               * Side Effects:    None
2528:               *
2529:               * Overview:        This routine handles an OUT transaction according to
2530:               *                  which control transfer state is currently active.
2531:               *
2532:               * Note:            Note that if the the control transfer was from
2533:               *                  host to device, the session owner should be notified
2534:               *                  at the end of each OUT transaction to service the
2535:               *                  received data.
2536:               *
2537:               *****************************************************************************/
2538:              static void USBCtrlTrfOutHandler(void)
2539:              {
00107A  FA0000     LNK #0x0
2540:                  if(controlTransferState == CTRL_TRF_RX)
00107C  BFC811     MOV.B controlTransferState, WREG
00107E  504FE2     SUB.B W0, #0x2, [W15]
001080  3A0002     BRA NZ, .L124
2541:                  {
2542:                      USBCtrlTrfRxService();	//Copies the newly received data into the appropriate buffer and configures EP0 OUT for next transaction.
001082  07FDE6     RCALL _USBCtrlTrfRxService, .LFE12, .LFB13
001084  370015     BRA .L123
2543:                  }
2544:                  else //In this case the last OUT transaction must have been a status stage of a CTRL_TRF_TX (<setup><in><in>...<OUT>  <-- this last OUT just occurred as the status stage)
2545:                  {
2546:                      //If the status stage is complete, this means we are done with the 
2547:                      //control transfer.  Go back to the idle "WAIT_SETUP" state.
2548:                      controlTransferState = WAIT_SETUP;
001086  EF6811     CLR.B controlTransferState
2549:              
2550:                      //Prepare EP0 OUT for the next SETUP transaction, however, it may have
2551:                      //already been prepared if ping-pong buffering was enabled on EP0 OUT,
2552:                      //and the last control transfer was of direction: device to host, see
2553:                      //USBCtrlEPServiceComplete().  If it was already prepared, do not want
2554:                      //to do anything to the BDT.
2555:                      if(BothEP0OutUOWNsSet == false)
001088  BFC818     MOV.B BothEP0OutUOWNsSet, WREG
00108A  A20400     BTG.B W0, #0
00108C  E00400     CP0.B W0
00108E  32000F     BRA Z, .L126
2556:                      {
2557:                          pBDTEntryEP0OutNext->CNT = USB_EP0_BUFF_SIZE;
001090  804030     MOV pBDTEntryEP0OutNext, W0
001092  B3C081     MOV.B #0x8, W1
001094  784801     MOV.B W1, [W0]
2558:                          pBDTEntryEP0OutNext->ADR = ConvertToPhysicalAddress(&SetupPkt);
001096  804030     MOV pBDTEntryEP0OutNext, W0
001098  208501     MOV #0x850, W1
00109A  980011     MOV W1, [W0+2]
2559:                          pBDTEntryEP0OutNext->STAT.Val = _DAT0|(_DTSEN & _DTS_CHECKING_ENABLED)|_BSTALL;
00109C  804030     MOV pBDTEntryEP0OutNext, W0
00109E  B3C0C1     MOV.B #0xC, W1
0010A0  984011     MOV.B W1, [W0+1]
2560:                          pBDTEntryEP0OutNext->STAT.Val |= _USIE;
0010A2  804030     MOV pBDTEntryEP0OutNext, W0
0010A4  804031     MOV pBDTEntryEP0OutNext, W1
0010A6  904091     MOV.B [W1+1], W1
0010A8  A07401     BSET.B W1, #7
0010AA  984011     MOV.B W1, [W0+1]
0010AC  370001     BRA .L123
2561:                      }
2562:                      else
2563:                      {
2564:                              BothEP0OutUOWNsSet = false;
0010AE  EF6818     CLR.B BothEP0OutUOWNsSet
2565:                      }
2566:                  }
2567:              }
0010B0  FA8000     ULNK
0010B2  060000     RETURN
2568:              
2569:              /******************************************************************************
2570:               * Function:        void USBCtrlTrfInHandler(void)
2571:               *
2572:               * PreCondition:    None
2573:               *
2574:               * Input:           None
2575:               *
2576:               * Output:          None
2577:               *
2578:               * Side Effects:    None
2579:               *
2580:               * Overview:        This routine handles an IN transaction according to
2581:               *                  which control transfer state is currently active.
2582:               *
2583:               * Note:            A Set Address Request must not change the actual address
2584:               *                  of the device until the completion of the control
2585:               *                  transfer. The end of the control transfer for Set Address
2586:               *                  Request is an IN transaction. Therefore it is necessary
2587:               *                  to service this unique situation when the condition is
2588:               *                  right. Macro mUSBCheckAdrPendingState is defined in
2589:               *                  usb9.h and its function is to specifically service this
2590:               *                  event.
2591:               *****************************************************************************/
2592:              static void USBCtrlTrfInHandler(void)
2593:              {
0010B4  FA0002     LNK #0x2
2594:                  uint8_t lastDTS;
2595:              
2596:                  lastDTS = pBDTEntryIn[0]->STAT.DTS;
0010B6  804060     MOV pBDTEntryIn, W0
0010B8  780010     MOV [W0], W0
0010BA  DE004E     LSR W0, #14, W0
0010BC  604061     AND.B W0, #0x1, W0
0010BE  784F00     MOV.B W0, [W14]
2597:              
2598:                  //switch to the next ping pong buffer
2599:                  pBDTEntryIn[0] = (volatile BDT_ENTRY*)(((uintptr_t)pBDTEntryIn[0]) ^ USB_NEXT_EP0_IN_PING_PONG);
0010C0  804060     MOV pBDTEntryIn, W0
0010C2  A22000     BTG W0, #2
0010C4  884060     MOV W0, pBDTEntryIn
2600:              
2601:                  //Must check if in ADR_PENDING_STATE.  If so, we need to update the address
2602:                  //now, since the IN status stage of the (set address) control transfer has 
2603:                  //evidently completed successfully.
2604:                  if(USBDeviceState == ADR_PENDING_STATE)
0010C6  804000     MOV USBDeviceState, W0
0010C8  500FE8     SUB W0, #0x8, [W15]
0010CA  3A000E     BRA NZ, .L128
2605:                  {
2606:                      U1ADDR = (SetupPkt.bDevADR & 0x7F);
0010CC  208520     MOV #0x852, W0
0010CE  784010     MOV.B [W0], W0
0010D0  FB8080     ZE W0, W1
0010D2  2007F0     MOV #0x7F, W0
0010D4  608000     AND W1, W0, W0
0010D6  8820B0     MOV W0, U1ADDR
2607:                      if(U1ADDR != 0u)
0010D8  8020B0     MOV U1ADDR, W0
0010DA  E00000     CP0 W0
0010DC  320003     BRA Z, .L129
2608:                      {
2609:                          USBDeviceState=ADDRESS_STATE;
0010DE  200100     MOV #0x10, W0
0010E0  884000     MOV W0, USBDeviceState
0010E2  370002     BRA .L128
2610:                      }
2611:                      else
2612:                      {
2613:                          USBDeviceState=DEFAULT_STATE;
0010E4  200040     MOV #0x4, W0
0010E6  884000     MOV W0, USBDeviceState
2614:                      }
2615:                  }//end if
2616:              
2617:              
2618:                  if(controlTransferState == CTRL_TRF_TX)
0010E8  BFC811     MOV.B controlTransferState, WREG
0010EA  504FE1     SUB.B W0, #0x1, [W15]
0010EC  3A0025     BRA NZ, .L130
2619:                  {
2620:                      pBDTEntryIn[0]->ADR = ConvertToPhysicalAddress(CtrlTrfData);
0010EE  804060     MOV pBDTEntryIn, W0
0010F0  208581     MOV #0x858, W1
0010F2  980011     MOV W1, [W0+2]
2621:                      USBCtrlTrfTxService();
0010F4  07FD72     RCALL _USBCtrlTrfTxService, .LFE11, .LFB12
2622:              
2623:                      //Check if we have already sent a short packet.  If so, configure
2624:                      //the endpoint to STALL in response to any further IN tokens (in the
2625:                      //case that the host erroneously tries to receive more data than it
2626:                      //should).
2627:                      if(shortPacketStatus == SHORT_PKT_SENT)
0010F6  BFC810     MOV.B shortPacketStatus, WREG
0010F8  504FE2     SUB.B W0, #0x2, [W15]
0010FA  3A0009     BRA NZ, .L131
2628:                      {
2629:                          // If a short packet has been sent, don't want to send any more,
2630:                          // stall next time if host is still trying to read.
2631:                          pBDTEntryIn[0]->STAT.Val = _BSTALL;
0010FC  804060     MOV pBDTEntryIn, W0
0010FE  B3C041     MOV.B #0x4, W1
001100  984011     MOV.B W1, [W0+1]
2632:                          pBDTEntryIn[0]->STAT.Val |= _USIE;
001102  804060     MOV pBDTEntryIn, W0
001104  804061     MOV pBDTEntryIn, W1
001106  904091     MOV.B [W1+1], W1
001108  A07401     BSET.B W1, #7
00110A  984011     MOV.B W1, [W0+1]
00110C  370031     BRA .L127
2633:                      }
2634:                      else
2635:                      {
2636:                          if(lastDTS == 0)
00110E  78401E     MOV.B [W14], W0
001110  E00400     CP0.B W0
001112  3A0009     BRA NZ, .L133
2637:                          {
2638:                              pBDTEntryIn[0]->STAT.Val = _DAT1|(_DTSEN & _DTS_CHECKING_ENABLED);
001114  804060     MOV pBDTEntryIn, W0
001116  B3C481     MOV.B #0x48, W1
001118  984011     MOV.B W1, [W0+1]
2639:                              pBDTEntryIn[0]->STAT.Val |= _USIE;
00111A  804060     MOV pBDTEntryIn, W0
00111C  804061     MOV pBDTEntryIn, W1
00111E  904091     MOV.B [W1+1], W1
001120  A07401     BSET.B W1, #7
001122  984011     MOV.B W1, [W0+1]
001124  370025     BRA .L127
2640:                          }
2641:                          else
2642:                          {
2643:                              pBDTEntryIn[0]->STAT.Val = _DAT0|(_DTSEN & _DTS_CHECKING_ENABLED);
001126  804060     MOV pBDTEntryIn, W0
001128  B3C081     MOV.B #0x8, W1
00112A  984011     MOV.B W1, [W0+1]
2644:                              pBDTEntryIn[0]->STAT.Val |= _USIE;
00112C  804060     MOV pBDTEntryIn, W0
00112E  804061     MOV pBDTEntryIn, W1
001130  904091     MOV.B [W1+1], W1
001132  A07401     BSET.B W1, #7
001134  984011     MOV.B W1, [W0+1]
001136  37001C     BRA .L127
2645:                          }
2646:                      }//end if(...)else
2647:                  }
2648:              	else // must have been a CTRL_TRF_RX status stage IN packet (<setup><out><out>...<IN>  <-- this last IN just occurred as the status stage)
2649:              	{
2650:                      //if someone is still expecting data from the control transfer
2651:                      //  then make sure to terminate that request and let them know that
2652:                      //  they are done
2653:                      if(outPipes[0].info.bits.busy == 1)
001138  208460     MOV #0x846, W0
00113A  784090     MOV.B [W0], W1
00113C  B3C800     MOV.B #0x80, W0
00113E  60C000     AND.B W1, W0, W0
001140  E00400     CP0.B W0
001142  320015     BRA Z, .L134
2654:                      {
2655:                          if(outPipes[0].pFunc != NULL)
001144  804240     MOV 0x848, W0
001146  DE0048     LSR W0, #8, W0
001148  804252     MOV 0x84A, W2
00114A  200FF1     MOV #0xFF, W1
00114C  610081     AND W2, W1, W1
00114E  DD08C8     SL W1, #8, W1
001150  700001     IOR W0, W1, W0
001152  E00000     CP0 W0
001154  320008     BRA Z, .L135
2656:                          {
2657:                              outPipes[0].pFunc();
001156  804240     MOV 0x848, W0
001158  DE0048     LSR W0, #8, W0
00115A  804252     MOV 0x84A, W2
00115C  200FF1     MOV #0xFF, W1
00115E  610081     AND W2, W1, W1
001160  DD08C8     SL W1, #8, W1
001162  700001     IOR W0, W1, W0
001164  010000     CALL W0
2658:                          }
2659:                          outPipes[0].info.bits.busy = 0;
001166  804231     MOV 0x846, W1
001168  2FF7F0     MOV #0xFF7F, W0
00116A  608000     AND W1, W0, W0
00116C  884230     MOV W0, 0x846
2660:                      }
2661:                  	
2662:                      controlTransferState = WAIT_SETUP;
00116E  EF6811     CLR.B controlTransferState
2663:                      //Don't need to arm EP0 OUT here.  It was already armed by the last <out> that
2664:                      //got processed by the USBCtrlTrfRxService() handler.
2665:              	}	
2666:              
2667:              }
001170  FA8000     ULNK
001172  060000     RETURN
2668:              
2669:              
2670:              /********************************************************************
2671:               * Function:        void USBCheckStdRequest(void)
2672:               *
2673:               * PreCondition:    None
2674:               *
2675:               * Input:           None
2676:               *
2677:               * Output:          None
2678:               *
2679:               * Side Effects:    None
2680:               *
2681:               * Overview:        This routine checks the setup data packet to see
2682:               *                  if it knows how to handle it
2683:               *
2684:               * Note:            None
2685:               *******************************************************************/
2686:              static void USBCheckStdRequest(void)
2687:              {
001174  FA0000     LNK #0x0
2688:                  if(SetupPkt.RequestType != USB_SETUP_TYPE_STANDARD_BITFIELD) return;
001176  208500     MOV #0x850, W0
001178  784010     MOV.B [W0], W0
00117A  B24600     AND.B #0x60, W0
00117C  E00400     CP0.B W0
00117E  3A0051     BRA NZ, .L150
001222  000000     NOP
001224  370003     BRA .L136
2689:              
2690:                  switch(SetupPkt.bRequest)
001180  208510     MOV #0x851, W0
001182  784010     MOV.B [W0], W0
001184  FB8000     ZE W0, W0
001186  DE80CF     ASR W0, #15, W1
001188  2000B2     MOV #0xB, W2
00118A  200003     MOV #0x0, W3
00118C  500F82     SUB W0, W2, [W15]
00118E  588F83     SUBB W1, W3, [W15]
001190  3E004A     BRA GTU, .L151
001192  016000     BRA W0
001194  370021     BRA .L140
001196  370022     BRA .L141
001198  370048     BRA .L152
00119A  370020     BRA .L141
00119C  370046     BRA .L152
00119E  370006     BRA .L142
0011A0  37000B     BRA .L143
0011A2  37003A     BRA .L144
0011A4  37000D     BRA .L145
0011A6  37000A     BRA .L146
0011A8  37001B     BRA .L147
0011AA  37002A     BRA .L148
2691:                  {
2692:                      case USB_REQUEST_SET_ADDRESS:
2693:                          inPipes[0].info.bits.busy = 1;            // This will generate a zero length packet
0011AC  804200     MOV 0x840, W0
0011AE  A07000     BSET W0, #7
0011B0  884200     MOV W0, 0x840
2694:                          USBDeviceState = ADR_PENDING_STATE;       // Update state only
0011B2  200080     MOV #0x8, W0
0011B4  884000     MOV W0, USBDeviceState
2695:                          /* See USBCtrlTrfInHandler() for the next step */
2696:                          break;
0011B6  37003A     BRA .L136
2697:                      case USB_REQUEST_GET_DESCRIPTOR:
2698:                          USBStdGetDscHandler();
0011B8  07FE17     RCALL _USBStdGetDscHandler, .LFE14, .LFB15
2699:                          break;
0011BA  370038     BRA .L136
2700:                      case USB_REQUEST_SET_CONFIGURATION:
2701:                          USBStdSetCfgHandler();
0011BC  07FDDB     RCALL _USBStdSetCfgHandler, .LFE13, .LFB14
2702:                          break;
0011BE  370036     BRA .L136
2703:                      case USB_REQUEST_GET_CONFIGURATION:
2704:                          inPipes[0].pSrc.bRam = (uint8_t*)&USBActiveConfiguration;         // Set Source
0011C0  208020     MOV #0x802, W0
0011C2  8841F0     MOV W0, inPipes
2705:                          inPipes[0].info.bits.ctrl_trf_mem = USB_EP0_RAM;               // Set memory type
0011C4  804200     MOV 0x840, W0
0011C6  A00000     BSET W0, #0
0011C8  884200     MOV W0, 0x840
2706:                          inPipes[0].wCount.v[0] = 1;                         // Set data count
0011CA  208420     MOV #0x842, W0
0011CC  B3C011     MOV.B #0x1, W1
0011CE  784801     MOV.B W1, [W0]
2707:                          inPipes[0].info.bits.busy = 1;
0011D0  804200     MOV 0x840, W0
0011D2  A07000     BSET W0, #7
0011D4  884200     MOV W0, 0x840
2708:                          break;
0011D6  37002A     BRA .L136
2709:                      case USB_REQUEST_GET_STATUS:
2710:                          USBStdGetStatusHandler();
0011D8  07FE56     RCALL _USBStdGetStatusHandler, .LFE15, .LFB16
2711:                          break;
0011DA  370028     BRA .L136
2712:                      case USB_REQUEST_CLEAR_FEATURE:
2713:                      case USB_REQUEST_SET_FEATURE:
2714:                          USBStdFeatureReqHandler();
0011DC  070029     RCALL _USBStdFeatureReqHandler, .LFE24, .LFB25
2715:                          break;
0011DE  370026     BRA .L136
2716:                      case USB_REQUEST_GET_INTERFACE:
2717:                          inPipes[0].pSrc.bRam = (uint8_t*)&USBAlternateInterface[SetupPkt.bIntfID];  // Set source
0011E0  208540     MOV #0x854, W0
0011E2  784010     MOV.B [W0], W0
0011E4  FB8080     ZE W0, W1
0011E6  208030     MOV #0x803, W0
0011E8  408000     ADD W1, W0, W0
0011EA  8841F0     MOV W0, inPipes
2718:                          inPipes[0].info.bits.ctrl_trf_mem = USB_EP0_RAM;               // Set memory type
0011EC  804200     MOV 0x840, W0
0011EE  A00000     BSET W0, #0
0011F0  884200     MOV W0, 0x840
2719:                          inPipes[0].wCount.v[0] = 1;                         // Set data count
0011F2  208420     MOV #0x842, W0
0011F4  B3C011     MOV.B #0x1, W1
0011F6  784801     MOV.B W1, [W0]
2720:                          inPipes[0].info.bits.busy = 1;
0011F8  804200     MOV 0x840, W0
0011FA  A07000     BSET W0, #7
0011FC  884200     MOV W0, 0x840
2721:                          break;
0011FE  370016     BRA .L136
2722:                      case USB_REQUEST_SET_INTERFACE:
2723:                          inPipes[0].info.bits.busy = 1;
001200  804200     MOV 0x840, W0
001202  A07000     BSET W0, #7
001204  884200     MOV W0, 0x840
2724:                          USBAlternateInterface[SetupPkt.bIntfID] = SetupPkt.bAltID;
001206  208540     MOV #0x854, W0
001208  784010     MOV.B [W0], W0
00120A  FB8100     ZE W0, W2
00120C  208520     MOV #0x852, W0
00120E  784090     MOV.B [W0], W1
001210  208030     MOV #0x803, W0
001212  410000     ADD W2, W0, W0
001214  784801     MOV.B W1, [W0]
2725:                          break;
001216  37000A     BRA .L136
2726:                      case USB_REQUEST_SET_DESCRIPTOR:
2727:                          USB_SET_DESCRIPTOR_HANDLER(EVENT_SET_DESCRIPTOR,0,0);
001218  EB0100     CLR W2
00121A  EB0080     CLR W1
00121C  200020     MOV #0x2, W0
00121E  07047F     RCALL USER_USB_CALLBACK_EVENT_HANDLER
2728:                          break;
001220  370005     BRA .L136
2729:                      case USB_REQUEST_SYNCH_FRAME:
2730:                      default:
2731:                          break;
001226  000000     NOP
001228  370001     BRA .L136
00122A  000000     NOP
2732:                  }//end switch
2733:              }//end USBCheckStdRequest
00122C  FA8000     ULNK
00122E  060000     RETURN
2734:              
2735:              /********************************************************************
2736:               * Function:        void USBStdFeatureReqHandler(void)
2737:               *
2738:               * PreCondition:    None
2739:               *
2740:               * Input:           None
2741:               *
2742:               * Output:          Can alter BDT entries.  Can also modify USB stack
2743:               *                  Maintained variables.
2744:               *
2745:               * Side Effects:    None
2746:               *
2747:               * Overview:        This routine handles the standard SET & CLEAR
2748:               *                  FEATURES requests
2749:               *
2750:               * Note:            This is a private function, intended for internal 
2751:               *                  use by the USB stack, when processing SET/CLEAR
2752:               *                  feature requests.  
2753:               *******************************************************************/
2754:              static void USBStdFeatureReqHandler(void)
2755:              {
001230  FA0006     LNK #0x6
2756:                  BDT_ENTRY *p;
2757:                  EP_STATUS current_ep_data;
2758:                  #if defined(__C32__)
2759:                      uint32_t* pUEP;
2760:                  #else
2761:                      unsigned char* pUEP;             
2762:                  #endif
2763:                  
2764:              
2765:                  #ifdef	USB_SUPPORT_OTG
2766:                  //Check for USB On-The-Go (OTG) specific requests
2767:                  if ((SetupPkt.bFeature == OTG_FEATURE_B_HNP_ENABLE)&&
2768:                      (SetupPkt.Recipient == USB_SETUP_RECIPIENT_DEVICE_BITFIELD))
2769:                  {  
2770:                      inPipes[0].info.bits.busy = 1;
2771:                      if(SetupPkt.bRequest == USB_REQUEST_SET_FEATURE)
2772:                          USBOTGEnableHnp();
2773:                      else
2774:                          USBOTGDisableHnp();
2775:                  }
2776:              
2777:                  if ((SetupPkt.bFeature == OTG_FEATURE_A_HNP_SUPPORT)&&
2778:                      (SetupPkt.Recipient == USB_SETUP_RECIPIENT_DEVICE_BITFIELD))
2779:                  {
2780:                      inPipes[0].info.bits.busy = 1;
2781:                      if(SetupPkt.bRequest == USB_REQUEST_SET_FEATURE)
2782:                          USBOTGEnableSupportHnp();
2783:                      else
2784:                          USBOTGDisableSupportHnp();
2785:                  }
2786:              
2787:                  if ((SetupPkt.bFeature == OTG_FEATURE_A_ALT_HNP_SUPPORT)&&
2788:                      (SetupPkt.Recipient == USB_SETUP_RECIPIENT_DEVICE_BITFIELD))
2789:                  {
2790:                      inPipes[0].info.bits.busy = 1;
2791:                      if(SetupPkt.bRequest == USB_REQUEST_SET_FEATURE)
2792:                          USBOTGEnableAltHnp();
2793:                      else
2794:                          USBOTGDisableAltHnp();
2795:                  }
2796:                  #endif   //#ifdef USB_SUPPORT_OTG 
2797:              
2798:                  //Check if the host sent a valid SET or CLEAR feature (remote wakeup) request.
2799:                  if((SetupPkt.bFeature == USB_FEATURE_DEVICE_REMOTE_WAKEUP)&&
001232  208520     MOV #0x852, W0
001234  784010     MOV.B [W0], W0
001236  504FE1     SUB.B W0, #0x1, [W15]
001238  3A0010     BRA NZ, .L154
001240  E00400     CP0.B W0
001242  3A000B     BRA NZ, .L154
2800:                     (SetupPkt.Recipient == USB_SETUP_RECIPIENT_DEVICE_BITFIELD))
00123A  208500     MOV #0x850, W0
00123C  784010     MOV.B [W0], W0
00123E  60407F     AND.B W0, #0x1F, W0
2801:                  {
2802:                      inPipes[0].info.bits.busy = 1;
001244  804200     MOV 0x840, W0
001246  A07000     BSET W0, #7
001248  884200     MOV W0, 0x840
2803:                      if(SetupPkt.bRequest == USB_REQUEST_SET_FEATURE)
00124A  208510     MOV #0x851, W0
00124C  784010     MOV.B [W0], W0
00124E  504FE3     SUB.B W0, #0x3, [W15]
001250  3A0003     BRA NZ, .L155
2804:                          RemoteWakeup = true;
001252  B3C010     MOV.B #0x1, W0
001254  B7E814     MOV.B WREG, RemoteWakeup
001256  370001     BRA .L154
2805:                      else
2806:                          RemoteWakeup = false;
001258  EF6814     CLR.B RemoteWakeup
2807:                  }//end if
2808:              
2809:                  //Check if the host sent a valid SET or CLEAR endpoint halt request.
2810:                  if((SetupPkt.bFeature == USB_FEATURE_ENDPOINT_HALT)&&
00125A  208520     MOV #0x852, W0
00125C  784010     MOV.B [W0], W0
00125E  E00400     CP0.B W0
001260  3A00FA     BRA NZ, .L153
001268  504FE2     SUB.B W0, #0x2, [W15]
00126A  3A00F5     BRA NZ, .L153
2811:                     (SetupPkt.Recipient == USB_SETUP_RECIPIENT_ENDPOINT_BITFIELD)&&
001262  208500     MOV #0x850, W0
001264  784010     MOV.B [W0], W0
001266  60407F     AND.B W0, #0x1F, W0
001272  E00400     CP0.B W0
001274  3200F0     BRA Z, .L153
2812:                     (SetupPkt.EPNum != 0) && (SetupPkt.EPNum <= USB_MAX_EP_NUMBER)&&
00126C  208540     MOV #0x854, W0
00126E  784010     MOV.B [W0], W0
001270  60406F     AND.B W0, #0xF, W0
001276  208540     MOV #0x854, W0
001278  784090     MOV.B [W0], W1
00127A  60C06F     AND.B W1, #0xF, W0
00127C  FB8000     ZE W0, W0
00127E  500FE1     SUB W0, #0x1, [W15]
001280  3C00EA     BRA GT, .L153
001284  200200     MOV #0x20, W0
001286  508F80     SUB W1, W0, [W15]
001288  3A00E6     BRA NZ, .L153
2813:                     (USBDeviceState == CONFIGURED_STATE))
001282  804001     MOV USBDeviceState, W1
2814:                  {
2815:              		//The request was valid.  Take control of the control transfer and
2816:              		//perform the host requested action.
2817:              		inPipes[0].info.bits.busy = 1;
00128A  804200     MOV 0x840, W0
00128C  A07000     BSET W0, #7
00128E  884200     MOV W0, 0x840
2818:              
2819:                      //Fetch a pointer to the BDT that the host wants to SET/CLEAR halt on.
2820:                      if(SetupPkt.EPDir == OUT_FROM_HOST)
001290  208540     MOV #0x854, W0
001292  784090     MOV.B [W0], W1
001294  B3C800     MOV.B #0x80, W0
001296  60C000     AND.B W1, W0, W0
001298  E00400     CP0.B W0
00129A  3A0011     BRA NZ, .L157
2821:                      {
2822:                          p = (BDT_ENTRY*)pBDTEntryOut[SetupPkt.EPNum];
00129C  208540     MOV #0x854, W0
00129E  784110     MOV.B [W0], W2
0012A0  61406F     AND.B W2, #0xF, W0
0012A2  FB8000     ZE W0, W0
0012A4  400080     ADD W0, W0, W1
0012A6  208080     MOV #0x808, W0
0012A8  408000     ADD W1, W0, W0
0012AA  780F10     MOV [W0], [W14]
2823:                          current_ep_data.Val = ep_data_out[SetupPkt.EPNum].Val;
0012AC  208540     MOV #0x854, W0
0012AE  784090     MOV.B [W0], W1
0012B0  60C06F     AND.B W1, #0xF, W0
0012B2  FB8080     ZE W0, W1
0012B4  2084E0     MOV #0x84E, W0
0012B6  408000     ADD W1, W0, W0
0012B8  784010     MOV.B [W0], W0
0012BA  984740     MOV.B W0, [W14+4]
0012BC  370010     BRA .L158
2824:                      }
2825:                      else
2826:                      {
2827:                          p = (BDT_ENTRY*)pBDTEntryIn[SetupPkt.EPNum];
0012BE  208540     MOV #0x854, W0
0012C0  784110     MOV.B [W0], W2
0012C2  61406F     AND.B W2, #0xF, W0
0012C4  FB8000     ZE W0, W0
0012C6  400080     ADD W0, W0, W1
0012C8  2080C0     MOV #0x80C, W0
0012CA  408000     ADD W1, W0, W0
0012CC  780F10     MOV [W0], [W14]
2828:                          current_ep_data.Val = ep_data_in[SetupPkt.EPNum].Val;
0012CE  208540     MOV #0x854, W0
0012D0  784090     MOV.B [W0], W1
0012D2  60C06F     AND.B W1, #0xF, W0
0012D4  FB8080     ZE W0, W1
0012D6  2084C0     MOV #0x84C, W0
0012D8  408000     ADD W1, W0, W0
0012DA  784010     MOV.B [W0], W0
0012DC  984740     MOV.B W0, [W14+4]
2829:                      }
2830:              
2831:                      //If ping pong buffering is enabled on the requested endpoint, need 
2832:                      //to point to the one that is the active BDT entry which the SIE will 
2833:                      //use for the next attempted transaction on that EP number.
2834:                      #if (USB_PING_PONG_MODE == USB_PING_PONG__ALL_BUT_EP0) || (USB_PING_PONG_MODE == USB_PING_PONG__FULL_PING_PONG)   
2835:                          if(current_ep_data.bits.ping_pong_state == 0) //Check if even
0012DE  90404E     MOV.B [W14+4], W0
0012E0  604061     AND.B W0, #0x1, W0
0012E2  E00400     CP0.B W0
0012E4  3A0005     BRA NZ, .L159
2836:                          {
2837:                              p = (BDT_ENTRY*)(((uintptr_t)p) & (~USB_NEXT_PING_PONG));
0012E6  78009E     MOV [W14], W1
0012E8  2FFFB0     MOV #0xFFFB, W0
0012EA  608000     AND W1, W0, W0
0012EC  780F00     MOV W0, [W14]
0012EE  370003     BRA .L160
2838:                          }
2839:                          else //else must have been odd
2840:                          {
2841:                              p = (BDT_ENTRY*)(((uintptr_t)p) | USB_NEXT_PING_PONG);
0012F0  78001E     MOV [W14], W0
0012F2  A02000     BSET W0, #2
0012F4  780F00     MOV W0, [W14]
2842:                          }
2843:                      #endif
2844:                      
2845:                      //Update the BDT pointers with the new, next entry based on the feature
2846:                      //  request
2847:                      if(SetupPkt.EPDir == OUT_FROM_HOST)
0012F6  208540     MOV #0x854, W0
0012F8  784090     MOV.B [W0], W1
0012FA  B3C800     MOV.B #0x80, W0
0012FC  60C000     AND.B W1, W0, W0
0012FE  E00400     CP0.B W0
001300  3A000A     BRA NZ, .L161
2848:                      {
2849:                          pBDTEntryOut[SetupPkt.EPNum] = (volatile BDT_ENTRY *)p;
001302  208540     MOV #0x854, W0
001304  784110     MOV.B [W0], W2
001306  61406F     AND.B W2, #0xF, W0
001308  FB8000     ZE W0, W0
00130A  78009E     MOV [W14], W1
00130C  400100     ADD W0, W0, W2
00130E  208080     MOV #0x808, W0
001310  410000     ADD W2, W0, W0
001312  780801     MOV W1, [W0]
001314  370009     BRA .L162
2850:                      }
2851:                      else
2852:                      {
2853:                          pBDTEntryIn[SetupPkt.EPNum] = (volatile BDT_ENTRY *)p;
001316  208540     MOV #0x854, W0
001318  784090     MOV.B [W0], W1
00131A  60C06F     AND.B W1, #0xF, W0
00131C  FB8000     ZE W0, W0
00131E  78009E     MOV [W14], W1
001320  400100     ADD W0, W0, W2
001322  2080C0     MOV #0x80C, W0
001324  410000     ADD W2, W0, W0
001326  780801     MOV W1, [W0]
2854:                      }
2855:              
2856:              		//Check if it was a SET_FEATURE endpoint halt request
2857:                      if(SetupPkt.bRequest == USB_REQUEST_SET_FEATURE)
001328  208510     MOV #0x851, W0
00132A  784010     MOV.B [W0], W0
00132C  504FE3     SUB.B W0, #0x3, [W15]
00132E  3A002C     BRA NZ, .L163
2858:                      {
2859:                          if(p->STAT.UOWN == 1)
001330  78001E     MOV [W14], W0
001332  780090     MOV [W0], W1
001334  280000     MOV #0x8000, W0
001336  608000     AND W1, W0, W0
001338  E00000     CP0 W0
00133A  320019     BRA Z, .L164
2860:                          {
2861:                              //Mark that we are terminating this transfer and that the user
2862:                              //  needs to be notified later
2863:                              if(SetupPkt.EPDir == OUT_FROM_HOST)
00133C  208540     MOV #0x854, W0
00133E  784090     MOV.B [W0], W1
001340  B3C800     MOV.B #0x80, W0
001342  60C000     AND.B W1, W0, W0
001344  E00400     CP0.B W0
001346  3A000A     BRA NZ, .L165
2864:                              {
2865:                                  ep_data_out[SetupPkt.EPNum].bits.transfer_terminated = 1;
001348  208540     MOV #0x854, W0
00134A  784110     MOV.B [W0], W2
00134C  61406F     AND.B W2, #0xF, W0
00134E  FB8080     ZE W0, W1
001350  2084E0     MOV #0x84E, W0
001352  408000     ADD W1, W0, W0
001354  784090     MOV.B [W0], W1
001356  A01401     BSET.B W1, #1
001358  784801     MOV.B W1, [W0]
00135A  370009     BRA .L164
2866:                              }
2867:                              else
2868:                              {
2869:                                  ep_data_in[SetupPkt.EPNum].bits.transfer_terminated = 1;
00135C  208540     MOV #0x854, W0
00135E  784090     MOV.B [W0], W1
001360  60C06F     AND.B W1, #0xF, W0
001362  FB8080     ZE W0, W1
001364  2084C0     MOV #0x84C, W0
001366  408000     ADD W1, W0, W0
001368  784090     MOV.B [W0], W1
00136A  A01401     BSET.B W1, #1
00136C  784801     MOV.B W1, [W0]
2870:                              }
2871:                          }
2872:              
2873:              			//Then STALL the endpoint
2874:                          p->STAT.Val |= _BSTALL;
00136E  78001E     MOV [W14], W0
001370  904010     MOV.B [W0+1], W0
001372  784080     MOV.B W0, W1
001374  A02401     BSET.B W1, #2
001376  78001E     MOV [W14], W0
001378  984011     MOV.B W1, [W0+1]
2875:                          p->STAT.Val |= _USIE;
00137A  78001E     MOV [W14], W0
00137C  904010     MOV.B [W0+1], W0
00137E  784080     MOV.B W0, W1
001380  A07401     BSET.B W1, #7
001382  78001E     MOV [W14], W0
001384  984011     MOV.B W1, [W0+1]
001386  370067     BRA .L153
2876:                      }//if(SetupPkt.bRequest == USB_REQUEST_SET_FEATURE)
2877:                      else
2878:                      {
2879:              			//Else the request must have been a CLEAR_FEATURE endpoint halt.
2880:                          #if (USB_PING_PONG_MODE == USB_PING_PONG__ALL_BUT_EP0) || (USB_PING_PONG_MODE == USB_PING_PONG__FULL_PING_PONG)   
2881:                              //toggle over the to the non-active BDT
2882:                              p = (BDT_ENTRY*)(((uintptr_t)p) ^ USB_NEXT_PING_PONG);  
001388  78001E     MOV [W14], W0
00138A  A22000     BTG W0, #2
00138C  780F00     MOV W0, [W14]
2883:              
2884:                              if(p->STAT.UOWN == 1)
00138E  78001E     MOV [W14], W0
001390  780090     MOV [W0], W1
001392  280000     MOV #0x8000, W0
001394  608000     AND W1, W0, W0
001396  E00000     CP0 W0
001398  320011     BRA Z, .L166
2885:                              {
2886:                                  //Clear UOWN and set DTS state so it will be correct the next time
2887:                                  //the application firmware uses USBTransferOnePacket() on the EP.
2888:                                  p->STAT.Val &= (~_USIE);    //Clear UOWN bit
00139A  78001E     MOV [W14], W0
00139C  904010     MOV.B [W0+1], W0
00139E  784080     MOV.B W0, W1
0013A0  A17401     BCLR.B W1, #7
0013A2  78001E     MOV [W14], W0
0013A4  984011     MOV.B W1, [W0+1]
2889:                                  p->STAT.Val |= _DAT1;       //Set DTS to DATA1
0013A6  78001E     MOV [W14], W0
0013A8  904010     MOV.B [W0+1], W0
0013AA  784080     MOV.B W0, W1
0013AC  A06401     BSET.B W1, #6
0013AE  78001E     MOV [W14], W0
0013B0  984011     MOV.B W1, [W0+1]
2890:                                  USB_TRANSFER_TERMINATED_HANDLER(EVENT_TRANSFER_TERMINATED,p,sizeof(p));
0013B2  200022     MOV #0x2, W2
0013B4  78009E     MOV [W14], W1
0013B6  200050     MOV #0x5, W0
0013B8  0703B2     RCALL USER_USB_CALLBACK_EVENT_HANDLER
0013BA  370006     BRA .L167
2891:                              }
2892:                              else
2893:                              {
2894:                                  //UOWN already clear, but still need to set DTS to DATA1     
2895:              					p->STAT.Val |= _DAT1;
0013BC  78001E     MOV [W14], W0
0013BE  904010     MOV.B [W0+1], W0
0013C0  784080     MOV.B W0, W1
0013C2  A06401     BSET.B W1, #6
0013C4  78001E     MOV [W14], W0
0013C6  984011     MOV.B W1, [W0+1]
2896:                              }
2897:              
2898:                              //toggle back to the active BDT (the one the SIE is currently looking at
2899:                              //and will use for the next successful transaction to take place on the EP
2900:                              p = (BDT_ENTRY*)(((uintptr_t)p) ^ USB_NEXT_PING_PONG);
0013C8  78001E     MOV [W14], W0
0013CA  A22000     BTG W0, #2
0013CC  780F00     MOV W0, [W14]
2901:                              
2902:                              //Check if we are currently terminating, or have previously terminated
2903:                              //a transaction on the given endpoint.  If so, need to clear UOWN,
2904:                              //set DTS to the proper state, and call the application callback
2905:                              //function.
2906:                              if((current_ep_data.bits.transfer_terminated != 0) || (p->STAT.UOWN == 1))
0013CE  90404E     MOV.B [W14+4], W0
0013D0  604062     AND.B W0, #0x2, W0
0013D2  E00400     CP0.B W0
0013D4  3A0006     BRA NZ, .L168
0013D6  78001E     MOV [W14], W0
0013D8  780090     MOV [W0], W1
0013DA  280000     MOV #0x8000, W0
0013DC  608000     AND W1, W0, W0
0013DE  E00000     CP0 W0
0013E0  320026     BRA Z, .L169
2907:                              {
2908:                                  if(SetupPkt.EPDir == OUT_FROM_HOST)
0013E2  208540     MOV #0x854, W0
0013E4  784090     MOV.B [W0], W1
0013E6  B3C800     MOV.B #0x80, W0
0013E8  60C000     AND.B W1, W0, W0
0013EA  E00400     CP0.B W0
0013EC  3A000B     BRA NZ, .L170
2909:                                  {
2910:                                      ep_data_out[SetupPkt.EPNum].bits.transfer_terminated = 0;
0013EE  208540     MOV #0x854, W0
0013F0  784110     MOV.B [W0], W2
0013F2  61406F     AND.B W2, #0xF, W0
0013F4  FB8080     ZE W0, W1
0013F6  2084E0     MOV #0x84E, W0
0013F8  408000     ADD W1, W0, W0
0013FA  784110     MOV.B [W0], W2
0013FC  B3CFD1     MOV.B #0xFD, W1
0013FE  614081     AND.B W2, W1, W1
001400  784801     MOV.B W1, [W0]
001402  37000A     BRA .L171
2911:                                  }
2912:                                  else
2913:                                  {
2914:                                      ep_data_in[SetupPkt.EPNum].bits.transfer_terminated = 0;
001404  208540     MOV #0x854, W0
001406  784090     MOV.B [W0], W1
001408  60C06F     AND.B W1, #0xF, W0
00140A  FB8080     ZE W0, W1
00140C  2084C0     MOV #0x84C, W0
00140E  408000     ADD W1, W0, W0
001410  784110     MOV.B [W0], W2
001412  B3CFD1     MOV.B #0xFD, W1
001414  614081     AND.B W2, W1, W1
001416  784801     MOV.B W1, [W0]
2915:                                  }
2916:                                  //clear UOWN, clear DTS to DATA0, and finally remove the STALL condition     
2917:                                  p->STAT.Val &= ~(_USIE | _DAT1 | _BSTALL);  
001418  78001E     MOV [W14], W0
00141A  904010     MOV.B [W0+1], W0
00141C  B3C3B2     MOV.B #0x3B, W2
00141E  604082     AND.B W0, W2, W1
001420  78001E     MOV [W14], W0
001422  984011     MOV.B W1, [W0+1]
2918:                                  //Call the application event handler callback function, so it can 
2919:              					//decide if the endpoint should get re-armed again or not.
2920:                                  USB_TRANSFER_TERMINATED_HANDLER(EVENT_TRANSFER_TERMINATED,p,sizeof(p));
001424  200022     MOV #0x2, W2
001426  78009E     MOV [W14], W1
001428  200050     MOV #0x5, W0
00142A  070379     RCALL USER_USB_CALLBACK_EVENT_HANDLER
00142C  370006     BRA .L172
2921:                              }
2922:                              else
2923:                              {
2924:                                  //clear UOWN, clear DTS to DATA0, and finally remove the STALL condition     
2925:                                  p->STAT.Val &= ~(_USIE | _DAT1 | _BSTALL); 
00142E  78001E     MOV [W14], W0
001430  904010     MOV.B [W0+1], W0
001432  B3C3B2     MOV.B #0x3B, W2
001434  604082     AND.B W0, W2, W1
001436  78001E     MOV [W14], W0
001438  984011     MOV.B W1, [W0+1]
2926:                              } 
2927:                          #else //else we must not be using ping-pong buffering on the requested endpoint
2928:                              //Check if we need to call the user transfer terminated event callback function.
2929:                              //We should call the callback, if the endpoint was previously terminated,
2930:                              //or the endpoint is currently armed, and the host is performing clear
2931:                              //endpoint halt, even though the endpoint wasn't stalled.
2932:                              if((current_ep_data.bits.transfer_terminated != 0) || (p->STAT.UOWN == 1))
2933:                              {
2934:                                  //We are going to call the user transfer terminated callback.
2935:                                  //Clear the flag so we know we took care of it and don't need
2936:                                  //to call it again later.
2937:                                  if(SetupPkt.EPDir == OUT_FROM_HOST)
2938:                                  {
2939:                                      ep_data_out[SetupPkt.EPNum].bits.transfer_terminated = 0;
2940:                                  }
2941:                                  else
2942:                                  {
2943:                                      ep_data_in[SetupPkt.EPNum].bits.transfer_terminated = 0;
2944:                                  }
2945:               
2946:                                  //Clear UOWN and remove the STALL condition.   
2947:                                  //  In this case we also need to set the DTS bit to 1 so that
2948:                                  //  it toggles to DATA0 the next time the application firmware
2949:                                  //  calls USBTransferOnePacket() (or equivalent macro).  
2950:                                  p->STAT.Val &= ~(_USIE | _BSTALL);  
2951:                                  p->STAT.Val |= _DAT1;
2952:                                  //Let the application firmware know a transaction just
2953:                                  //got terminated by the host, and that it is now free to
2954:                                  //re-arm the endpoint or do other tasks if desired.                                        
2955:                                  USB_TRANSFER_TERMINATED_HANDLER(EVENT_TRANSFER_TERMINATED,p,sizeof(p));
2956:                              }
2957:                              else
2958:                              {
2959:                                  //Clear UOWN and remove the STALL condition.   
2960:                                  //  In this case we also need to set the DTS bit to 1 so that
2961:                                  //  it toggles to DATA0 the next time the application firmware
2962:                                  //  calls USBTransferOnePacket() (or equivalent macro).  
2963:                                  p->STAT.Val &= ~(_USIE | _BSTALL);  
2964:                                  p->STAT.Val |= _DAT1;
2965:                              } 
2966:                          #endif //end of #if (USB_PING_PONG_MODE == USB_PING_PONG__ALL_BUT_EP0) || (USB_PING_PONG_MODE == USB_PING_PONG__FULL_PING_PONG)   
2967:                          
2968:              			//Get a pointer to the appropriate UEPn register
2969:                          #if defined(__C32__)
2970:                              pUEP = (uint32_t*)(&U1EP0);
2971:                              pUEP += (SetupPkt.EPNum*4);
2972:                          #else
2973:                              pUEP = (unsigned char*)(&U1EP0+SetupPkt.EPNum);
00143A  2042A1     MOV #0x42A, W1
00143C  208540     MOV #0x854, W0
00143E  784110     MOV.B [W0], W2
001440  61406F     AND.B W2, #0xF, W0
001442  FB8000     ZE W0, W0
001444  400000     ADD W0, W0, W0
001446  408000     ADD W1, W0, W0
001448  980710     MOV W0, [W14+2]
2974:                          #endif
2975:              
2976:              			//Clear the STALL bit in the UEP register
2977:                          *pUEP &= ~UEP_STALL;            
00144A  90001E     MOV [W14+2], W0
00144C  784090     MOV.B [W0], W1
00144E  B3CFD0     MOV.B #0xFD, W0
001450  60C080     AND.B W1, W0, W1
001452  90001E     MOV [W14+2], W0
001454  784801     MOV.B W1, [W0]
2978:                      }//end if(SetupPkt.bRequest == USB_REQUEST_SET_FEATURE)
2979:                  }//end if (lots of checks for set/clear endpoint halt)
2980:              }//end USBStdFeatureReqHandler
001456  FA8000     ULNK
001458  060000     RETURN
2981:              
2982:              
2983:              
2984:              
2985:              /**************************************************************************
2986:                  Function:
2987:                      void USBIncrement1msInternalTimers(void)
2988:              
2989:                  Description:
2990:                      This function increments internal 1ms time base counters, which are
2991:                      useful for application code (that can use a 1ms time base/counter), and
2992:                      for certain USB event timing specific purposes.
2993:              
2994:                      In USB full speed applications, the application code does not need to (and should
2995:                      not) explicitly call this function, as the USBDeviceTasks() function will
2996:                      automatically call this function whenever a 1ms time interval has elapsed
2997:                      (assuming the code is calling USBDeviceTasks() frequently enough in USB_POLLING
2998:                      mode, or that USB interrupts aren't being masked for more than 1ms at a time
2999:                      in USB_INTERRUPT mode).
3000:              
3001:                      In USB low speed applications, the application firmware is responsible for
3002:                      periodically calling this function at a ~1ms rate.  This can be done using
3003:                      a general purpose microcontroller timer set to interrupt every 1ms for example.
3004:                      If the low speed application code does not call this function, the internal timers
3005:                      will not increment, and the USBGet1msTickCount() API function will not be available.
3006:                      Additionally, certain USB stack operations (like control transfer timeouts)
3007:                      may be unavailable.
3008:              
3009:                  Precondition:
3010:                      This function should be called only after USBDeviceInit() has been
3011:                      called (at least once at the start of the application).  Ordinarily,
3012:                      application code should never call this function, unless it is a low speed
3013:                      USB device.
3014:              
3015:                  Parameters:
3016:                      None
3017:              
3018:                  Return Values:
3019:                      None
3020:              
3021:                  Remarks:
3022:                      This function does not need to be called during USB suspend conditions, when
3023:                      the USB module/stack is disabled, or when the USB cable is detached from the host.
3024:                ***************************************************************************/
3025:              void USBIncrement1msInternalTimers(void)
3026:              {
00145A  FA0000     LNK #0x0
3027:                  #if(USB_SPEED_OPTION == USB_LOW_SPEED)
3028:                      #warning "For low speed USB applications, read the function comments for the USBIncrement1msInternalTimers() function, and implement code to call this function periodically."
3029:                  #endif
3030:              
3031:                  //Increment timekeeping 1ms tick counters.  Useful for other APIs/code
3032:                  //that needs a 1ms time base that is active during USB non-suspended operation.
3033:                  USB1msTickCount++;
00145C  804100     MOV USB1msTickCount, W0
00145E  804111     MOV 0x822, W1
001460  400061     ADD W0, #0x1, W0
001462  4880E0     ADDC W1, #0x0, W1
001464  884100     MOV W0, USB1msTickCount
001466  884111     MOV W1, 0x822
3034:                  if(USBIsBusSuspended() == false)
001468  BFC815     MOV.B USBBusIsSuspended, WREG
00146A  A20400     BTG.B W0, #0
00146C  E00400     CP0.B W0
00146E  320008     BRA Z, .L173
3035:                  {
3036:                      USBTicksSinceSuspendEnd++;
001470  BFC824     MOV.B USBTicksSinceSuspendEnd, WREG
001472  E84000     INC.B W0, W0
001474  B7E824     MOV.B WREG, USBTicksSinceSuspendEnd
3037:                      //Check for 8-bit wraparound.  If so, force it to saturate at 255.
3038:                      if(USBTicksSinceSuspendEnd == 0)
001476  BFC824     MOV.B USBTicksSinceSuspendEnd, WREG
001478  E00400     CP0.B W0
00147A  3A0002     BRA NZ, .L173
3039:                      {
3040:                          USBTicksSinceSuspendEnd = 255;
00147C  EBC000     SETM.B W0
00147E  B7E824     MOV.B WREG, USBTicksSinceSuspendEnd
3041:                      }
3042:                  }
3043:              }
001480  FA8000     ULNK
001482  060000     RETURN
3044:              
3045:              
3046:              
3047:              
3048:              /**************************************************************************
3049:                  Function:
3050:                      uint32_t USBGet1msTickCount(void)
3051:              
3052:                  Description:
3053:                      This function retrieves a 32-bit unsigned integer that normally increments by
3054:                      one every one millisecond.  The count value starts from zero when the
3055:                      USBDeviceInit() function is first called.  See the remarks section for
3056:                      details on special circumstances where the tick count will not increment.
3057:              
3058:                  Precondition:
3059:                      This function should be called only after USBDeviceInit() has been
3060:                      called (at least once at the start of the application).
3061:              
3062:                  Parameters:
3063:                      None
3064:              
3065:                  Return Values:
3066:                      uint32_t representing the approximate millisecond count, since the time the
3067:                      USBDeviceInit() function was first called.
3068:              
3069:                  Remarks:
3070:                      On 8-bit USB full speed devices, the internal counter is incremented on
3071:                      every SOF packet detected.  Therefore, it will not increment during suspend
3072:                      or when the USB cable is detached.  However, on 16-bit devices, the T1MSECIF
3073:                      hardware interrupt source is used to increment the internal counter.  Therefore,
3074:                      on 16-bit devices, the count continue to increment during USB suspend or
3075:                      detach events, so long as the application code has not put the microcontroller
3076:                      to sleep during these events, and the application firmware is regularly
3077:                      calling the USBDeviceTasks() function (or allowing it to execute, if using
3078:                      USB_INTERRUPT mode operation).
3079:              
3080:                      In USB low speed applications, the host does not broadcast SOF packets to
3081:                      the device, so the application firmware becomes responsible for calling
3082:                      USBIncrement1msInternalTimers() periodically (ex: from a general purpose
3083:                      timer interrupt handler), or else the returned value from this function will
3084:                      not increment.
3085:                      
3086:                      Prior to calling USBDeviceInit() for the first time the returned value will
3087:                      be unpredictable.
3088:              
3089:                      This function is USB_INTERRUPT mode safe and may be called from main loop
3090:                      code without risk of retrieving a partially updated 32-bit number.
3091:              
3092:                      However, this value only increments when the USBDeviceTasks() function is allowed
3093:                      to execute.  If USB_INTERRUPT mode is used, it is allowable to block on this
3094:                      function.  If however USB_POLLING mode is used, one must not block on this
3095:                      function without also calling USBDeviceTasks() continuously for the blocking
3096:                      duration (since the USB stack must still be allowed to execute, and the USB
3097:                      stack is also responsible for updating the tick counter internally).
3098:              
3099:                      If the application is operating in USB_POLLING mode, this function should
3100:                      only be called from the main loop context, and not from an interrupt handler,
3101:                      as the returned value could be incorrect, if the main loop context code was in
3102:                      the process of updating the internal count at the moment of the interrupt event.
3103:                 ***************************************************************************/
3104:              uint32_t USBGet1msTickCount(void)
3105:              {
001484  FA0004     LNK #0x4
3106:                  #if defined (USB_INTERRUPT)
3107:                      uint32_t localContextValue;
3108:              
3109:                      //Repeatedly read the interrupt context variable, until we get a stable/unchanging
3110:                      //value.  This ensures that the complete 32-bit value got read without
3111:                      //getting interrupted in between bytes.
3112:                      do
3113:                      {
3114:                          localContextValue = USB1msTickCount;
001486  804102     MOV USB1msTickCount, W2
001488  804113     MOV 0x822, W3
00148A  BE8F02     MOV.D W2, [W14]
3115:                      }while(localContextValue != USB1msTickCount);
00148C  804100     MOV USB1msTickCount, W0
00148E  804111     MOV 0x822, W1
001490  BE011E     MOV.D [W14], W2
001492  510F80     SUB W2, W0, [W15]
001494  598F81     SUBB W3, W1, [W15]
001496  3AFFF7     BRA NZ, .L176
3116:              
3117:                      return localContextValue;    
001498  BE001E     MOV.D [W14], W0
3118:                  
3119:                  #else
3120:                      return USB1msTickCount;
3121:                  #endif
3122:              }
00149A  FA8000     ULNK
00149C  060000     RETURN
3123:              
3124:              
3125:              
3126:              
3127:              
3128:              
3129:              /** EOF USBDevice.c *****************************************************/
---  C:/Users/imada/OneDrive/Documents/MPLAB X/IR_Splitted_KB/IR_Splitted_Master.X/system.c  ------------
1:                 /*******************************************************************************
2:                 Copyright 2016 Microchip Technology Inc. (www.microchip.com)
3:                 
4:                 Licensed under the Apache License, Version 2.0 (the "License");
5:                 you may not use this file except in compliance with the License.
6:                 You may obtain a copy of the License at
7:                 
8:                 	http://www.apache.org/licenses/LICENSE-2.0
9:                 
10:                Unless required by applicable law or agreed to in writing, software
11:                distributed under the License is distributed on an "AS IS" BASIS,
12:                WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
13:                See the License for the specific language governing permissions and
14:                limitations under the License.
15:                
16:                To request to license the code under the MLA license (www.microchip.com/mla_license), 
17:                please contact mla_licensing@microchip.com
18:                 *******************************************************************************/
19:                
20:                #include "system.h"
21:                #include "usb.h"
22:                #include "leds.h"
23:                #include "buttons.h"
24:                
25:                /** CONFIGURATION Bits **********************************************/
26:                // CONFIG4
27:                #pragma config DSWDTPS = DSWDTPS1F      // Deep Sleep Watchdog Timer Postscale Select bits (1:68719476736 (25.7 Days))
28:                #pragma config DSWDTOSC = LPRC          // DSWDT Reference Clock Select (DSWDT uses LPRC as reference clock)
29:                #pragma config DSBOREN = OFF            // Deep Sleep BOR Enable bit (DSBOR Disabled)
30:                #pragma config DSWDTEN = OFF            // Deep Sleep Watchdog Timer Enable (DSWDT Disabled)
31:                #pragma config DSSWEN = OFF             // DSEN Bit Enable (Deep Sleep operation is always disabled)
32:                #pragma config PLLDIV = DIVIDE2         // USB 96 MHz PLL Prescaler Select bits (Oscillator input divided by 1 (4 MHz input))
33:                #pragma config I2C1SEL = DISABLE        // Alternate I2C1 enable bit (I2C1 uses SCL1 and SDA1 pins)
34:                #pragma config IOL1WAY = OFF            // PPS IOLOCK Set Only Once Enable bit (The IOLOCK bit can be set and cleared using the unlock sequence)
35:                
36:                // CONFIG3
37:                #pragma config WPFP = WPFP127           // Write Protection Flash Page Segment Boundary (Page 127 (0x1FC00))
38:                #pragma config SOSCSEL = ON             // SOSC Selection bits (SOSC circuit selected)
39:                #pragma config WDTWIN = PS25_0          // Window Mode Watchdog Timer Window Width Select (Watch Dog Timer Window Width is 25 percent)
40:                #pragma config PLLSS = PLL_FRC          // PLL Secondary Selection Configuration bit (PLL is fed by the on-chip Fast RC (FRC) oscillator)
41:                #pragma config BOREN = ON               // Brown-out Reset Enable (Brown-out Reset Enable)
42:                #pragma config WPDIS = WPDIS            // Segment Write Protection Disable (Disabled)
43:                #pragma config WPCFG = WPCFGDIS         // Write Protect Configuration Page Select (Disabled)
44:                #pragma config WPEND = WPENDMEM         // Segment Write Protection End Page Select (Write Protect from WPFP to the last page of memory)
45:                
46:                // CONFIG2
47:                #pragma config POSCMD = NONE            // Primary Oscillator Select (Primary Oscillator Disabled)
48:                #pragma config WDTCLK = LPRC            // WDT Clock Source Select bits (WDT uses LPRC)
49:                #pragma config OSCIOFCN = ON            // OSCO Pin Configuration (OSCO/CLKO/RA3 functions as port I/O (RA3))
50:                #pragma config FCKSM = CSECMD           // Clock Switching and Fail-Safe Clock Monitor Configuration bits (Clock switching is enabled, Fail-Safe Clock Monitor is disabled)
51:                #pragma config FNOSC = FRCPLL           // Initial Oscillator Select (Fast RC Oscillator with PLL module (FRCPLL))
52:                #pragma config ALTRB6 = APPEND          // Alternate RB6 pin function enable bit (Append the RP6/ASCL1/PMPD6 functions of RB6 to RA1 pin functions)
53:                #pragma config ALTCMPI = CxINC_RB       // Alternate Comparator Input bit (C1INC is on RB13, C2INC is on RB9 and C3INC is on RA0)
54:                #pragma config WDTCMX = WDTCLK          // WDT Clock Source Select bits (WDT clock source is determined by the WDTCLK Configuration bits)
55:                #pragma config IESO = OFF               // Internal External Switchover (Disabled)
56:                
57:                // CONFIG1
58:                #pragma config WDTPS = PS32768          // Watchdog Timer Postscaler Select (1:32,768)
59:                #pragma config FWPSA = PR128            // WDT Prescaler Ratio Select (1:128)
60:                #pragma config WINDIS = OFF             // Windowed WDT Disable (Standard Watchdog Timer)
61:                #pragma config FWDTEN = OFF             // Watchdog Timer Enable (WDT disabled in hardware; SWDTEN bit disabled)
62:                #pragma config ICS = PGx1               // Emulator Pin Placement Select bits (Emulator functions are shared with PGEC1/PGED1)
63:                #pragma config LPCFG = OFF              // Low power regulator control (Disabled - regardless of RETEN)
64:                #pragma config GWRP = OFF               // General Segment Write Protect (Write to program memory allowed)
65:                #pragma config GCP = OFF                // General Segment Code Protect (Code protection is disabled)
66:                #pragma config JTAGEN = OFF             // JTAG Port Enable (Disabled)
67:                
68:                /*********************************************************************
69:                 * Function: void SYSTEM_Initialize( SYSTEM_STATE state )
70:                 *
71:                 * Overview: Initializes the system.
72:                 *
73:                 * PreCondition: None
74:                 *
75:                 * Input:  SYSTEM_STATE - the state to initialize the system into
76:                 *
77:                 * Output: None
78:                 *
79:                 ********************************************************************/
80:                void SYSTEM_Initialize(SYSTEM_STATE state)
81:                {
001D08  FA0002     LNK #0x2
001D0A  780F00     MOV W0, [W14]
82:                	switch (state) {
001D0C  78001E     MOV [W14], W0
001D0E  500FE1     SUB W0, #0x1, [W15]
001D10  32000C     BRA Z, .L4
001D12  500FE1     SUB W0, #0x1, [W15]
001D14  31000C     BRA C, .L7
83:                	case SYSTEM_STATE_USB_START:
84:                		//Make sure that the general purpose output driver multiplexed with
85:                		//the VBUS pin is always consistently configured to be tri-stated in
86:                		//USB applications, so as to avoid any possible contention with the host.
87:                		//(ex: maintain TRISBbits.TRISB6 = 1 at all times).
88:                		TRISBbits.TRISB6 = 1;
001D16  A8C18A     BSET TRISB, #6
89:                
90:                		LED_Enable(LED_USB_DEVICE_STATE);
001D18  200010     MOV #0x1, W0
001D1A  07FE70     RCALL LED_Enable
91:                		LED_Enable(LED_USB_DEVICE_HID_KEYBOARD_CAPS_LOCK);
001D1C  200020     MOV #0x2, W0
001D1E  07FE6E     RCALL LED_Enable
92:                		LED_Enable(LED_USB_DEVICE_HID_KEYBOARD_KANA);
001D20  200030     MOV #0x3, W0
001D22  07FE6C     RCALL LED_Enable
93:                
94:                		BUTTON_Enable(BUTTON_USB_DEVICE_HID_KEYBOARD_KEY);
001D24  200010     MOV #0x1, W0
001D26  07FF95     RCALL BUTTON_Enable
95:                		break;
001D28  370003     BRA .L1
96:                
97:                	case SYSTEM_STATE_USB_SUSPEND:
98:                		//If developing a bus powered USB device that needs to be USB compliant,
99:                		//insert code here to reduce the I/O pin and microcontroller power consumption,
100:               		//so that the total current is <2.5mA from the USB host's VBUS supply.
101:               		//If developing a self powered application (or a bus powered device where
102:               		//official USB compliance isn't critical), nothing strictly needs
103:               		//to be done during USB suspend.
104:               
105:               		USBSleepOnSuspend();
001D2A  07FBB9     RCALL USBSleepOnSuspend
106:               		break;
001D2C  370001     BRA .L1
107:               
108:               	case SYSTEM_STATE_USB_RESUME:
109:               		//If you didn't change any I/O pin states prior to entry into suspend,
110:               		//then nothing explicitly needs to be done here.  However, by the time
111:               		//the firmware returns from this function, the full application should
112:               		//be restored into effectively exactly the same state as the application
113:               		//was in, prior to entering USB suspend.
114:               
115:               		//Additionally, before returning from this function, make sure the microcontroller's
116:               		//currently active clock settings are compatible with USB operation, including
117:               		//taking into consideration all possible microcontroller features/effects
118:               		//that can affect the oscillator settings (such as internal/external 
119:               		//switchover (two speed start up), fail-safe clock monitor, PLL lock time,
120:               		//external crystal/resonator startup time (if using a crystal/resonator),
121:               		//etc.
122:               
123:               		//Additionally, the official USB specifications dictate that USB devices
124:               		//must become fully operational and ready for new host requests/normal 
125:               		//USB communication after a 10ms "resume recovery interval" has elapsed.
126:               		//In order to meet this timing requirement and avoid possible issues,
127:               		//make sure that all necessary oscillator startup is complete and this
128:               		//function has returned within less than this 10ms interval.
129:               
130:               		break;
001D2E  000000     NOP
131:               
132:               	default:
133:               		break;
134:               	}
135:               }
001D30  FA8000     ULNK
001D32  060000     RETURN
136:               
137:               #if defined(USB_INTERRUPT)
138:               
139:               void __attribute__((interrupt, auto_psv)) _USB1Interrupt()
140:               {
000308  F80036     PUSH RCOUNT
00030A  BE9F80     MOV.D W0, [W15++]
00030C  BE9F82     MOV.D W2, [W15++]
00030E  BE9F84     MOV.D W4, [W15++]
000310  BE9F86     MOV.D W6, [W15++]
000312  F80032     PUSH DSRPAG
000314  F80034     PUSH DSWPAG
000316  200010     MOV #0x1, W0
000318  8801A0     MOV W0, DSWPAG
00031A  202000     MOV #0x200, W0
00031C  880190     MOV W0, DSRPAG
00031E  FA0000     LNK #0x0
141:               	USBDeviceTasks();
000320  070166     RCALL USBDeviceTasks
142:               }
000322  FA8000     ULNK
000324  F90034     POP DSWPAG
000326  F90032     POP DSRPAG
000328  BE034F     MOV.D [--W15], W6
00032A  BE024F     MOV.D [--W15], W4
00032C  BE014F     MOV.D [--W15], W2
00032E  BE004F     MOV.D [--W15], W0
000330  F90036     POP RCOUNT
000332  064000     RETFIE
143:               #endif
144:               
145:               void __attribute__((interrupt, auto_psv)) _IC1Interrupt()
146:               {
000334  F80036     PUSH RCOUNT
000336  BE9F80     MOV.D W0, [W15++]
000338  BE9F82     MOV.D W2, [W15++]
00033A  BE9F84     MOV.D W4, [W15++]
00033C  BE9F86     MOV.D W6, [W15++]
00033E  F80032     PUSH DSRPAG
000340  F80034     PUSH DSWPAG
000342  200010     MOV #0x1, W0
000344  8801A0     MOV W0, DSWPAG
000346  202000     MOV #0x200, W0
000348  880190     MOV W0, DSRPAG
00034A  FA0004     LNK #0x4
147:               	static uint16_t old = 0;
148:               	uint16_t new = 0;
00034C  EB0000     CLR W0
00034E  780F00     MOV W0, [W14]
149:               	uint16_t diff = 0;
000350  EB0000     CLR W0
000352  980710     MOV W0, [W14+2]
150:               
151:               	LATBbits.LATB15 = 1;
000354  A8E18F     BSET 0x18F, #7
152:               	while (IC1CON1bits.ICBNE) {
000356  370014     BRA .L10
000380  801550     MOV IC1CON1, W0
000382  600068     AND W0, #0x8, W0
000384  E00000     CP0 W0
000386  3AFFE8     BRA NZ, .L13
153:               		new = IC1BUF;
000358  801571     MOV IC1BUF, W1
00035A  780F01     MOV W1, [W14]
154:               		diff = new - old;
00035C  8041D0     MOV old, W0
00035E  10001E     SUBR W0, [W14], W0
000360  980710     MOV W0, [W14+2]
155:               		//		11843;
156:               		if (10843 < diff && diff < 12843) {
000362  90009E     MOV [W14+2], W1
000364  22A5B0     MOV #0x2A5B, W0
000366  508F80     SUB W1, W0, [W15]
000368  360007     BRA LEU, .L11
00036A  90009E     MOV [W14+2], W1
00036C  2322A0     MOV #0x322A, W0
00036E  508F80     SUB W1, W0, [W15]
000370  3E0003     BRA GTU, .L11
157:               			//			START
158:               			LED_Off(LED_D7);
000372  200040     MOV #0x4, W0
000374  070AAD     RCALL LED_Off
000376  370002     BRA .L12
159:               		} else {
160:               			LED_On(LED_D7);
000378  200040     MOV #0x4, W0
00037A  070A91     RCALL LED_On
161:               		}
162:               		old = new;
00037C  78009E     MOV [W14], W1
00037E  8841D1     MOV W1, old
163:               	}
164:               	LATBbits.LATB15 = 0;
000388  A9E18F     BCLR 0x18F, #7
165:               	IFS0bits.OC1IF = 0;
00038A  A94084     BCLR IFS0, #2
166:               }
00038C  FA8000     ULNK
00038E  F90034     POP DSWPAG
000390  F90032     POP DSRPAG
000392  BE034F     MOV.D [--W15], W6
000394  BE024F     MOV.D [--W15], W4
000396  BE014F     MOV.D [--W15], W2
000398  BE004F     MOV.D [--W15], W0
00039A  F90036     POP RCOUNT
00039C  064000     RETFIE
167:               
---  C:/Users/imada/OneDrive/Documents/MPLAB X/IR_Splitted_KB/IR_Splitted_Master.X/main.c  --------------
1:                 /*******************************************************************************
2:                 Copyright 2016 Microchip Technology Inc. (www.microchip.com)
3:                 
4:                 Licensed under the Apache License, Version 2.0 (the "License");
5:                 you may not use this file except in compliance with the License.
6:                 You may obtain a copy of the License at
7:                 
8:                 	http://www.apache.org/licenses/LICENSE-2.0
9:                 
10:                Unless required by applicable law or agreed to in writing, software
11:                distributed under the License is distributed on an "AS IS" BASIS,
12:                WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
13:                See the License for the specific language governing permissions and
14:                limitations under the License.
15:                
16:                To request to license the code under the MLA license (www.microchip.com/mla_license), 
17:                please contact mla_licensing@microchip.com
18:                 *******************************************************************************/
19:                
20:                // *****************************************************************************
21:                // *****************************************************************************
22:                // Section: Included Files
23:                // *****************************************************************************
24:                // *****************************************************************************
25:                /* Standard C includes */
26:                #include <stdint.h>
27:                
28:                /* Microchip library includes */
29:                #include "system.h"
30:                
31:                #include "usb.h"
32:                #include "usb_device_hid.h"
33:                
34:                /* Demo project includes */
35:                #include "app_led_usb_status.h"
36:                #include "app_device_keyboard.h"
37:                
38:                int main(void)
39:                {
001C78  FA0000     LNK #0x0
40:                	OSCTUN = 0x9000;
001C7A  290000     MOV #0x9000, W0
001C7C  880830     MOV W0, OSCTUN
41:                	CLKDIVbits.RCDIV = 0b000;
001C7E  800811     MOV CLKDIV, W1
001C80  2F8FF0     MOV #0xF8FF, W0
001C82  608000     AND W1, W0, W0
001C84  880810     MOV W0, CLKDIV
42:                //	REFOCONH = 500;
43:                //	REFOCONL = 0x8006;
44:                
45:                	ANSA = 0;
001C86  EF2188     CLR ANSA
46:                	ANSB = 0;
001C88  EF2192     CLR ANSB
47:                
48:                //Input PPS
49:                	RPINR7bits.IC1R = 0x04;	//IC1 = RB4
001C8A  801CD1     MOV RPINR7, W1
001C8C  2FFC00     MOV #0xFFC0, W0
001C8E  608000     AND W1, W0, W0
001C90  A02000     BSET W0, #2
001C92  881CD0     MOV W0, RPINR7
50:                //	RPINR18bits.U1RXR = 0x04;	//U1RX = RB4
51:                	
52:                	IC1TMR = 0;
001C94  EF22B0     CLR IC1TMR
53:                	IC1CON1 =0x1c01; //IC1 use FOSC/2
001C96  21C010     MOV #0x1C01, W0
001C98  881550     MOV W0, IC1CON1
54:                	IC1CON2 =0x0000;
001C9A  EF22AC     CLR IC1CON2
55:                	while (IC1CON1bits.ICBNE) {IC1BUF;}
001C9C  370001     BRA .L2
001C9E  801570     MOV IC1BUF, W0
001CA0  801550     MOV IC1CON1, W0
001CA2  600068     AND W0, #0x8, W0
001CA4  E00000     CP0 W0
001CA6  3AFFFB     BRA NZ, .L3
56:                	
57:                //	IPC0bits.IC1IP = 7;
58:                	IFS0bits.IC1IF = 0;
001CA8  A92084     BCLR IFS0, #1
59:                	IEC0bits.IC1IE = 1;
001CAA  A82094     BSET IEC0, #1
60:                	
61:                	
62:                
63:                //	//
64:                //	OC6CON1 = 0x1c06;
65:                //	OC6CON2 = 0x001f;
66:                //	OC6RS = 286;
67:                //	OC6R = OC6RS >> 2;
68:                	
69:                
70:                //	U1BRG = 127; //7812.5bps,Calculated by Fosc = 32MHz?
71:                //	U1BRG = 255; //7812.5/2bps,Calculated by Fosc = 32MHz?
72:                //	U1MODE = 0x8000;
73:                //	U1STA = 0x1400;
74:                
75:                //	MDCON = 0x8060; 
76:                //	MDSRC = 0x0004;	//U1TX
77:                //	MDCAR = 0x8009; //Low Carrier is OC6
78:                
79:                //	RPOR1bits.RP2R = 27;	//RB2 = MDOUT
80:                //	RPOR6bits.RP13R = 27;	//RB13 = MDOUT
81:                //	RPOR7bits.RP14R = 3;	//RB14 = U1TX
82:                //	RPOR7bits.RP15R = 27;	//RB15 = MDOUT
83:                	
84:                //	CNPU1bits.CN1PUE=1;
85:                //	CNPD1bits.CN1PDE=0;
86:                		
87:                		LED_Enable(LED_D7);
001CAC  200040     MOV #0x4, W0
001CAE  07FEA6     RCALL LED_Enable
88:                //		LED_On(LED_D7);
89:                		
90:                	TRISB &= 0x1ffb;
001CB0  800C51     MOV TRISB, W1
001CB2  21FFB0     MOV #0x1FFB, W0
001CB4  608000     AND W1, W0, W0
001CB6  880C50     MOV W0, TRISB
91:                //	LATBbits.LATB15 = 1;
92:                //	while (1) {}
93:                
94:                	SYSTEM_Initialize(SYSTEM_STATE_USB_START);
001CB8  EB0000     CLR W0
001CBA  070026     RCALL SYSTEM_Initialize
95:                
96:                	USBDeviceInit();
001CBC  07F41D     RCALL USBDeviceInit
97:                	USBDeviceAttach();
001CBE  07F679     RCALL USBDeviceAttach
98:                
99:                	while (1) {
100:               		SYSTEM_Tasks();
101:               
102:               #if defined(USB_POLLING)
103:               		/* Check bus status and service USB interrupts.  Interrupt or polling
104:               		 * method.  If using polling, must call this function periodically.
105:               		 * This function will take care of processing and responding to SETUP
106:               		 * transactions (such as during the enumeration process when you first
107:               		 * plug in).  USB hosts require that USB devices should accept and
108:               		 * process SETUP packets in a timely fashion.  Therefore, when using
109:               		 * polling, this function should be called regularly (such as once every
110:               		 * 1.8ms or faster** [see inline code comments in usb_device.c for
111:               		 * explanation when "or faster" applies])  In most cases, the
112:               		 * USBDeviceTasks() function does not take very long to execute
113:               		 * (ex: <100 instruction cycles) before it returns. */
114:               		USBDeviceTasks();
115:               #endif
116:               
117:               		/* Run the keyboard demo tasks. */
118:               		APP_KeyboardTasks();
001CC0  07FD19     RCALL APP_KeyboardTasks
119:               	}//end while
001CC2  37FFFE     BRA .L4
120:               }//end main
121:               
122:               /*******************************************************************************
123:                End of File
124:                */
---  C:/Users/imada/OneDrive/Documents/MPLAB X/IR_Splitted_KB/IR_Splitted_Master.X/leds.c  --------------
1:                 /*******************************************************************************
2:                 Copyright 2016 Microchip Technology Inc. (www.microchip.com)
3:                 
4:                 Licensed under the Apache License, Version 2.0 (the "License");
5:                 you may not use this file except in compliance with the License.
6:                 You may obtain a copy of the License at
7:                 
8:                     http://www.apache.org/licenses/LICENSE-2.0
9:                 
10:                Unless required by applicable law or agreed to in writing, software
11:                distributed under the License is distributed on an "AS IS" BASIS,
12:                WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
13:                See the License for the specific language governing permissions and
14:                limitations under the License.
15:                *******************************************************************************/
16:                
17:                #include <xc.h>
18:                
19:                #include <stdbool.h>
20:                
21:                #include "leds.h"
22:                
23:                #define LED_D4_LAT      LATBbits.LATB8
24:                #define LED_D5_LAT      LATBbits.LATB7
25:                #define LED_D6_LAT      LATAbits.LATA3
26:                #define LED_D7_LAT      LATAbits.LATA2
27:                
28:                #define LED_D4_TRIS     TRISBbits.TRISB8
29:                #define LED_D5_TRIS     TRISBbits.TRISB7
30:                #define LED_D6_TRIS     TRISAbits.TRISA3
31:                #define LED_D7_TRIS     TRISAbits.TRISA2
32:                
33:                #define LED_ON  1
34:                #define LED_OFF 0
35:                
36:                #define PIN_INPUT   1
37:                #define PIN_OUTPUT  0
38:                
39:                /*********************************************************************
40:                * Function: void LED_On(LED led);
41:                *
42:                * Overview: Turns requested LED on
43:                *
44:                * PreCondition: LED configured via LED_Configure()
45:                *
46:                * Input: LED led - enumeration of the LEDs available in this
47:                *        demo.  They should be meaningful names and not the names of
48:                *        the LEDs on the silkscreen on the board (as the demo code may
49:                *        be ported to other boards).
50:                *         i.e. - LED_On(LED_CONNECTION_DETECTED);
51:                *
52:                * Output: none
53:                *
54:                ********************************************************************/
55:                void LED_On(LED led)
56:                {
00189E  FA0002     LNK #0x2
0018A0  780F00     MOV W0, [W14]
57:                    switch(led)
0018A2  78001E     MOV [W14], W0
0018A4  500FE2     SUB W0, #0x2, [W15]
0018A6  32000C     BRA Z, .L4
0018A8  500FE2     SUB W0, #0x2, [W15]
0018AA  3E0003     BRA GTU, .L7
0018AC  500FE1     SUB W0, #0x1, [W15]
0018AE  320006     BRA Z, .L3
0018B2  500FE3     SUB W0, #0x3, [W15]
0018B4  320007     BRA Z, .L5
0018B6  500FE4     SUB W0, #0x4, [W15]
0018B8  320007     BRA Z, .L6
58:                    {
59:                        case LED_D4:
60:                            LED_D4_LAT = LED_ON;
0018BC  A8018F     BSET 0x18F, #0
61:                            break ;
0018BE  370006     BRA .L1
62:                
63:                        case LED_D5:
64:                            LED_D5_LAT = LED_ON;
0018C0  A8E18E     BSET LATB, #7
65:                            break;
0018C2  370004     BRA .L1
66:                
67:                        case LED_D6:
68:                            LED_D6_LAT = LED_ON;
0018C4  A86184     BSET LATA, #3
69:                            break;
0018C6  370002     BRA .L1
70:                
71:                        case LED_D7:
72:                            LED_D7_LAT = LED_ON;
0018C8  A84184     BSET LATA, #2
73:                            break;
0018CA  000000     NOP
74:                
75:                        default:
76:                            break;
0018B0  37000D     BRA .L1
0018BA  370008     BRA .L1
77:                    }
78:                }
0018CC  FA8000     ULNK
0018CE  060000     RETURN
79:                
80:                /*********************************************************************
81:                * Function: void LED_Off(LED led);
82:                *
83:                * Overview: Turns requested LED off
84:                *
85:                * PreCondition: LED configured via LEDConfigure()
86:                *
87:                * Input: LED led - enumeration of the LEDs available in this
88:                *        demo.  They should be meaningful names and not the names of
89:                *        the LEDs on the silkscreen on the board (as the demo code may
90:                *        be ported to other boards).
91:                *         i.e. - LED_Off(LED_CONNECTION_DETECTED);
92:                *
93:                * Output: none
94:                *
95:                ********************************************************************/
96:                void LED_Off(LED led)
97:                {
0018D0  FA0002     LNK #0x2
0018D2  780F00     MOV W0, [W14]
98:                    switch(led)
0018D4  78001E     MOV [W14], W0
0018D6  500FE2     SUB W0, #0x2, [W15]
0018D8  32000C     BRA Z, .L12
0018DA  500FE2     SUB W0, #0x2, [W15]
0018DC  3E0003     BRA GTU, .L15
0018DE  500FE1     SUB W0, #0x1, [W15]
0018E0  320006     BRA Z, .L11
0018E4  500FE3     SUB W0, #0x3, [W15]
0018E6  320007     BRA Z, .L13
0018E8  500FE4     SUB W0, #0x4, [W15]
0018EA  320007     BRA Z, .L14
99:                    {
100:                       case LED_D4:
101:                           LED_D4_LAT = LED_OFF;
0018EE  A9018F     BCLR 0x18F, #0
102:                           break ;
0018F0  370006     BRA .L9
103:               
104:                       case LED_D5:
105:                           LED_D5_LAT = LED_OFF;
0018F2  A9E18E     BCLR LATB, #7
106:                           break;
0018F4  370004     BRA .L9
107:               
108:                       case LED_D6:
109:                           LED_D6_LAT = LED_OFF;
0018F6  A96184     BCLR LATA, #3
110:                           break;
0018F8  370002     BRA .L9
111:               
112:                       case LED_D7:
113:                           LED_D7_LAT = LED_OFF;
0018FA  A94184     BCLR LATA, #2
114:                           break;
0018FC  000000     NOP
115:               
116:                       default:
117:                           break;
0018E2  37000D     BRA .L9
0018EC  370008     BRA .L9
118:                   }
119:               }
0018FE  FA8000     ULNK
001900  060000     RETURN
120:               
121:               /*********************************************************************
122:               * Function: void LED_Toggle(LED led);
123:               *
124:               * Overview: Toggles the state of the requested LED
125:               *
126:               * PreCondition: LED configured via LEDConfigure()
127:               *
128:               * Input: LED led - enumeration of the LEDs available in this
129:               *        demo.  They should be meaningful names and not the names of
130:               *        the LEDs on the silkscreen on the board (as the demo code may
131:               *        be ported to other boards).
132:               *         i.e. - LED_Toggle(LED_CONNECTION_DETECTED);
133:               *
134:               * Output: none
135:               *
136:               ********************************************************************/
137:               void LED_Toggle(LED led)
138:               {
001902  FA0002     LNK #0x2
001904  780F00     MOV W0, [W14]
139:                   switch(led)
001906  78001E     MOV [W14], W0
001908  500FE2     SUB W0, #0x2, [W15]
00190A  320018     BRA Z, .L20
00190C  500FE2     SUB W0, #0x2, [W15]
00190E  3E0003     BRA GTU, .L23
001910  500FE1     SUB W0, #0x1, [W15]
001912  320006     BRA Z, .L19
001916  500FE3     SUB W0, #0x3, [W15]
001918  32001F     BRA Z, .L21
00191A  500FE4     SUB W0, #0x4, [W15]
00191C  32002B     BRA Z, .L22
140:                   {
141:                       case LED_D4:
142:                           LED_D4_LAT ^= 1;
001920  800C70     MOV LATB, W0
001922  DE0048     LSR W0, #8, W0
001924  604061     AND.B W0, #0x1, W0
001926  A20400     BTG.B W0, #0
001928  604061     AND.B W0, #0x1, W0
00192A  FB8000     ZE W0, W0
00192C  600061     AND W0, #0x1, W0
00192E  DD0048     SL W0, #8, W0
001930  800C72     MOV LATB, W2
001932  2FEFF1     MOV #0xFEFF, W1
001934  610081     AND W2, W1, W1
001936  700001     IOR W0, W1, W0
001938  880C70     MOV W0, LATB
143:                           break;
00193A  37002A     BRA .L17
144:               
145:                       case LED_D5:
146:                           LED_D5_LAT ^= 1;
00193C  800C70     MOV LATB, W0
00193E  DE0047     LSR W0, #7, W0
001940  604061     AND.B W0, #0x1, W0
001942  A20400     BTG.B W0, #0
001944  604061     AND.B W0, #0x1, W0
001946  FB8000     ZE W0, W0
001948  600061     AND W0, #0x1, W0
00194A  DD0047     SL W0, #7, W0
00194C  800C72     MOV LATB, W2
00194E  2FF7F1     MOV #0xFF7F, W1
001950  610081     AND W2, W1, W1
001952  700001     IOR W0, W1, W0
001954  880C70     MOV W0, LATB
147:                           break;
001956  37001C     BRA .L17
148:               
149:                       case LED_D6:
150:                           LED_D6_LAT ^= 1;
001958  800C20     MOV LATA, W0
00195A  DE0043     LSR W0, #3, W0
00195C  604061     AND.B W0, #0x1, W0
00195E  A20400     BTG.B W0, #0
001960  604061     AND.B W0, #0x1, W0
001962  FB8000     ZE W0, W0
001964  600061     AND W0, #0x1, W0
001966  DD0043     SL W0, #3, W0
001968  800C22     MOV LATA, W2
00196A  2FFF71     MOV #0xFFF7, W1
00196C  610081     AND W2, W1, W1
00196E  700001     IOR W0, W1, W0
001970  880C20     MOV W0, LATA
151:                           break;
001972  37000E     BRA .L17
152:               
153:                       case LED_D7:
154:                           LED_D7_LAT ^= 1;
001974  800C20     MOV LATA, W0
001976  DE0042     LSR W0, #2, W0
001978  604061     AND.B W0, #0x1, W0
00197A  A20400     BTG.B W0, #0
00197C  604061     AND.B W0, #0x1, W0
00197E  FB8000     ZE W0, W0
001980  600061     AND W0, #0x1, W0
001982  DD0042     SL W0, #2, W0
001984  800C22     MOV LATA, W2
001986  2FFFB1     MOV #0xFFFB, W1
001988  610081     AND W2, W1, W1
00198A  700001     IOR W0, W1, W0
00198C  880C20     MOV W0, LATA
155:                           break;
00198E  000000     NOP
156:               
157:                       default:
158:                           break;
001914  37003D     BRA .L17
00191E  370038     BRA .L17
159:                   }
160:               }
001990  FA8000     ULNK
001992  060000     RETURN
161:               
162:               /*********************************************************************
163:               * Function: bool LED_Get(LED led);
164:               *
165:               * Overview: Returns the current state of the requested LED
166:               *
167:               * PreCondition: LED configured via LEDConfigure()
168:               *
169:               * Input: LED led - enumeration of the LEDs available in this
170:               *        demo.  They should be meaningful names and not the names of
171:               *        the LEDs on the silkscreen on the board (as the demo code may
172:               *        be ported to other boards).
173:               *         i.e. - LED_Get(LED_CONNECTION_DETECTED);
174:               *
175:               * Output: true if on, false if off
176:               *
177:               ********************************************************************/
178:               bool LED_Get(LED led)
179:               {
001994  FA0002     LNK #0x2
001996  780F00     MOV W0, [W14]
180:                   switch(led)
001998  78001E     MOV [W14], W0
00199A  500FE2     SUB W0, #0x2, [W15]
00199C  320013     BRA Z, .L28
00199E  500FE2     SUB W0, #0x2, [W15]
0019A0  3E0003     BRA GTU, .L31
0019A2  500FE1     SUB W0, #0x1, [W15]
0019A4  320006     BRA Z, .L27
0019A6  370027     BRA .L26
0019A8  500FE3     SUB W0, #0x3, [W15]
0019AA  320015     BRA Z, .L29
0019AC  500FE4     SUB W0, #0x4, [W15]
0019AE  32001B     BRA Z, .L30
0019B0  370022     BRA .L26
181:                   {
182:                       case LED_D4:
183:                           return ( ( LED_D4_LAT == LED_ON ) ? true : false ) ;
0019B2  800C71     MOV LATB, W1
0019B4  201000     MOV #0x100, W0
0019B6  608000     AND W1, W0, W0
0019B8  A7F000     BTSC W0, #15
0019BA  EA0000     NEG W0, W0
0019BC  EA0000     NEG W0, W0
0019BE  DE004F     LSR W0, #15, W0
0019C0  784000     MOV.B W0, W0
0019C2  37001A     BRA .L32
184:               
185:                       case LED_D5:
186:                           return ( (LED_D5_LAT == LED_ON) ? true : false );
0019C4  800C71     MOV LATB, W1
0019C6  200800     MOV #0x80, W0
0019C8  608000     AND W1, W0, W0
0019CA  A7F000     BTSC W0, #15
0019CC  EA0000     NEG W0, W0
0019CE  EA0000     NEG W0, W0
0019D0  DE004F     LSR W0, #15, W0
0019D2  784000     MOV.B W0, W0
0019D4  370011     BRA .L32
187:               
188:                       case LED_D6:
189:                           return ( (LED_D6_LAT == LED_ON) ? true : false );
0019D6  800C20     MOV LATA, W0
0019D8  600068     AND W0, #0x8, W0
0019DA  A7F000     BTSC W0, #15
0019DC  EA0000     NEG W0, W0
0019DE  EA0000     NEG W0, W0
0019E0  DE004F     LSR W0, #15, W0
0019E2  784000     MOV.B W0, W0
0019E4  370009     BRA .L32
190:               
191:                       case LED_D7:
192:                           return ( (LED_D7_LAT == LED_ON) ? true : false );
0019E6  800C20     MOV LATA, W0
0019E8  600064     AND W0, #0x4, W0
0019EA  A7F000     BTSC W0, #15
0019EC  EA0000     NEG W0, W0
0019EE  EA0000     NEG W0, W0
0019F0  DE004F     LSR W0, #15, W0
0019F2  784000     MOV.B W0, W0
0019F4  370001     BRA .L32
193:               
194:                       default:
195:                           break;
196:                   }
197:                   return false;
0019F6  EB4000     CLR.B W0
198:               }
0019F8  FA8000     ULNK
0019FA  060000     RETURN
199:               
200:               /*********************************************************************
201:               * Function: void LED_Enable(LED led);
202:               *
203:               * Overview: Configures the LED for use by the other LED API
204:               *
205:               * PreCondition: none
206:               *
207:               * Input: LED led - enumeration of the LEDs available in this
208:               *        demo.  They should be meaningful names and not the names of
209:               *        the LEDs on the silkscreen on the board (as the demo code may
210:               *        be ported to other boards).
211:               *
212:               * Output: none
213:               *
214:               ********************************************************************/
215:               void LED_Enable(LED led)
216:               {
0019FC  FA0002     LNK #0x2
0019FE  780F00     MOV W0, [W14]
217:                   switch(led)
001A00  78001E     MOV [W14], W0
001A02  500FE2     SUB W0, #0x2, [W15]
001A04  32000C     BRA Z, .L36
001A06  500FE2     SUB W0, #0x2, [W15]
001A08  3E0003     BRA GTU, .L39
001A0A  500FE1     SUB W0, #0x1, [W15]
001A0C  320006     BRA Z, .L35
001A10  500FE3     SUB W0, #0x3, [W15]
001A12  320007     BRA Z, .L37
001A14  500FE4     SUB W0, #0x4, [W15]
001A16  320007     BRA Z, .L38
218:                   {
219:                       case LED_D4:
220:                           LED_D4_TRIS = PIN_OUTPUT;
001A1A  A9018B     BCLR 0x18B, #0
221:                           break;
001A1C  370006     BRA .L33
222:               
223:                       case LED_D5:
224:                           LED_D5_TRIS = PIN_OUTPUT;
001A1E  A9E18A     BCLR TRISB, #7
225:                           break;
001A20  370004     BRA .L33
226:               
227:                       case LED_D6:
228:                           LED_D6_TRIS = PIN_OUTPUT;
001A22  A96180     BCLR TRISA, #3
229:                           break;
001A24  370002     BRA .L33
230:               
231:                       case LED_D7:
232:                           LED_D7_TRIS = PIN_OUTPUT;
001A26  A94180     BCLR TRISA, #2
233:                           break;
001A28  000000     NOP
234:               
235:                       default:
236:                           break;
001A0E  37000D     BRA .L33
001A18  370008     BRA .L33
237:                   }
238:               }
001A2A  FA8000     ULNK
001A2C  060000     RETURN
239:               
---  C:/Users/imada/OneDrive/Documents/MPLAB X/IR_Splitted_KB/IR_Splitted_Master.X/buttons.c  -----------
1:                 /*******************************************************************************
2:                 Copyright 2016 Microchip Technology Inc. (www.microchip.com)
3:                 
4:                 Licensed under the Apache License, Version 2.0 (the "License");
5:                 you may not use this file except in compliance with the License.
6:                 You may obtain a copy of the License at
7:                 
8:                     http://www.apache.org/licenses/LICENSE-2.0
9:                 
10:                Unless required by applicable law or agreed to in writing, software
11:                distributed under the License is distributed on an "AS IS" BASIS,
12:                WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
13:                See the License for the specific language governing permissions and
14:                limitations under the License.
15:                *******************************************************************************/
16:                
17:                #include <xc.h>
18:                
19:                #include <stdbool.h>
20:                
21:                #include "buttons.h"
22:                
23:                /*** Button Definitions *********************************************/
24:                #define S1_PORT  (PORTAbits.RA0|1)
25:                #define S2_PORT  (PORTAbits.RA1|1)
26:                #define S3_PORT  (PORTBbits.RB3|1)
27:                
28:                #define S1_TRIS  TRISAbits.TRISA0
29:                #define S2_TRIS  TRISAbits.TRISA1
30:                #define S3_TRIS  TRISBbits.TRISB3
31:                
32:                #define BUTTON_PRESSED      0
33:                #define BUTTON_NOT_PRESSED  1
34:                
35:                #define PIN_INPUT           1
36:                #define PIN_OUTPUT          0
37:                
38:                /*********************************************************************
39:                 * Function: bool BUTTON_IsPressed(BUTTON button);
40:                 *
41:                 * Overview: Returns the current state of the requested button
42:                 *
43:                 * PreCondition: button configured via BUTTON_SetConfiguration()
44:                 *
45:                 * Input: BUTTON button - enumeration of the buttons available in
46:                 *        this demo.  They should be meaningful names and not the names
47:                 *        of the buttons on the silk-screen on the board (as the demo
48:                 *        code may be ported to other boards).
49:                 *         i.e. - ButtonIsPressed(BUTTON_SEND_MESSAGE);
50:                 *
51:                 * Output: true if pressed; false if not pressed.
52:                 *
53:                 ********************************************************************/
54:                bool BUTTON_IsPressed ( BUTTON button )
55:                {
001C0A  FA0002     LNK #0x2
001C0C  780F00     MOV W0, [W14]
56:                    switch(button)
001C0E  78001E     MOV [W14], W0
001C10  500FE2     SUB W0, #0x2, [W15]
001C12  32000C     BRA Z, .L4
001C14  500FE3     SUB W0, #0x3, [W15]
001C16  320012     BRA Z, .L5
001C18  500FE1     SUB W0, #0x1, [W15]
001C1A  3A0018     BRA NZ, .L7
57:                    {
58:                        case BUTTON_S1:
59:                            return ( (S1_PORT == BUTTON_PRESSED) ? true : false);
001C1C  800C10     MOV PORTA, W0
001C1E  EB0000     CLR W0
001C20  A7F000     BTSC W0, #15
001C22  EA0000     NEG W0, W0
001C24  EA0000     NEG W0, W0
001C26  DE004F     LSR W0, #15, W0
001C28  784000     MOV.B W0, W0
001C2A  370011     BRA .L6
60:                
61:                        case BUTTON_S2:
62:                            return ( (S2_PORT == BUTTON_PRESSED) ? true : false);
001C2C  800C10     MOV PORTA, W0
001C2E  EB0000     CLR W0
001C30  A7F000     BTSC W0, #15
001C32  EA0000     NEG W0, W0
001C34  EA0000     NEG W0, W0
001C36  DE004F     LSR W0, #15, W0
001C38  784000     MOV.B W0, W0
001C3A  370009     BRA .L6
63:                
64:                        case BUTTON_S3:
65:                            return ( (S3_PORT == BUTTON_PRESSED) ? true : false);
001C3C  800C60     MOV PORTB, W0
001C3E  EB0000     CLR W0
001C40  A7F000     BTSC W0, #15
001C42  EA0000     NEG W0, W0
001C44  EA0000     NEG W0, W0
001C46  DE004F     LSR W0, #15, W0
001C48  784000     MOV.B W0, W0
001C4A  370001     BRA .L6
66:                
67:                        default:
68:                            return false;
001C4C  EB4000     CLR.B W0
69:                    }
70:                    
71:                    return false;
72:                }
001C4E  FA8000     ULNK
001C50  060000     RETURN
73:                
74:                /*********************************************************************
75:                * Function: void BUTTON_Enable(BUTTON button);
76:                *
77:                * Overview: Returns the current state of the requested button
78:                *
79:                * PreCondition: button configured via BUTTON_SetConfiguration()
80:                *
81:                * Input: BUTTON button - enumeration of the buttons available in
82:                *        this demo.  They should be meaningful names and not the names
83:                *        of the buttons on the silk-screen on the board (as the demo
84:                *        code may be ported to other boards).
85:                *         i.e. - ButtonIsPressed(BUTTON_SEND_MESSAGE);
86:                *
87:                * Output: None
88:                *
89:                ********************************************************************/
90:                void BUTTON_Enable(BUTTON button)
91:                {
001C52  FA0002     LNK #0x2
001C54  780F00     MOV W0, [W14]
92:                    switch(button)
001C56  78001E     MOV [W14], W0
001C58  500FE2     SUB W0, #0x2, [W15]
001C5A  320006     BRA Z, .L11
001C5C  500FE3     SUB W0, #0x3, [W15]
001C5E  320006     BRA Z, .L12
001C60  500FE1     SUB W0, #0x1, [W15]
001C62  3A0007     BRA NZ, .L14
93:                    {
94:                        case BUTTON_S1:
95:                            S1_TRIS = PIN_INPUT ;
001C64  A80180     BSET TRISA, #0
96:                            break ;
001C66  370006     BRA .L8
97:                
98:                        case BUTTON_S2:
99:                            S2_TRIS = PIN_INPUT;
001C68  A82180     BSET TRISA, #1
100:                           break;
001C6A  370004     BRA .L8
101:               
102:                       case BUTTON_S3:
103:                           S3_TRIS = PIN_INPUT;
001C6C  A8618A     BSET TRISB, #3
104:                           break;
001C6E  000000     NOP
001C70  370001     BRA .L8
105:               
106:                       default:
107:                           break ;
001C72  000000     NOP
108:                   }
109:               }
001C74  FA8000     ULNK
001C76  060000     RETURN
---  C:/Users/imada/OneDrive/Documents/MPLAB X/IR_Splitted_KB/IR_Splitted_Master.X/app_led_usb_status.c  
1:                 /*******************************************************************************
2:                 Copyright 2016 Microchip Technology Inc. (www.microchip.com)
3:                 
4:                 Licensed under the Apache License, Version 2.0 (the "License");
5:                 you may not use this file except in compliance with the License.
6:                 You may obtain a copy of the License at
7:                 
8:                     http://www.apache.org/licenses/LICENSE-2.0
9:                 
10:                Unless required by applicable law or agreed to in writing, software
11:                distributed under the License is distributed on an "AS IS" BASIS,
12:                WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
13:                See the License for the specific language governing permissions and
14:                limitations under the License.
15:                
16:                To request to license the code under the MLA license (www.microchip.com/mla_license), 
17:                please contact mla_licensing@microchip.com
18:                *******************************************************************************/
19:                
20:                // *****************************************************************************
21:                // *****************************************************************************
22:                // Section: Included Files
23:                // *****************************************************************************
24:                // *****************************************************************************
25:                #include <stdint.h>
26:                #include "system.h"
27:                #include "usb_device.h"
28:                
29:                // *****************************************************************************
30:                // *****************************************************************************
31:                // Section: File Scope or Global Constants
32:                // *****************************************************************************
33:                // *****************************************************************************
34:                
35:                
36:                // *****************************************************************************
37:                // *****************************************************************************
38:                // Section: File Scope Data Types
39:                // *****************************************************************************
40:                // *****************************************************************************
41:                
42:                
43:                // *****************************************************************************
44:                // *****************************************************************************
45:                // Section: Macros or Functions
46:                // *****************************************************************************
47:                // *****************************************************************************
48:                
49:                void APP_LEDUpdateUSBStatus(void)
50:                {
001B96  FA0000     LNK #0x0
51:                    static uint16_t ledCount = 0;
52:                
53:                    if(USBIsDeviceSuspended() == true)
001B98  802040     MOV U1PWRC, W0
001B9A  600062     AND W0, #0x2, W0
001B9C  E00000     CP0 W0
001B9E  320003     BRA Z, .L2
54:                    {
55:                        LED_Off(LED_USB_DEVICE_STATE);
001BA0  200010     MOV #0x1, W0
001BA2  07FE96     RCALL LED_Off
56:                        return;
001BA4  370030     BRA .L1
57:                    }
58:                
59:                    switch(USBGetDeviceState())
001BA6  804001     MOV USBDeviceState, W1
001BA8  200200     MOV #0x20, W0
001BAA  508F80     SUB W1, W0, [W15]
001BAC  3A0013     BRA NZ, .L13
60:                    {         
61:                        case CONFIGURED_STATE:
62:                            /* We are configured.  Blink fast.
63:                             * On for 75ms, off for 75ms, then reset/repeat. */
64:                            if(ledCount == 1)
001BAE  8041E0     MOV ledCount, W0
001BB0  500FE1     SUB W0, #0x1, [W15]
001BB2  3A0003     BRA NZ, .L6
65:                            {
66:                                LED_On(LED_USB_DEVICE_STATE);
001BB4  200010     MOV #0x1, W0
001BB6  07FE73     RCALL LED_On
67:                            }
68:                            else if(ledCount == 75)
001BBA  8041E1     MOV ledCount, W1
001BBC  2004B0     MOV #0x4B, W0
001BBE  508F80     SUB W1, W0, [W15]
001BC0  3A0003     BRA NZ, .L8
69:                            {
70:                                LED_Off(LED_USB_DEVICE_STATE);
001BC2  200010     MOV #0x1, W0
001BC4  07FE85     RCALL LED_Off
71:                            }
72:                            else if(ledCount > 150)
001BC8  8041E1     MOV ledCount, W1
001BCA  200960     MOV #0x96, W0
001BCC  508F80     SUB W1, W0, [W15]
001BCE  360015     BRA LEU, .L14
73:                            {
74:                                ledCount = 0;
001BD0  EF283C     CLR ledCount
75:                            }
76:                            break;
001BB8  370023     BRA .L9
001BC6  37001C     BRA .L9
001BD2  370016     BRA .L9
001BFA  000000     NOP
001BFC  370001     BRA .L9
77:                
78:                        default:
79:                            /* We aren't configured yet, but we aren't suspended so let's blink with
80:                             * a slow pulse. On for 50ms, then off for 950ms, then reset/repeat. */
81:                            if(ledCount == 1)
001BD4  8041E0     MOV ledCount, W0
001BD6  500FE1     SUB W0, #0x1, [W15]
001BD8  3A0003     BRA NZ, .L10
82:                            {
83:                                LED_On(LED_USB_DEVICE_STATE);
001BDA  200010     MOV #0x1, W0
001BDC  07FE60     RCALL LED_On
84:                            }
85:                            else if(ledCount == 50)
001BE0  8041E1     MOV ledCount, W1
001BE2  200320     MOV #0x32, W0
001BE4  508F80     SUB W1, W0, [W15]
001BE6  3A0003     BRA NZ, .L12
86:                            {
87:                                LED_Off(LED_USB_DEVICE_STATE);
001BE8  200010     MOV #0x1, W0
001BEA  07FE72     RCALL LED_Off
88:                            }
89:                            else if(ledCount > 950)
001BEE  8041E1     MOV ledCount, W1
001BF0  203B60     MOV #0x3B6, W0
001BF2  508F80     SUB W1, W0, [W15]
001BF4  360004     BRA LEU, .L15
90:                            {
91:                                ledCount = 0;
001BF6  EF283C     CLR ledCount
92:                            }
93:                            break;
001BDE  370010     BRA .L9
001BEC  370009     BRA .L9
001BF8  370003     BRA .L9
001BFE  000000     NOP
94:                    }
95:                
96:                    /* Increment the millisecond counter. */
97:                    ledCount++;
001C00  8041E0     MOV ledCount, W0
001C02  E80000     INC W0, W0
001C04  8841E0     MOV W0, ledCount
98:                }
001C06  FA8000     ULNK
001C08  060000     RETURN
99:                
100:               /*******************************************************************************
101:                End of File
102:               */
---  C:/Users/imada/OneDrive/Documents/MPLAB X/IR_Splitted_KB/IR_Splitted_Master.X/app_device_keyboard.c  
1:                 /*******************************************************************************
2:                 Copyright 2016 Microchip Technology Inc. (www.microchip.com)
3:                 
4:                 Licensed under the Apache License, Version 2.0 (the "License");
5:                 you may not use this file except in compliance with the License.
6:                 You may obtain a copy of the License at
7:                 
8:                 	http://www.apache.org/licenses/LICENSE-2.0
9:                 
10:                Unless required by applicable law or agreed to in writing, software
11:                distributed under the License is distributed on an "AS IS" BASIS,
12:                WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
13:                See the License for the specific language governing permissions and
14:                limitations under the License.
15:                
16:                To request to license the code under the MLA license (www.microchip.com/mla_license), 
17:                please contact mla_licensing@microchip.com
18:                 *******************************************************************************/
19:                
20:                // *****************************************************************************
21:                // *****************************************************************************
22:                // Section: Included Files
23:                // *****************************************************************************
24:                // *****************************************************************************
25:                #include <stdint.h>
26:                #include <string.h>
27:                
28:                #include "system.h"
29:                #include "usb.h"
30:                #include "usb_device_hid.h"
31:                
32:                #include "app_led_usb_status.h"
33:                #include "HID_Define.h"
34:                
35:                // *****************************************************************************
36:                // *****************************************************************************
37:                // Section: File Scope or Global Constants
38:                // *****************************************************************************
39:                // *****************************************************************************
40:                
41:                //Class specific descriptor - HID Keyboard
42:                
43:                const struct {
44:                	uint8_t report[HID_RPT01_SIZE];
45:                } hid_rpt01 = {
46:                	{ 0x05, 0x01, // USAGE_PAGE (Generic Desktop)
47:                		0x09, 0x06, // USAGE (Keyboard)
48:                		0xa1, 0x01, // COLLECTION (Application)
49:                		0x05, 0x07, //   USAGE_PAGE (Keyboard)
50:                		0x19, 0xe0, //   USAGE_MINIMUM (Keyboard LeftControl)
51:                		0x29, 0xe7, //   USAGE_MAXIMUM (Keyboard Right GUI)
52:                		0x15, 0x00, //   LOGICAL_MINIMUM (0)
53:                		0x25, 0x01, //   LOGICAL_MAXIMUM (1)
54:                		0x75, 0x01, //   REPORT_SIZE (1)
55:                		0x95, 0x08, //   REPORT_COUNT (8)
56:                		0x81, 0x02, //   INPUT (Data,Var,Abs)
57:                		0x95, 0x01, //   REPORT_COUNT (1)
58:                		0x75, 0x08, //   REPORT_SIZE (8)
59:                		0x81, 0x03, //   INPUT (Cnst,Var,Abs)
60:                		0x95, 0x05, //   REPORT_COUNT (5)
61:                		0x75, 0x01, //   REPORT_SIZE (1)
62:                		0x05, 0x08, //   USAGE_PAGE (LEDs)
63:                		0x19, 0x01, //   USAGE_MINIMUM (Num Lock)
64:                		0x29, 0x05, //   USAGE_MAXIMUM (Kana)
65:                		0x91, 0x02, //   OUTPUT (Data,Var,Abs)
66:                		0x95, 0x01, //   REPORT_COUNT (1)
67:                		0x75, 0x03, //   REPORT_SIZE (3)
68:                		0x91, 0x03, //   OUTPUT (Cnst,Var,Abs)
69:                		0x95, 0x06, //   REPORT_COUNT (6)
70:                		0x75, 0x08, //   REPORT_SIZE (8)
71:                		0x15, 0x00, //   LOGICAL_MINIMUM (0)
72:                		0x25, 0x65, //   LOGICAL_MAXIMUM (101)
73:                		0x05, 0x07, //   USAGE_PAGE (Keyboard)
74:                		0x19, 0x00, //   USAGE_MINIMUM (Reserved (no event indicated))
75:                		0x29, 0x65, //   USAGE_MAXIMUM (Keyboard Application)
76:                		0x81, 0x00, //   INPUT (Data,Ary,Abs)
77:                		0xc0} // End Collection
78:                };
79:                
80:                
81:                // *****************************************************************************
82:                // *****************************************************************************
83:                // Section: File Scope Data Types
84:                // *****************************************************************************
85:                // *****************************************************************************
86:                
87:                /* This typedef defines the only INPUT report found in the HID report
88:                 * descriptor and gives an easy way to create the OUTPUT report. */
89:                typedef struct __attribute__((packed))
90:                {
91:                
92:                	/* The union below represents the first byte of the INPUT report.  It is
93:                	 * formed by the following HID report items:
94:                	 *
95:                	 *  0x19, 0xe0, //   USAGE_MINIMUM (Keyboard LeftControl)
96:                	 *  0x29, 0xe7, //   USAGE_MAXIMUM (Keyboard Right GUI)
97:                	 *  0x15, 0x00, //   LOGICAL_MINIMUM (0)
98:                	 *  0x25, 0x01, //   LOGICAL_MAXIMUM (1)
99:                	 *  0x75, 0x01, //   REPORT_SIZE (1)
100:               	 *  0x95, 0x08, //   REPORT_COUNT (8)
101:               	 *  0x81, 0x02, //   INPUT (Data,Var,Abs)
102:               	 *
103:               	 * The report size is 1 specifying 1 bit per entry.
104:               	 * The report count is 8 specifying there are 8 entries.
105:               	 * These entries represent the Usage items between Left Control (the usage
106:               	 * minimum) and Right GUI (the usage maximum).
107:               	 */
108:               	union __attribute__((packed))
109:               	{
110:               		uint8_t value;
111:               
112:               		struct __attribute__((packed))
113:               		{
114:               			unsigned leftControl : 1;
115:               			unsigned leftShift : 1;
116:               			unsigned leftAlt : 1;
117:               			unsigned leftGUI : 1;
118:               			unsigned rightControl : 1;
119:               			unsigned rightShift : 1;
120:               			unsigned rightAlt : 1;
121:               			unsigned rightGUI : 1;
122:               		}
123:               		bits;
124:               	}
125:               	modifiers;
126:               
127:               	/* There is one byte of constant data/padding that is specified in the
128:               	 * input report:
129:               	 *
130:               	 *  0x95, 0x01,                    //   REPORT_COUNT (1)
131:               	 *  0x75, 0x08,                    //   REPORT_SIZE (8)
132:               	 *  0x81, 0x03,                    //   INPUT (Cnst,Var,Abs)
133:               	 */
134:               	unsigned : 8;
135:               
136:               	/* The last INPUT item in the INPUT report is an array type.  This array
137:               	 * contains an entry for each of the keys that are currently pressed until
138:               	 * the array limit, in this case 6 concurent key presses.
139:               	 *
140:               	 *  0x95, 0x06,                    //   REPORT_COUNT (6)
141:               	 *  0x75, 0x08,                    //   REPORT_SIZE (8)
142:               	 *  0x15, 0x00,                    //   LOGICAL_MINIMUM (0)
143:               	 *  0x25, 0x65,                    //   LOGICAL_MAXIMUM (101)
144:               	 *  0x05, 0x07,                    //   USAGE_PAGE (Keyboard)
145:               	 *  0x19, 0x00,                    //   USAGE_MINIMUM (Reserved (no event indicated))
146:               	 *  0x29, 0x65,                    //   USAGE_MAXIMUM (Keyboard Application)
147:               	 *
148:               	 * Report count is 6 indicating that the array has 6 total entries.
149:               	 * Report size is 8 indicating each entry in the array is one byte.
150:               	 * The usage minimum indicates the lowest key value (Reserved/no event)
151:               	 * The usage maximum indicates the highest key value (Application button)
152:               	 * The logical minimum indicates the remapped value for the usage minimum:
153:               	 *   No Event has a logical value of 0.
154:               	 * The logical maximum indicates the remapped value for the usage maximum:
155:               	 *   Application button has a logical value of 101.
156:               	 *
157:               	 * In this case the logical min/max match the usage min/max so the logical
158:               	 * remapping doesn't actually change the values.
159:               	 *
160:               	 * To send a report with the 'a' key pressed (usage value of 0x04, logical
161:               	 * value in this example of 0x04 as well), then the array input would be the
162:               	 * following:
163:               	 *
164:               	 * LSB [0x04][0x00][0x00][0x00][0x00][0x00] MSB
165:               	 *
166:               	 * If the 'b' button was then pressed with the 'a' button still held down,
167:               	 * the report would then look like this:
168:               	 *
169:               	 * LSB [0x04][0x05][0x00][0x00][0x00][0x00] MSB
170:               	 *
171:               	 * If the 'a' button was then released with the 'b' button still held down,
172:               	 * the resulting array would be the following:
173:               	 *
174:               	 * LSB [0x05][0x00][0x00][0x00][0x00][0x00] MSB
175:               	 *
176:               	 * The 'a' key was removed from the array and all other items in the array
177:               	 * were shifted down. */
178:               	uint8_t keys[6];
179:               }
180:               KEYBOARD_INPUT_REPORT;
181:               
182:               /* This typedef defines the only OUTPUT report found in the HID report
183:                * descriptor and gives an easy way to parse the OUTPUT report. */
184:               typedef union __attribute__((packed))
185:               {
186:               	/* The OUTPUT report is comprised of only one byte of data. */
187:               	uint8_t value;
188:               
189:               	struct {
190:               		/* There are two report items that form the one byte of OUTPUT report
191:               		 * data.  The first report item defines 5 LED indicators:
192:               		 *
193:               		 *  0x95, 0x05,                    //   REPORT_COUNT (5)
194:               		 *  0x75, 0x01,                    //   REPORT_SIZE (1)
195:               		 *  0x05, 0x08,                    //   USAGE_PAGE (LEDs)
196:               		 *  0x19, 0x01,                    //   USAGE_MINIMUM (Num Lock)
197:               		 *  0x29, 0x05,                    //   USAGE_MAXIMUM (Kana)
198:               		 *  0x91, 0x02,                    //   OUTPUT (Data,Var,Abs)
199:               		 *
200:               		 * The report count indicates there are 5 entries.
201:               		 * The report size is 1 indicating each entry is just one bit.
202:               		 * These items are located on the LED usage page
203:               		 * These items are all of the usages between Num Lock (the usage
204:               		 * minimum) and Kana (the usage maximum).
205:               		 */
206:               		unsigned numLock : 1;
207:               		unsigned capsLock : 1;
208:               		unsigned scrollLock : 1;
209:               		unsigned compose : 1;
210:               		unsigned kana : 1;
211:               
212:               		/* The second OUTPUT report item defines 3 bits of constant data
213:               		 * (padding) used to make a complete byte:
214:               		 *
215:               		 *  0x95, 0x01,                    //   REPORT_COUNT (1)
216:               		 *  0x75, 0x03,                    //   REPORT_SIZE (3)
217:               		 *  0x91, 0x03,                    //   OUTPUT (Cnst,Var,Abs)
218:               		 *
219:               		 * Report count of 1 indicates that there is one entry
220:               		 * Report size of 3 indicates the entry is 3 bits long. */
221:               		unsigned : 3;
222:               	} leds;
223:               }
224:               KEYBOARD_OUTPUT_REPORT;
225:               
226:               /* This creates a storage type for all of the information required to track the
227:                * current state of the keyboard. */
228:               typedef struct {
229:               	USB_HANDLE lastINTransmission;
230:               	USB_HANDLE lastOUTTransmission;
231:               	unsigned char key;
232:               	bool waitingForRelease;
233:               } KEYBOARD;
234:               
235:               // *****************************************************************************
236:               // *****************************************************************************
237:               // Section: File Scope or Global Variables
238:               // *****************************************************************************
239:               // *****************************************************************************
240:               static KEYBOARD keyboard;
241:               
242:               #if !defined(KEYBOARD_INPUT_REPORT_DATA_BUFFER_ADDRESS_TAG)
243:               #define KEYBOARD_INPUT_REPORT_DATA_BUFFER_ADDRESS_TAG
244:               #endif
245:               static KEYBOARD_INPUT_REPORT inputReport KEYBOARD_INPUT_REPORT_DATA_BUFFER_ADDRESS_TAG;
246:               
247:               #if !defined(KEYBOARD_OUTPUT_REPORT_DATA_BUFFER_ADDRESS_TAG)
248:               #define KEYBOARD_OUTPUT_REPORT_DATA_BUFFER_ADDRESS_TAG
249:               #endif
250:               static volatile KEYBOARD_OUTPUT_REPORT outputReport KEYBOARD_OUTPUT_REPORT_DATA_BUFFER_ADDRESS_TAG;
251:               
252:               const uint16_t keymap[] = {
253:               	//0     1     2     3     4     5     6     7  //   8     9     A     B
254:               	ESC_, _F1_, _F2_, _F3_, _F4_, _F5_, _F6_, _F7_, //_F8_, // _F9_, F10_, F11_, F12_, ____, ____, ____, ____, //0x0n
255:               	BSP_, APOS, __1_, __2_, __3_, __4_, __5_, __6_, //__7_, __8_, // __9_, __0_, MIN_, EQU_, ____, ____, ____, ____, //0x0n
256:               	P_UP, TAB_, __Q_, __W_, __E_, __R_, __T_, __Y_, //__U_, // __I_, __O_, __P_, BSP_, GRAV, BR_L, BR_R, ____, ____, ____, ____, //0x1n
257:               	P_UP, CAPS, __A_, __S_, __D_, __F_, __G_, ____, //__H_, __J_, // __K_, __L_, DEL_, ENT_, ____, ____, ____, ____, //0x2n
258:               	P_DN, SHLL, __Z_, __X_, __C_, __V_, __B_, ____, //__N_, __M_, // COMM, DOT_, C_UP, SHRL, ____, ____, ____, ____, //0x3n
259:               	P_DN, ____, CTLL, GULL, ALLL, _SP_, FN_L, ____, // FNRL, C_LT, C_DN, C_RT, ____, ____, ____, ____, //0x4n
260:               	//	CONN, SHDN, _SP_, SEMI, SLAS, BSLA, PREV, PLAY, NEXT, V_DN, V_UP, ____, ____, ____, ____, //0x5n
261:               };
262:               
263:               
264:               // *****************************************************************************
265:               // *****************************************************************************
266:               // Section: Private Prototypes
267:               // *****************************************************************************
268:               // *****************************************************************************
269:               static void APP_KeyboardProcessOutputReport(void);
270:               
271:               
272:               //Exteranl variables declared in other .c files
273:               extern volatile signed int SOFCounter;
274:               
275:               
276:               //Application variables that need wide scope
277:               KEYBOARD_INPUT_REPORT oldInputReport;
278:               signed int keyboardIdleRate;
279:               signed int LocalSOFCount;
280:               static signed int OldSOFCount;
281:               
282:               
283:               
284:               
285:               // *****************************************************************************
286:               // *****************************************************************************
287:               // Section: Macros or Functions
288:               // *****************************************************************************
289:               // *****************************************************************************
290:               
291:               void APP_KeyboardInit(void)
292:               {
0016BA  FA0000     LNK #0x0
293:               	//initialize the variable holding the handle for the last
294:               	// transmission
295:               	keyboard.lastINTransmission = 0;
0016BC  EB0000     CLR W0
0016BE  884300     MOV W0, keyboard
296:               
297:               	keyboard.key = 4;
0016C0  208640     MOV #0x864, W0
0016C2  B3C041     MOV.B #0x4, W1
0016C4  784801     MOV.B W1, [W0]
298:               	keyboard.waitingForRelease = false;
0016C6  208650     MOV #0x865, W0
0016C8  EB4080     CLR.B W1
0016CA  784801     MOV.B W1, [W0]
299:               
300:               	//Set the default idle rate to 500ms (until the host sends a SET_IDLE request to change it to a new value)
301:               	keyboardIdleRate = 500;
0016CC  201F40     MOV #0x1F4, W0
0016CE  884180     MOV W0, keyboardIdleRate
302:               
303:               	//Copy the (possibly) interrupt context SOFCounter value into a local variable.
304:               	//Using a while() loop to do this since the SOFCounter isn't necessarily atomically
305:               	//updated and therefore we need to read it a minimum of twice to ensure we captured the correct value.
306:               	while (OldSOFCount != SOFCounter) {
0016D0  370002     BRA .L2
0016D6  8041A1     MOV OldSOFCount, W1
0016D8  8041C0     MOV SOFCounter, W0
0016DA  508F80     SUB W1, W0, [W15]
0016DC  3AFFFA     BRA NZ, .L3
307:               		OldSOFCount = SOFCounter;
0016D2  8041C0     MOV SOFCounter, W0
0016D4  8841A0     MOV W0, OldSOFCount
308:               	}
309:               
310:               	//enable the HID endpoint
311:               	USBEnableEndpoint(HID_EP, USB_IN_ENABLED | USB_OUT_ENABLED | USB_HANDSHAKE_ENABLED | USB_DISALLOW_SETUP);
0016DE  B3C1D1     MOV.B #0x1D, W1
0016E0  B3C010     MOV.B #0x1, W0
0016E2  07F84A     RCALL USBEnableEndpoint
312:               
313:               	//Arm OUT endpoint so we can receive caps lock, num lock, etc. info from host
314:               	keyboard.lastOUTTransmission = HIDRxPacket(HID_EP, (uint8_t*) & outputReport, sizeof (outputReport));
0016E4  B3C023     MOV.B #0x2, W3
0016E6  2086E2     MOV #0x86E, W2
0016E8  EB4080     CLR.B W1
0016EA  B3C010     MOV.B #0x1, W0
0016EC  07F862     RCALL USBTransferOnePacket
0016EE  884310     MOV W0, 0x862
315:               }
0016F0  FA8000     ULNK
0016F2  060000     RETURN
316:               
317:               void APP_KeyboardTasks(void)
318:               {
0016F4  FA0004     LNK #0x4
319:               	signed int TimeDeltaMilliseconds;
320:               	unsigned char i;
321:               	bool needToSendNewReportPacket;
322:               
323:               	/* If the USB device isn't configured yet, we can't really do anything
324:               	 * else since we don't have a host to talk to.  So jump back to the
325:               	 * top of the while loop. */
326:               	if (USBGetDeviceState() < CONFIGURED_STATE) {
0016F6  804000     MOV USBDeviceState, W0
0016F8  500FFF     SUB W0, #0x1F, [W15]
0016FA  360076     BRA LEU, .L21
327:               		return;
0017E8  000000     NOP
0017EA  370001     BRA .L4
328:               	}
329:               
330:               	/* If we are currently suspended, then we need to see if we need to
331:               	 * issue a remote wakeup.  In either case, we shouldn't process any
332:               	 * keyboard commands since we aren't currently communicating to the host
333:               	 * thus just continue back to the start of the while loop. */
334:               	if (USBIsDeviceSuspended() == true) {
0016FC  802040     MOV U1PWRC, W0
0016FE  600062     AND W0, #0x2, W0
001700  E00000     CP0 W0
001702  320006     BRA Z, .L22
335:               		//Check if we should assert a remote wakeup request to the USB host,
336:               		//when the user presses the pushbutton.
337:               		if (BUTTON_IsPressed(BUTTON_USB_DEVICE_REMOTE_WAKEUP) == 0) {
001704  200010     MOV #0x1, W0
001706  070281     RCALL BUTTON_IsPressed
338:               			//Add code here to issue a resume signal.
339:               		}
340:               
341:               		return;
001708  370072     BRA .L4
342:               	}
343:               
344:               	//Copy the (possibly) interrupt context SOFCounter value into a local variable.
345:               	//Using a while() loop to do this since the SOFCounter isn't necessarily atomically
346:               	//updated and we need to read it a minimum of twice to ensure we captured the correct value.
347:               	while (LocalSOFCount != SOFCounter) {
001710  000000     NOP
001712  804191     MOV LocalSOFCount, W1
001714  8041C0     MOV SOFCounter, W0
001716  508F80     SUB W1, W0, [W15]
001718  3AFFF8     BRA NZ, .L9
348:               		LocalSOFCount = SOFCounter;
00170A  8041C0     MOV SOFCounter, W0
00170C  884190     MOV W0, LocalSOFCount
00170E  370001     BRA .L8
349:               	}
350:               
351:               	//Compute the elapsed time since the last input report was sent (we need
352:               	//this info for properly obeying the HID idle rate set by the host).
353:               	TimeDeltaMilliseconds = LocalSOFCount - OldSOFCount;
00171A  804191     MOV LocalSOFCount, W1
00171C  8041A0     MOV OldSOFCount, W0
00171E  508F00     SUB W1, W0, [W14]
354:               	//Check for negative value due to count wraparound back to zero.
355:               	if (TimeDeltaMilliseconds < 0) {
001720  78001E     MOV [W14], W0
001722  E00000     CP0 W0
001724  3D0005     BRA GE, .L10
356:               		TimeDeltaMilliseconds = (32767 - OldSOFCount) + LocalSOFCount;
001726  8041A0     MOV OldSOFCount, W0
001728  27FFF1     MOV #0x7FFF, W1
00172A  508080     SUB W1, W0, W1
00172C  804190     MOV LocalSOFCount, W0
00172E  408F00     ADD W1, W0, [W14]
357:               	}
358:               	//Check if the TimeDelay is quite large.  If the idle rate is == 0 (which represents "infinity"),
359:               	//then the TimeDeltaMilliseconds could also become infinity (which would cause overflow)
360:               	//if there is no recent button presses or other changes occurring on the keyboard.
361:               	//Therefore, saturate the TimeDeltaMilliseconds if it gets too large, by virtue
362:               	//of updating the OldSOFCount, even if we haven't actually sent a packet recently.
363:               	if (TimeDeltaMilliseconds > 5000) {
001730  213880     MOV #0x1388, W0
001732  78009E     MOV [W14], W1
001734  508F80     SUB W1, W0, [W15]
001736  340004     BRA LE, .L11
364:               		OldSOFCount = LocalSOFCount - 5000;
001738  804191     MOV LocalSOFCount, W1
00173A  2EC780     MOV #0xEC78, W0
00173C  408000     ADD W1, W0, W0
00173E  8841A0     MOV W0, OldSOFCount
365:               	}
366:               
367:               
368:               	/* Check if the IN endpoint is busy, and if it isn't check if we want to send
369:               	 * keystroke data to the host. */
370:               	if (HIDTxHandleBusy(keyboard.lastINTransmission) == false) {
001740  804300     MOV keyboard, W0
001742  E00000     CP0 W0
001744  320006     BRA Z, .L12
001746  804300     MOV keyboard, W0
001748  780090     MOV [W0], W1
00174A  280000     MOV #0x8000, W0
00174C  608000     AND W1, W0, W0
00174E  E00000     CP0 W0
001750  3A003A     BRA NZ, .L13
371:               		/* Clear the INPUT report buffer.  Set to all zeros. */
372:               		memset(&inputReport, 0, sizeof (inputReport));
001752  200082     MOV #0x8, W2
001754  EB0080     CLR W1
001756  208660     MOV #0x866, W0
001758  07F62C     RCALL _memset
373:               
374:               		/////////////////////////////
375:               //		if (1) {
376:               //			static uint8_t len = 0;
377:               //			static uint8_t count = 0;
378:               //			static uint8_t report[7] = {0, 0, 0, 0, 0, 0, 0};
379:               //
380:               //			if (U1STAbits.OERR) {
381:               //				U1STAbits.OERR = 0;
382:               //			}
383:               //			while (U1STAbits.URXDA) {
384:               //				LED_Toggle(LED_D7);
385:               //				uint8_t data = U1RXREG;
386:               //				U1TXREG = data;
387:               //				if ((data & 0xc0) == 0x80) {
388:               //					len = (data & 0x38) >> 3;
389:               //					count = 0;
390:               //				} else {
391:               //					data = ~data;
392:               //					if (data < 48) {
393:               //						data = 47 - data;
394:               //						report[count++] = data;
395:               //						if (count < 6) {
396:               //							if (getKeyGroup(keymap[data]) == KEY_NORMAL) {
397:               //								inputReport.keys[count] = keymap[data];
398:               //							}
399:               //							if (getKeyGroup(keymap[data]) == KEY_MODIFIER) {
400:               //								inputReport.modifiers.value |= 1 << (data & 0x07);
401:               //							}
402:               //						}
403:               //					}
404:               //				}
405:               //			}
406:               //		}
407:               		////////////////////////////
408:               
409:               		//		if (BUTTON_IsPressed(BUTTON_USB_DEVICE_HID_KEYBOARD_KEY) == true) {
410:               		//			if (keyboard.waitingForRelease == false) {
411:               		//				keyboard.waitingForRelease = true;
412:               		//
413:               		//				/* Set the only important data, the key press data. */
414:               		//				inputReport.keys[0] = keyboard.key++;
415:               		//
416:               		//				//In this simulated keyboard, if the last key pressed exceeds the a-z + 0-9,
417:               		//				//then wrap back around so we send 'a' again.
418:               		//				if (keyboard.key == 40) {
419:               		//					keyboard.key = 4;
420:               		//				}
421:               		//			}
422:               		//		} else {
423:               		//			keyboard.waitingForRelease = false;
424:               		//		}
425:               
426:               
427:               		//Check to see if the new packet contents are somehow different from the most
428:               		//recently sent packet contents.
429:               		needToSendNewReportPacket = false;
00175A  EB4000     CLR.B W0
00175C  984730     MOV.B W0, [W14+3]
430:               		for (i = 0; i < sizeof (inputReport); i++) {
00175E  EB4000     CLR.B W0
001760  984720     MOV.B W0, [W14+2]
001762  370012     BRA .L14
001782  90402E     MOV.B [W14+2], W0
001784  E84000     INC.B W0, W0
001786  984720     MOV.B W0, [W14+2]
001788  90402E     MOV.B [W14+2], W0
00178A  504FE7     SUB.B W0, #0x7, [W15]
00178C  36FFEB     BRA LEU, .L17
431:               			if (*((uint8_t*) & oldInputReport + i) != *((uint8_t*) & inputReport + i)) {
001764  90402E     MOV.B [W14+2], W0
001766  FB8080     ZE W0, W1
001768  208700     MOV #0x870, W0
00176A  408000     ADD W1, W0, W0
00176C  784090     MOV.B [W0], W1
00176E  90402E     MOV.B [W14+2], W0
001770  FB8100     ZE W0, W2
001772  208660     MOV #0x866, W0
001774  410000     ADD W2, W0, W0
001776  784010     MOV.B [W0], W0
001778  50CF80     SUB.B W1, W0, [W15]
00177A  320003     BRA Z, .L15
432:               				needToSendNewReportPacket = true;
00177C  B3C010     MOV.B #0x1, W0
00177E  984730     MOV.B W0, [W14+3]
433:               				break;
001780  370006     BRA .L16
434:               			}
435:               		}
436:               
437:               		//Check if the host has set the idle rate to something other than 0 (which is effectively "infinite").
438:               		//If the idle rate is non-infinite, check to see if enough time has elapsed since
439:               		//the last packet was sent, and it is time to send a new repeated packet or not.
440:               		if (keyboardIdleRate != 0) {
00178E  804180     MOV keyboardIdleRate, W0
001790  E00000     CP0 W0
001792  320006     BRA Z, .L18
441:               			//Check if the idle rate time limit is met.  If so, need to send another HID input report packet to the host
442:               			if (TimeDeltaMilliseconds >= keyboardIdleRate) {
001794  804180     MOV keyboardIdleRate, W0
001796  78009E     MOV [W14], W1
001798  508F80     SUB W1, W0, [W15]
00179A  350002     BRA LT, .L18
443:               				needToSendNewReportPacket = true;
00179C  B3C010     MOV.B #0x1, W0
00179E  984730     MOV.B W0, [W14+3]
444:               			}
445:               		}
446:               
447:               		//Now send the new input report packet, if it is appropriate to do so (ex: new data is
448:               		//present or the idle rate limit was met).
449:               		if (needToSendNewReportPacket == true) {
0017A0  90403E     MOV.B [W14+3], W0
0017A2  E00400     CP0.B W0
0017A4  320010     BRA Z, .L13
450:               			//Save the old input report packet contents.  We do this so we can detect changes in report packet content
451:               			//useful for determining when something has changed and needs to get re-sent to the host when using
452:               			//infinite idle rate setting.
453:               			oldInputReport = inputReport;
0017A6  804332     MOV inputReport, W2
0017A8  804343     MOV 0x868, W3
0017AA  884382     MOV W2, oldInputReport
0017AC  884393     MOV W3, 0x872
0017AE  804352     MOV 0x86A, W2
0017B0  804363     MOV 0x86C, W3
0017B2  8843A2     MOV W2, 0x874
0017B4  8843B3     MOV W3, 0x876
454:               
455:               			/* Send the 8 byte packet over USB to the host. */
456:               			keyboard.lastINTransmission = HIDTxPacket(HID_EP, (uint8_t*) & inputReport, sizeof (inputReport));
0017B6  B3C083     MOV.B #0x8, W3
0017B8  208662     MOV #0x866, W2
0017BA  B3C011     MOV.B #0x1, W1
0017BC  B3C010     MOV.B #0x1, W0
0017BE  07F7F9     RCALL USBTransferOnePacket
0017C0  884300     MOV W0, keyboard
457:               			OldSOFCount = LocalSOFCount; //Save the current time, so we know when to send the next packet (which depends in part on the idle rate setting)
0017C2  804190     MOV LocalSOFCount, W0
0017C4  8841A0     MOV W0, OldSOFCount
458:               		}
459:               
460:               	}//if(HIDTxHandleBusy(keyboard.lastINTransmission) == false)
461:               
462:               
463:               	/* Check if any data was sent from the PC to the keyboard device.  Report
464:               	 * descriptor allows host to send 1 byte of data.  Bits 0-4 are LED states,
465:               	 * bits 5-7 are unused pad bits.  The host can potentially send this OUT
466:               	 * report data through the HID OUT endpoint (EP1 OUT), or, alternatively,
467:               	 * the host may try to send LED state information by sending a SET_REPORT
468:               	 * control transfer on EP0.  See the USBHIDCBSetReportHandler() function. */
469:               	if (HIDRxHandleBusy(keyboard.lastOUTTransmission) == false) {
0017C6  804310     MOV 0x862, W0
0017C8  E00000     CP0 W0
0017CA  320006     BRA Z, .L19
0017CC  804310     MOV 0x862, W0
0017CE  780090     MOV [W0], W1
0017D0  280000     MOV #0x8000, W0
0017D2  608000     AND W1, W0, W0
0017D4  E00000     CP0 W0
0017D6  3A000A     BRA NZ, .L23
470:               		APP_KeyboardProcessOutputReport();
0017D8  07000C     RCALL _APP_KeyboardProcessOutputReport, .LFE1, .LFB2
471:               
472:               		keyboard.lastOUTTransmission = HIDRxPacket(HID_EP, (uint8_t*) & outputReport, sizeof (outputReport));
0017DA  B3C023     MOV.B #0x2, W3
0017DC  2086E2     MOV #0x86E, W2
0017DE  EB4080     CLR.B W1
0017E0  B3C010     MOV.B #0x1, W0
0017E2  07F7E7     RCALL USBTransferOnePacket
0017E4  884310     MOV W0, 0x862
473:               	}
474:               
475:               	return;
0017E6  370003     BRA .L4
0017EC  000000     NOP
476:               }
0017EE  FA8000     ULNK
0017F0  060000     RETURN
477:               
478:               static void APP_KeyboardProcessOutputReport(void)
479:               {
0017F2  FA0000     LNK #0x0
480:               	if (outputReport.leds.capsLock) {
0017F4  2086E0     MOV #0x86E, W0
0017F6  784010     MOV.B [W0], W0
0017F8  604062     AND.B W0, #0x2, W0
0017FA  E00400     CP0.B W0
0017FC  320003     BRA Z, .L25
481:               		LED_On(LED_USB_DEVICE_HID_KEYBOARD_CAPS_LOCK);
0017FE  200020     MOV #0x2, W0
001800  07004E     RCALL LED_On
001802  370002     BRA .L26
482:               	} else {
483:               		LED_Off(LED_USB_DEVICE_HID_KEYBOARD_CAPS_LOCK);
001804  200020     MOV #0x2, W0
001806  070064     RCALL LED_Off
484:               	}
485:               	if (outputReport.leds.numLock) {
001808  2086E0     MOV #0x86E, W0
00180A  784010     MOV.B [W0], W0
00180C  604061     AND.B W0, #0x1, W0
00180E  E00400     CP0.B W0
001810  320003     BRA Z, .L27
486:               		LED_On(LED_USB_DEVICE_HID_KEYBOARD_KANA);
001812  200030     MOV #0x3, W0
001814  070044     RCALL LED_On
001816  370002     BRA .L24
487:               	} else {
488:               		LED_Off(LED_USB_DEVICE_HID_KEYBOARD_KANA);
001818  200030     MOV #0x3, W0
00181A  07005A     RCALL LED_Off
489:               	}
490:               }
00181C  FA8000     ULNK
00181E  060000     RETURN
491:               
492:               static void USBHIDCBSetReportComplete(void)
493:               {
001820  FA0000     LNK #0x0
494:               	/* 1 byte of LED state data should now be in the CtrlTrfData buffer.  Copy
495:               	 * it to the OUTPUT report buffer for processing */
496:               	outputReport.value = CtrlTrfData[0];
001822  208580     MOV #0x858, W0
001824  784090     MOV.B [W0], W1
001826  2086E0     MOV #0x86E, W0
001828  784801     MOV.B W1, [W0]
497:               
498:               	/* Process the OUTPUT report. */
499:               	APP_KeyboardProcessOutputReport();
00182A  07FFE3     RCALL _APP_KeyboardProcessOutputReport, .LFE1, .LFB2
500:               }
00182C  FA8000     ULNK
00182E  060000     RETURN
501:               
502:               void USBHIDCBSetReportHandler(void)
503:               {
001830  FA0000     LNK #0x0
504:               	/* Prepare to receive the keyboard LED state data through a SET_REPORT
505:               	 * control transfer on endpoint 0.  The host should only send 1 byte,
506:               	 * since this is all that the report descriptor allows it to send. */
507:               	USBEP0Receive((uint8_t*) & CtrlTrfData, USB_EP0_BUFF_SIZE, USBHIDCBSetReportComplete);
001832  208580     MOV #0x858, W0
001834  200FF1     MOV #0xFF, W1
001836  600101     AND W0, W1, W2
001838  208441     MOV #0x844, W1
00183A  784191     MOV.B [W1], W3
00183C  61C1E0     AND.B W3, #0x0, W3
00183E  71C102     IOR.B W3, W2, W2
001840  784882     MOV.B W2, [W1]
001842  DE00C8     LSR W0, #8, W1
001844  208450     MOV #0x845, W0
001846  784110     MOV.B [W0], W2
001848  614160     AND.B W2, #0x0, W2
00184A  714081     IOR.B W2, W1, W1
00184C  784801     MOV.B W1, [W0]
00184E  208470     MOV #0x847, W0
001850  784090     MOV.B [W0], W1
001852  60C0E0     AND.B W1, #0x0, W1
001854  A03401     BSET.B W1, #3
001856  784801     MOV.B W1, [W0]
001858  208480     MOV #0x848, W0
00185A  784090     MOV.B [W0], W1
00185C  60C0E0     AND.B W1, #0x0, W1
00185E  784801     MOV.B W1, [W0]
001860  218200     MOV #0x1820, W0
001862  200FF1     MOV #0xFF, W1
001864  600101     AND W0, W1, W2
001866  208491     MOV #0x849, W1
001868  784191     MOV.B [W1], W3
00186A  61C1E0     AND.B W3, #0x0, W3
00186C  71C102     IOR.B W3, W2, W2
00186E  784882     MOV.B W2, [W1]
001870  DE00C8     LSR W0, #8, W1
001872  2084A0     MOV #0x84A, W0
001874  784110     MOV.B [W0], W2
001876  614160     AND.B W2, #0x0, W2
001878  714081     IOR.B W2, W1, W1
00187A  784801     MOV.B W1, [W0]
00187C  208460     MOV #0x846, W0
00187E  784090     MOV.B [W0], W1
001880  A07401     BSET.B W1, #7
001882  784801     MOV.B W1, [W0]
508:               }
001884  FA8000     ULNK
001886  060000     RETURN
509:               
510:               
511:               //Callback function called by the USB stack, whenever the host sends a new SET_IDLE
512:               //command.
513:               
514:               void USBHIDCBSetIdleRateHandler(uint8_t reportID, uint8_t newIdleRate)
515:               {
001888  FA0002     LNK #0x2
00188A  784F00     MOV.B W0, [W14]
00188C  984711     MOV.B W1, [W14+1]
516:               	//Make sure the report ID matches the keyboard input report id number.
517:               	//If however the firmware doesn't implement/use report ID numbers,
518:               	//then it should be == 0.
519:               	if (reportID == 0) {
00188E  78401E     MOV.B [W14], W0
001890  E00400     CP0.B W0
001892  3A0003     BRA NZ, .L31
520:               		keyboardIdleRate = newIdleRate;
001894  90401E     MOV.B [W14+1], W0
001896  FB8000     ZE W0, W0
001898  884180     MOV W0, keyboardIdleRate
521:               	}
522:               }
00189A  FA8000     ULNK
00189C  060000     RETURN
523:               
524:               
525:               /*******************************************************************************
526:                End of File
527:                */
